/*! For license information please see index.js.LICENSE.txt */
(() => { const t = { 5913: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1208)); const o = r(n(3737)); const s = r(n(1013)); const a = n(4102); const u = n(611); e.default = function (t, e, n) { void 0 === n && (n = {}); for (var r = u.getGeom(t).coordinates, l = 0, c = 0; c < r.length && !(e >= l && c === r.length - 1); c++) { if (l >= e) { const f = e - l; if (f) { const h = i.default(r[c], r[c - 1]) - 180; return o.default(r[c], f, h, n) } return a.point(r[c]) }l += s.default(r[c], r[c + 1], n) } return a.point(r[r.length - 1]) } }, 8517: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1208)); const o = n(4102); const s = r(n(2054)); e.default = function (t, e, n, r) { if (void 0 === r && (r = {}), !o.isObject(r)) throw new Error('options is invalid'); if (!t) throw new Error('startPoint is required'); if (!e) throw new Error('midPoint is required'); if (!n) throw new Error('endPoint is required'); const a = t; const u = e; const l = n; const c = o.bearingToAzimuth(!0 !== r.mercator ? i.default(a, u) : s.default(a, u)); const f = o.bearingToAzimuth(!0 !== r.mercator ? i.default(l, u) : s.default(l, u)); const h = Math.abs(c - f); return !0 === r.explementary ? 360 - h : h } }, 1070: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(1540); const i = 6378137; function o (t) { let e = 0; if (t && t.length > 0) { e += Math.abs(s(t[0])); for (let n = 1; n < t.length; n++)e -= Math.abs(s(t[n])) } return e } function s (t) { let e; let n; let r; let o; let s; let u; let l = 0; const c = t.length; if (c > 2) { for (u = 0; u < c; u++)u === c - 2 ? (r = c - 2, o = c - 1, s = 0) : u === c - 1 ? (r = c - 1, o = 0, s = 1) : (r = u, o = u + 1, s = u + 2), e = t[r], n = t[o], l += (a(t[s][0]) - a(e[0])) * Math.sin(a(n[1])); l = l * i * i / 2 } return l } function a (t) { return t * Math.PI / 180 }e.default = function (t) { return r.geomReduce(t, function (t, e) { return t + (function (t) { let e; let n = 0; switch (t.type) { case 'Polygon':return o(t.coordinates); case 'MultiPolygon':for (e = 0; e < t.coordinates.length; e++)n += o(t.coordinates[e]); return n; case 'Point':case 'MultiPoint':case 'LineString':case 'MultiLineString':return 0 } return 0 }(e)) }, 0) } }, 173: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); const o = n(1383); function s (t, e) { for (var n = [], r = 0, i = t; r < i.length; r++) { const s = i[r]; const a = o.polygonclip(s, e); a.length > 0 && (a[0][0] === a[a.length - 1][0] && a[0][1] === a[a.length - 1][1] || a.push(a[0]), a.length >= 4 && n.push(a)) } return n }e.default = function (t, e) { const n = i.getGeom(t); const a = n.type; const u = t.type === 'Feature' ? t.properties : {}; let l = n.coordinates; switch (a) { case 'LineString':case 'MultiLineString':var c = []; return a === 'LineString' && (l = [l]), l.forEach(function (t) { o.lineclip(t, e, c) }), c.length === 1 ? r.lineString(c[0], u) : r.multiLineString(c, u); case 'Polygon':return r.polygon(s(l, e), u); case 'MultiPolygon':return r.multiPolygon(l.map(function (t) { return s(t, e) }), u); default:throw new Error('geometry ' + a + ' not supported') } } }, 1383: (t, e) => { 'use strict'; function n (t, e, n, r) { return 8 & n ? [t[0] + (e[0] - t[0]) * (r[3] - t[1]) / (e[1] - t[1]), r[3]] : 4 & n ? [t[0] + (e[0] - t[0]) * (r[1] - t[1]) / (e[1] - t[1]), r[1]] : 2 & n ? [r[2], t[1] + (e[1] - t[1]) * (r[2] - t[0]) / (e[0] - t[0])] : 1 & n ? [r[0], t[1] + (e[1] - t[1]) * (r[0] - t[0]) / (e[0] - t[0])] : null } function r (t, e) { let n = 0; return t[0] < e[0] ? n |= 1 : t[0] > e[2] && (n |= 2), t[1] < e[1] ? n |= 4 : t[1] > e[3] && (n |= 8), n }Object.defineProperty(e, '__esModule', { value: !0 }), e.lineclip = function (t, e, i) { let o; let s; let a; let u; let l; const c = t.length; let f = r(t[0], e); let h = []; for (i || (i = []), o = 1; o < c; o++) { for (u = t[o - 1], s = a = r(l = t[o], e); ;) { if (!(f | s)) { h.push(u), s !== a ? (h.push(l), o < c - 1 && (i.push(h), h = [])) : o === c - 1 && h.push(l); break } if (f & s) break; f ? f = r(u = n(u, l, f, e), e) : s = r(l = n(u, l, s, e), e) }f = a } return h.length && i.push(h), i }, e.polygonclip = function (t, e) { let i, o, s, a, u, l, c; for (o = 1; o <= 8; o *= 2) { for (i = [], a = !(r(s = t[t.length - 1], e) & o), u = 0; u < t.length; u++)(c = !(r(l = t[u], e) & o)) !== a && i.push(n(s, l, o, e)), c && i.push(l), s = l, a = c; if (!(t = i).length) break } return i } }, 3652: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); e.default = function (t, e) { void 0 === e && (e = {}); const n = Number(t[0]); const i = Number(t[1]); const o = Number(t[2]); const s = Number(t[3]); if (t.length === 6) throw new Error('@turf/bbox-polygon does not support BBox with 6 positions'); const a = [n, i]; const u = [n, s]; const l = [o, s]; const c = [o, i]; return r.polygon([[a, c, l, u, a]], e.properties, { bbox: t, id: e.id }) } }, 9705: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(1540); function i (t) { const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0]; return r.coordEach(t, function (t) { e[0] > t[0] && (e[0] = t[0]), e[1] > t[1] && (e[1] = t[1]), e[2] < t[0] && (e[2] = t[0]), e[3] < t[1] && (e[3] = t[1]) }), e }i.default = i, e.default = i }, 1208: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); e.default = function t (e, n, o) { if (void 0 === o && (o = {}), !0 === o.final) return (function (e, n) { const r = t(n, e); return (r + 180) % 360 }(e, n)); const s = i.getCoord(e); const a = i.getCoord(n); const u = r.degreesToRadians(s[0]); const l = r.degreesToRadians(a[0]); const c = r.degreesToRadians(s[1]); const f = r.degreesToRadians(a[1]); const h = Math.sin(l - u) * Math.cos(f); const p = Math.cos(c) * Math.sin(f) - Math.sin(c) * Math.cos(f) * Math.cos(l - u); return r.radiansToDegrees(Math.atan2(h, p)) } }, 7478: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4102); const o = n(611); const s = r(n(915)); e.default = function (t, e) { void 0 === e && (e = {}); for (var n = e.resolution || 1e4, r = e.sharpness || 0.85, a = [], u = o.getGeom(t).coordinates.map(function (t) { return { x: t[0], y: t[1] } }), l = new s.default({ duration: n, points: u, sharpness: r }), c = function (t) { const e = l.pos(t); Math.floor(t / 100) % 2 == 0 && a.push([e.x, e.y]) }, f = 0; f < l.duration; f += 10)c(f); return c(l.duration), i.lineString(a, e.properties) } }, 915: (t, e) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const n = (function () { function t (t) { this.points = t.points || [], this.duration = t.duration || 1e4, this.sharpness = t.sharpness || 0.85, this.centers = [], this.controls = [], this.stepLength = t.stepLength || 60, this.length = this.points.length, this.delay = 0; for (var e = 0; e < this.length; e++) this.points[e].z = this.points[e].z || 0; for (e = 0; e < this.length - 1; e++) { const n = this.points[e]; const r = this.points[e + 1]; this.centers.push({ x: (n.x + r.x) / 2, y: (n.y + r.y) / 2, z: (n.z + r.z) / 2 }) } for (this.controls.push([this.points[0], this.points[0]]), e = 0; e < this.centers.length - 1; e++) { const i = this.points[e + 1].x - (this.centers[e].x + this.centers[e + 1].x) / 2; const o = this.points[e + 1].y - (this.centers[e].y + this.centers[e + 1].y) / 2; const s = this.points[e + 1].z - (this.centers[e].y + this.centers[e + 1].z) / 2; this.controls.push([{ x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e].x + i), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e].y + o), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e].z + s) }, { x: (1 - this.sharpness) * this.points[e + 1].x + this.sharpness * (this.centers[e + 1].x + i), y: (1 - this.sharpness) * this.points[e + 1].y + this.sharpness * (this.centers[e + 1].y + o), z: (1 - this.sharpness) * this.points[e + 1].z + this.sharpness * (this.centers[e + 1].z + s) }]) } return this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]), this.steps = this.cacheSteps(this.stepLength), this } return t.prototype.cacheSteps = function (t) { const e = []; let n = this.pos(0); e.push(0); for (let r = 0; r < this.duration; r += 10) { const i = this.pos(r); Math.sqrt((i.x - n.x) * (i.x - n.x) + (i.y - n.y) * (i.y - n.y) + (i.z - n.z) * (i.z - n.z)) > t && (e.push(r), n = i) } return e }, t.prototype.vector = function (t) { const e = this.pos(t + 10); const n = this.pos(t - 10); return { angle: 180 * Math.atan2(e.y - n.y, e.x - n.x) / 3.14, speed: Math.sqrt((n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y) + (n.z - e.z) * (n.z - e.z)) } }, t.prototype.pos = function (t) { let e = t - this.delay; e < 0 && (e = 0), e > this.duration && (e = this.duration - 1); const n = e / this.duration; if (n >= 1) return this.points[this.length - 1]; const r = Math.floor((this.points.length - 1) * n); return (function (t, e, n, r, i) { const o = (function (t) { const e = t * t; return [e * t, 3 * e * (1 - t), 3 * t * (1 - t) * (1 - t), (1 - t) * (1 - t) * (1 - t)] }(t)); return { x: i.x * o[0] + r.x * o[1] + n.x * o[2] + e.x * o[3], y: i.y * o[0] + r.y * o[1] + n.y * o[2] + e.y * o[3], z: i.z * o[0] + r.z * o[1] + n.z * o[2] + e.z * o[3] } }((this.length - 1) * n - r, this.points[r], this.controls[r][1], this.controls[r + 1][0], this.points[r + 1])) }, t }()); e.default = n }, 3809: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(611); e.default = function (t) { for (var e, n, i = r.getCoords(t), o = 0, s = 1; s < i.length;)e = n || i[0], o += ((n = i[s])[0] - e[0]) * (n[1] + e[1]), s++; return o > 0 } }, 4766: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(9705)); const o = r(n(8147)); const s = r(n(2793)); const a = n(611); function u (t, e) { let n; let r = !1; for (n = 0; n < t.coordinates.length; n++) if (y(t.coordinates[n], e.coordinates)) { r = !0; break } return r } function l (t, e) { for (let n = 0, r = e.coordinates; n < r.length; n++) { for (var i = r[n], o = !1, s = 0, a = t.coordinates; s < a.length; s++) if (y(i, a[s])) { o = !0; break } if (!o) return !1 } return !0 } function c (t, e) { for (var n = !1, r = 0, i = e.coordinates; r < i.length; r++) { const o = i[r]; if (s.default(o, t, { ignoreEndVertices: !0 }) && (n = !0), !s.default(o, t)) return !1 } return !!n } function f (t, e) { for (let n = 0, r = e.coordinates; n < r.length; n++) { const i = r[n]; if (!o.default(i, t, { ignoreBoundary: !0 })) return !1 } return !0 } function h (t, e) { for (var n = !1, r = 0, i = e.coordinates; r < i.length; r++) { const o = i[r]; if (s.default({ type: 'Point', coordinates: o }, t, { ignoreEndVertices: !0 }) && (n = !0), !s.default({ type: 'Point', coordinates: o }, t, { ignoreEndVertices: !1 })) return !1 } return n } function p (t, e) { let n = !1; let r = 0; if (!d(i.default(t), i.default(e))) return !1; for (;r < e.coordinates.length - 1; r++) { const s = v(e.coordinates[r], e.coordinates[r + 1]); if (o.default({ type: 'Point', coordinates: s }, t, { ignoreBoundary: !0 })) { n = !0; break } } return n } function g (t, e) { if (t.type === 'Feature' && t.geometry === null) return !1; if (e.type === 'Feature' && e.geometry === null) return !1; if (!d(i.default(t), i.default(e))) return !1; for (let n = 0, r = a.getGeom(e).coordinates; n < r.length; n++) for (let s = 0, u = r[n]; s < u.length; s++) { const l = u[s]; if (!o.default(l, t)) return !1 } return !0 } function d (t, e) { return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3]) } function y (t, e) { return t[0] === e[0] && t[1] === e[1] } function v (t, e) { return [(t[0] + e[0]) / 2, (t[1] + e[1]) / 2] }e.default = function (t, e) { const n = a.getGeom(t); const r = a.getGeom(e); const i = n.type; const d = r.type; const v = n.coordinates; const _ = r.coordinates; switch (i) { case 'Point':if (d === 'Point') return y(v, _); throw new Error('feature2 ' + d + ' geometry not supported'); case 'MultiPoint':switch (d) { case 'Point':return u(n, r); case 'MultiPoint':return l(n, r); default:throw new Error('feature2 ' + d + ' geometry not supported') } case 'LineString':switch (d) { case 'Point':return s.default(r, n, { ignoreEndVertices: !0 }); case 'LineString':return h(n, r); case 'MultiPoint':return c(n, r); default:throw new Error('feature2 ' + d + ' geometry not supported') } case 'Polygon':switch (d) { case 'Point':return o.default(r, n, { ignoreBoundary: !0 }); case 'LineString':return p(n, r); case 'Polygon':return g(n, r); case 'MultiPoint':return f(n, r); default:throw new Error('feature2 ' + d + ' geometry not supported') } default:throw new Error('feature1 ' + i + ' geometry not supported') } }, e.isPointInMultiPoint = u, e.isMultiPointInMultiPoint = l, e.isMultiPointOnLine = c, e.isMultiPointInPoly = f, e.isLineOnLine = h, e.isLineInPoly = p, e.isPolyInPoly = g, e.doBBoxOverlap = d, e.compareCoords = y, e.getMidpoint = v }, 7656: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(3663)); const o = n(7383); const s = r(n(8147)); const a = n(611); const u = n(4102); function l (t, e) { for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && !n && !r;) { for (let s = 0; s < e.coordinates.length - 1; s++) { let a = !0; s !== 0 && s !== e.coordinates.length - 2 || (a = !1), h(e.coordinates[s], e.coordinates[s + 1], t.coordinates[o], a) ? n = !0 : r = !0 }o++ } return n && r } function c (t, e) { const n = o.polygonToLine(e); return i.default(t, n).features.length > 0 } function f (t, e) { for (var n = !1, r = !1, i = t.coordinates.length, o = 0; o < i && (!n || !r); o++)s.default(u.point(t.coordinates[o]), e) ? n = !0 : r = !0; return r && n } function h (t, e, n, r) { const i = n[0] - t[0]; const o = n[1] - t[1]; const s = e[0] - t[0]; const a = e[1] - t[1]; return i * a - o * s == 0 && (r ? Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : a > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1] : Math.abs(s) >= Math.abs(a) ? s > 0 ? t[0] < n[0] && n[0] < e[0] : e[0] < n[0] && n[0] < t[0] : a > 0 ? t[1] < n[1] && n[1] < e[1] : e[1] < n[1] && n[1] < t[1]) }e.default = function (t, e) { const n = a.getGeom(t); const r = a.getGeom(e); const o = n.type; const s = r.type; switch (o) { case 'MultiPoint':switch (s) { case 'LineString':return l(n, r); case 'Polygon':return f(n, r); default:throw new Error('feature2 ' + s + ' geometry not supported') } case 'LineString':switch (s) { case 'MultiPoint':return l(r, n); case 'LineString':return (function (t, e) { if (i.default(t, e).features.length > 0) for (let n = 0; n < t.coordinates.length - 1; n++) for (let r = 0; r < e.coordinates.length - 1; r++) { let o = !0; if (r !== 0 && r !== e.coordinates.length - 2 || (o = !1), h(t.coordinates[n], t.coordinates[n + 1], e.coordinates[r], o)) return !0 } return !1 }(n, r)); case 'Polygon':return c(n, r); default:throw new Error('feature2 ' + s + ' geometry not supported') } case 'Polygon':switch (s) { case 'MultiPoint':return f(r, n); case 'LineString':return c(r, n); default:throw new Error('feature2 ' + s + ' geometry not supported') } default:throw new Error('feature1 ' + o + ' geometry not supported') } } }, 5883: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(8147)); const o = r(n(3663)); const s = n(1540); const a = r(n(7383)); function u (t, e) { for (let n = 0; n < t.coordinates.length - 1; n++) if (c(t.coordinates[n], t.coordinates[n + 1], e.coordinates)) return !0; return !1 } function l (t, e) { for (let n = 0, r = e.coordinates; n < r.length; n++) { const s = r[n]; if (i.default(s, t)) return !0 } return o.default(e, a.default(t)).features.length > 0 } function c (t, e, n) { const r = n[0] - t[0]; const i = n[1] - t[1]; const o = e[0] - t[0]; const s = e[1] - t[1]; return r * s - i * o == 0 && (Math.abs(o) >= Math.abs(s) ? o > 0 ? t[0] <= n[0] && n[0] <= e[0] : e[0] <= n[0] && n[0] <= t[0] : s > 0 ? t[1] <= n[1] && n[1] <= e[1] : e[1] <= n[1] && n[1] <= t[1]) }e.default = function (t, e) { let n = !0; return s.flattenEach(t, function (t) { s.flattenEach(e, function (e) { if (!1 === n) return !1; n = (function (t, e) { switch (t.type) { case 'Point':switch (e.type) { case 'Point':return s = t.coordinates, c = e.coordinates, !(s[0] === c[0] && s[1] === c[1]); case 'LineString':return !u(e, t); case 'Polygon':return !i.default(t, e) } break; case 'LineString':switch (e.type) { case 'Point':return !u(t, e); case 'LineString':return n = t, r = e, !(o.default(n, r).features.length > 0); case 'Polygon':return !l(e, t) } break; case 'Polygon':switch (e.type) { case 'Point':return !i.default(e, t); case 'LineString':return !l(t, e); case 'Polygon':return !(function (t, e) { for (let n = 0, r = t.coordinates[0]; n < r.length; n++) { const s = r[n]; if (i.default(s, e)) return !0 } for (let u = 0, l = e.coordinates[0]; u < l.length; u++) { const c = l[u]; if (i.default(c, t)) return !0 } return o.default(a.default(t), a.default(e)).features.length > 0 }(e, t)) } } let n, r, s, c; return !1 }(t.geometry, e.geometry)) }) }), n } }, 9482: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(9657)); const o = r(n(1435)); const s = n(611); e.default = function (t, e) { return s.getGeom(t).type === s.getGeom(e).type && new i.default({ precision: 6 }).compare(o.default(t), o.default(e)) } }, 5745: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(5883)); const o = n(1540); e.default = function (t, e) { let n = !1; return o.flattenEach(t, function (t) { o.flattenEach(e, function (e) { if (!0 === n) return !0; n = !i.default(t.geometry, e.geometry) }) }), n } }, 7612: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(1540); const o = n(611); const s = r(n(273)); const a = r(n(3663)); const u = r(n(9657)); e.default = function (t, e) { const n = o.getGeom(t); const r = o.getGeom(e); const l = n.type; const c = r.type; if (l === 'MultiPoint' && c !== 'MultiPoint' || (l === 'LineString' || l === 'MultiLineString') && c !== 'LineString' && c !== 'MultiLineString' || (l === 'Polygon' || l === 'MultiPolygon') && c !== 'Polygon' && c !== 'MultiPolygon') throw new Error('features must be of the same type'); if (l === 'Point') throw new Error('Point geometry not supported'); if (new u.default({ precision: 6 }).compare(t, e)) return !1; let f = 0; switch (l) { case 'MultiPoint':for (let h = 0; h < n.coordinates.length; h++) for (let p = 0; p < r.coordinates.length; p++) { const g = n.coordinates[h]; const d = r.coordinates[p]; if (g[0] === d[0] && g[1] === d[1]) return !0 } return !1; case 'LineString':case 'MultiLineString':i.segmentEach(t, function (t) { i.segmentEach(e, function (e) { s.default(t, e).features.length && f++ }) }); break; case 'Polygon':case 'MultiPolygon':i.segmentEach(t, function (t) { i.segmentEach(e, function (e) { a.default(t, e).features.length && f++ }) }) } return f > 0 } }, 4840: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1435)); const o = r(n(4590)); const s = r(n(2054)); const a = n(4102); function u (t, e) { return a.bearingToAzimuth(s.default(t[0], t[1])) === a.bearingToAzimuth(s.default(e[0], e[1])) } function l (t, e) { if (t.geometry && t.geometry.type) return t.geometry.type; if (t.type) return t.type; throw new Error('Invalid GeoJSON object for ' + e) }e.default = function (t, e) { if (!t) throw new Error('line1 is required'); if (!e) throw new Error('line2 is required'); if (l(t, 'line1') !== 'LineString') throw new Error('line1 must be a LineString'); if (l(e, 'line2') !== 'LineString') throw new Error('line2 must be a LineString'); for (let n = o.default(i.default(t)).features, r = o.default(i.default(e)).features, s = 0; s < n.length; s++) { const a = n[s].geometry.coordinates; if (!r[s]) break; if (!u(a, r[s].geometry.coordinates)) return !1 } return !0 } }, 8147: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(611); function i (t, e, n) { let r = !1; e[0][0] === e[e.length - 1][0] && e[0][1] === e[e.length - 1][1] && (e = e.slice(0, e.length - 1)); for (let i = 0, o = e.length - 1; i < e.length; o = i++) { const s = e[i][0]; const a = e[i][1]; const u = e[o][0]; const l = e[o][1]; if (t[1] * (s - u) + a * (u - t[0]) + l * (t[0] - s) == 0 && (s - t[0]) * (u - t[0]) <= 0 && (a - t[1]) * (l - t[1]) <= 0) return !n; a > t[1] != l > t[1] && t[0] < (u - s) * (t[1] - a) / (l - a) + s && (r = !r) } return r }e.default = function (t, e, n) { if (void 0 === n && (n = {}), !t) throw new Error('point is required'); if (!e) throw new Error('polygon is required'); const o = r.getCoord(t); const s = r.getGeom(e); const a = s.type; const u = e.bbox; let l = s.coordinates; if (u && !1 === (function (t, e) { return e[0] <= t[0] && e[1] <= t[1] && e[2] >= t[0] && e[3] >= t[1] }(o, u))) return !1; a === 'Polygon' && (l = [l]); for (var c = !1, f = 0; f < l.length && !c; f++) if (i(o, l[f][0], n.ignoreBoundary)) { for (var h = !1, p = 1; p < l[f].length && !h;)i(o, l[f][p], !n.ignoreBoundary) && (h = !0), p++; h || (c = !0) } return c } }, 2793: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(611); function i (t, e, n, r, i) { const o = n[0]; const s = n[1]; const a = t[0]; const u = t[1]; const l = e[0]; const c = e[1]; const f = l - a; const h = c - u; const p = (n[0] - a) * h - (n[1] - u) * f; if (i !== null) { if (Math.abs(p) > i) return !1 } else if (p !== 0) return !1; return r ? r === 'start' ? Math.abs(f) >= Math.abs(h) ? f > 0 ? a < o && o <= l : l <= o && o < a : h > 0 ? u < s && s <= c : c <= s && s < u : r === 'end' ? Math.abs(f) >= Math.abs(h) ? f > 0 ? a <= o && o < l : l < o && o <= a : h > 0 ? u <= s && s < c : c < s && s <= u : r === 'both' && (Math.abs(f) >= Math.abs(h) ? f > 0 ? a < o && o < l : l < o && o < a : h > 0 ? u < s && s < c : c < s && s < u) : Math.abs(f) >= Math.abs(h) ? f > 0 ? a <= o && o <= l : l <= o && o <= a : h > 0 ? u <= s && s <= c : c <= s && s <= u }e.default = function (t, e, n) { void 0 === n && (n = {}); for (let o = r.getCoord(t), s = r.getCoords(e), a = 0; a < s.length - 1; a++) { let u = !1; if (n.ignoreEndVertices && (a === 0 && (u = 'start'), a === s.length - 2 && (u = 'end'), a === 0 && a + 1 === s.length - 1 && (u = 'both')), i(s[a], s[a + 1], o, u, void 0 === n.epsilon ? null : n.epsilon)) return !0 } return !1 } }, 5184: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(9705)); const o = r(n(2793)); const s = r(n(8147)); const a = n(611); function u (t, e) { return !(t[0] > e[0] || t[2] < e[2] || t[1] > e[1] || t[3] < e[3]) } function l (t, e) { return t[0] === e[0] && t[1] === e[1] }e.default = function (t, e) { const n = a.getGeom(t); const r = a.getGeom(e); const c = n.type; const f = r.type; switch (c) { case 'Point':switch (f) { case 'MultiPoint':return (function (t, e) { let n; let r = !1; for (n = 0; n < e.coordinates.length; n++) if (l(e.coordinates[n], t.coordinates)) { r = !0; break } return r }(n, r)); case 'LineString':return o.default(n, r, { ignoreEndVertices: !0 }); case 'Polygon':case 'MultiPolygon':return s.default(n, r, { ignoreBoundary: !0 }); default:throw new Error('feature2 ' + f + ' geometry not supported') } case 'MultiPoint':switch (f) { case 'MultiPoint':return (function (t, e) { for (let n = 0; n < t.coordinates.length; n++) { for (var r = !1, i = 0; i < e.coordinates.length; i++)l(t.coordinates[n], e.coordinates[i]) && (r = !0); if (!r) return !1 } return !0 }(n, r)); case 'LineString':return (function (t, e) { for (var n = !1, r = 0; r < t.coordinates.length; r++) { if (!o.default(t.coordinates[r], e)) return !1; n || (n = o.default(t.coordinates[r], e, { ignoreEndVertices: !0 })) } return n }(n, r)); case 'Polygon':case 'MultiPolygon':return (function (t, e) { for (var n = !0, r = !1, i = 0; i < t.coordinates.length; i++) { if (!(r = s.default(t.coordinates[1], e))) { n = !1; break }r = s.default(t.coordinates[1], e, { ignoreBoundary: !0 }) } return n && r }(n, r)); default:throw new Error('feature2 ' + f + ' geometry not supported') } case 'LineString':switch (f) { case 'LineString':return (function (t, e) { for (let n = 0; n < t.coordinates.length; n++) if (!o.default(t.coordinates[n], e)) return !1; return !0 }(n, r)); case 'Polygon':case 'MultiPolygon':return (function (t, e) { let n, r; if (!u(i.default(e), i.default(t))) return !1; for (var o = !1, a = 0; a < t.coordinates.length - 1; a++) { if (!s.default(t.coordinates[a], e)) return !1; if (o || (o = s.default(t.coordinates[a], e, { ignoreBoundary: !0 })), !o) { const l = (n = t.coordinates[a], r = t.coordinates[a + 1], [(n[0] + r[0]) / 2, (n[1] + r[1]) / 2]); o = s.default(l, e, { ignoreBoundary: !0 }) } } return o }(n, r)); default:throw new Error('feature2 ' + f + ' geometry not supported') } case 'Polygon':switch (f) { case 'Polygon':case 'MultiPolygon':return (function (t, e) { const n = i.default(t); if (!u(i.default(e), n)) return !1; for (let r = 0; r < t.coordinates[0].length; r++) if (!s.default(t.coordinates[0][r], e)) return !1; return !0 }(n, r)); default:throw new Error('feature2 ' + f + ' geometry not supported') } default:throw new Error('feature1 ' + c + ' geometry not supported') } } }, 5950: (t, e, n) => { 'use strict'; const r = n(8230); const i = n(675); const o = n(1540); const s = n(1688); const a = n(4102); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(r); function c (t, e, n) { const r = (n = n || {}).units || 'kilometers'; const i = n.steps || 8; if (!t) throw new Error('geojson is required'); if (typeof n !== 'object') throw new Error('options must be an object'); if (typeof i !== 'number') throw new Error('steps must be an number'); if (void 0 === e) throw new Error('radius is required'); if (i <= 0) throw new Error('steps must be greater than 0'); const s = []; switch (t.type) { case 'GeometryCollection':return o.geomEach(t, function (t) { const n = f(t, e, r, i); n && s.push(n) }), a.featureCollection(s); case 'FeatureCollection':return o.featureEach(t, function (t) { const n = f(t, e, r, i); n && o.featureEach(n, function (t) { t && s.push(t) }) }), a.featureCollection(s) } return f(t, e, r, i) } function f (t, e, n, r) { const u = t.properties || {}; const c = t.type === 'Feature' ? t.geometry : t; if (c.type === 'GeometryCollection') { const d = []; return o.geomEach(t, function (t) { const i = f(t, e, n, r); i && d.push(i) }), a.featureCollection(d) } const y = (function (t) { const e = l.default(t).geometry.coordinates; const n = [-e[0], -e[1]]; return s.geoAzimuthalEquidistant().rotate(n).scale(a.earthRadius) }(c)); const v = { type: c.type, coordinates: p(c.coordinates, y) }; const _ = (new i.GeoJSONReader()).read(v); const m = a.radiansToLength(a.lengthToRadians(e, n), 'meters'); let x = i.BufferOp.bufferOp(_, m, r); if (!h((x = (new i.GeoJSONWriter()).write(x)).coordinates)) { const b = { type: x.type, coordinates: g(x.coordinates, y) }; return a.feature(b, u) } } function h (t) { return Array.isArray(t[0]) ? h(t[0]) : isNaN(t[0]) } function p (t, e) { return typeof t[0] !== 'object' ? e(t) : t.map(function (t) { return p(t, e) }) } function g (t, e) { return typeof t[0] !== 'object' ? e.invert(t) : t.map(function (t) { return g(t, e) }) }t.exports = c, t.exports.default = c }, 6320: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(1540); const i = n(4102); e.default = function (t, e) { void 0 === e && (e = {}); let n = 0; let o = 0; let s = 0; return r.geomEach(t, function (t, a, u) { let l = e.weight ? u == null ? void 0 : u[e.weight] : void 0; if (l = l == null ? 1 : l, !i.isNumber(l)) throw new Error('weight value must be a number for feature index ' + a); (l = Number(l)) > 0 && r.coordEach(t, function (t) { n += t[0] * l, o += t[1] * l, s += l }) }), i.point([n / s, o / s], e.properties, e) } }, 2935: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6320)); const o = r(n(1013)); const s = r(n(6338)); const a = n(4102); const u = n(1540); function l (t, e, n, r, i) { const s = r.tolerance || 0.001; let c = 0; let f = 0; let h = 0; let p = 0; if (u.featureEach(n, function (e) { let n; const r = (n = e.properties) === null || void 0 === n ? void 0 : n.weight; let i = r == null ? 1 : r; if (i = Number(i), !a.isNumber(i)) throw new Error('weight value must be a number'); if (i > 0) { p += 1; let s = i * o.default(e, t); s === 0 && (s = 1); const u = i / s; c += e.geometry.coordinates[0] * u, f += e.geometry.coordinates[1] * u, h += u } }), p < 1) throw new Error('no features to measure'); const g = c / h; const d = f / h; return p === 1 || i === 0 || Math.abs(g - e[0]) < s && Math.abs(d - e[1]) < s ? a.point([g, d], { medianCandidates: r.medianCandidates }) : (r.medianCandidates.push([g, d]), l([g, d], t, n, r, i - 1)) }e.default = function (t, e) { if (void 0 === e && (e = {}), e = e || {}, !a.isObject(e)) throw new Error('options is invalid'); const n = e.counter || 10; if (!a.isNumber(n)) throw new Error('counter must be a number'); const r = e.weight; const o = i.default(t, { weight: e.weight }); const c = a.featureCollection([]); u.featureEach(t, function (t) { let e; c.features.push(s.default(t, { properties: { weight: (e = t.properties) === null || void 0 === e ? void 0 : e[r] } })) }); const f = { tolerance: e.tolerance, medianCandidates: [] }; return l(o.geometry.coordinates, [0, 0], c, f, n) } }, 5084: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(7382)); const o = r(n(6338)); const s = n(4102); const a = n(611); const u = n(1540); e.default = function t (e, n) { switch (void 0 === n && (n = {}), a.getType(e)) { case 'Point':return s.point(a.getCoord(e), n.properties); case 'Polygon':var r = []; u.coordEach(e, function (t) { r.push(t) }); var l; var c; var f; var h; var p; var g; var d; var y; var v = o.default(e, { properties: n.properties }); var _ = v.geometry.coordinates; var m = 0; var x = 0; var b = 0; var E = r.map(function (t) { return [t[0] - _[0], t[1] - _[1]] }); for (l = 0; l < r.length - 1; l++)h = (c = E[l])[0], g = c[1], p = (f = E[l + 1])[0], b += y = h * (d = f[1]) - p * g, m += (h + p) * y, x += (g + d) * y; if (b === 0) return v; var w = 1 / (0.5 * b * 6); return s.point([_[0] + w * m, _[1] + w * x], n.properties); default:var I = i.default(e); return I ? t(I, { properties: n.properties }) : o.default(e, { properties: n.properties }) } } }, 8230: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(9705)); const o = n(4102); e.default = function (t, e) { void 0 === e && (e = {}); const n = i.default(t); const r = (n[0] + n[2]) / 2; const s = (n[1] + n[3]) / 2; return o.point([r, s], e.properties, e) } }, 6338: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(1540); const i = n(4102); e.default = function (t, e) { void 0 === e && (e = {}); let n = 0; let o = 0; let s = 0; return r.coordEach(t, function (t) { n += t[0], o += t[1], s++ }, !0), i.point([n / s, o / s], e.properties) } }, 265: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(3737)); const o = n(4102); e.default = function (t, e, n) { void 0 === n && (n = {}); for (var r = n.steps || 64, s = n.properties ? n.properties : !Array.isArray(t) && t.type === 'Feature' && t.properties ? t.properties : {}, a = [], u = 0; u < r; u++)a.push(i.default(t, e, -360 * u / r, n).geometry.coordinates); return a.push(a[0]), o.polygon([a], s) } }, 1435: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); function o (t) { const e = i.getCoords(t); if (e.length === 2 && !s(e[0], e[1])) return e; const n = []; const r = e.length - 1; let o = n.length; n.push(e[0]); for (let u = 1; u < r; u++) { const l = n[n.length - 1]; e[u][0] === l[0] && e[u][1] === l[1] || (n.push(e[u]), (o = n.length) > 2 && a(n[o - 3], n[o - 1], n[o - 2]) && n.splice(n.length - 2, 1)) } if (n.push(e[e.length - 1]), o = n.length, s(e[0], e[e.length - 1]) && o < 4) throw new Error('invalid polygon'); return a(n[o - 3], n[o - 1], n[o - 2]) && n.splice(n.length - 2, 1), n } function s (t, e) { return t[0] === e[0] && t[1] === e[1] } function a (t, e, n) { const r = n[0]; const i = n[1]; const o = t[0]; const s = t[1]; const a = e[0]; const u = e[1]; const l = a - o; const c = u - s; return (r - o) * c - (i - s) * l == 0 && (Math.abs(l) >= Math.abs(c) ? l > 0 ? o <= r && r <= a : a <= r && r <= o : c > 0 ? s <= i && i <= u : u <= i && i <= s) }e.default = function (t, e) { void 0 === e && (e = {}); const n = typeof e === 'object' ? e.mutate : e; if (!t) throw new Error('geojson is required'); const s = i.getType(t); let a = []; switch (s) { case 'LineString':a = o(t); break; case 'MultiLineString':case 'Polygon':i.getCoords(t).forEach(function (t) { a.push(o(t)) }); break; case 'MultiPolygon':i.getCoords(t).forEach(function (t) { const e = []; t.forEach(function (t) { e.push(o(t)) }), a.push(e) }); break; case 'Point':return t; case 'MultiPoint':var u = {}; i.getCoords(t).forEach(function (t) { const e = t.join('-'); Object.prototype.hasOwnProperty.call(u, e) || (a.push(t), u[e] = !0) }); break; default:throw new Error(s + ' geometry not supported') } return t.coordinates ? !0 === n ? (t.coordinates = a, t) : { type: s, coordinates: a } : !0 === n ? (t.geometry.coordinates = a, t) : r.feature({ type: s, coordinates: a }, t.properties, { bbox: t.bbox, id: t.id }) } }, 6565: (t, e) => { 'use strict'; function n (t) { const e = { type: 'Feature' }; return Object.keys(t).forEach(function (n) { switch (n) { case 'type':case 'properties':case 'geometry':return; default:e[n] = t[n] } }), e.properties = r(t.properties), e.geometry = i(t.geometry), e } function r (t) { const e = {}; return t ? (Object.keys(t).forEach(function (n) { const i = t[n]; typeof i === 'object' ? i === null ? e[n] = null : Array.isArray(i) ? e[n] = i.map(function (t) { return t }) : e[n] = r(i) : e[n] = i }), e) : e } function i (t) { const e = { type: t.type }; return t.bbox && (e.bbox = t.bbox), t.type === 'GeometryCollection' ? (e.geometries = t.geometries.map(function (t) { return i(t) }), e) : (e.coordinates = o(t.coordinates), e) } function o (t) { const e = t; return typeof e[0] !== 'object' ? e.slice() : e.map(function (t) { return o(t) }) }Object.defineProperty(e, '__esModule', { value: !0 }), e.default = function (t) { if (!t) throw new Error('geojson is required'); switch (t.type) { case 'Feature':return n(t); case 'FeatureCollection':return (function (t) { const e = { type: 'FeatureCollection' }; return Object.keys(t).forEach(function (n) { switch (n) { case 'type':case 'features':return; default:e[n] = t[n] } }), e.features = t.features.map(function (t) { return n(t) }), e }(t)); case 'Point':case 'LineString':case 'Polygon':case 'MultiPoint':case 'MultiLineString':case 'MultiPolygon':case 'GeometryCollection':return i(t); default:throw new Error('unknown GeoJSON type') } } }, 1495: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6565)); const o = r(n(1013)); const s = n(1540); const a = n(4102); const u = r(n(2606)); e.default = function (t, e, n) { void 0 === n && (n = {}), !0 !== n.mutate && (t = i.default(t)), n.minPoints = n.minPoints || 3; const r = new u.default.DBSCAN(); const l = r.run(s.coordAll(t), a.convertLength(e, n.units), n.minPoints, o.default); let c = -1; return l.forEach(function (e) { c++, e.forEach(function (e) { const n = t.features[e]; n.properties || (n.properties = {}), n.properties.cluster = c, n.properties.dbscan = 'core' }) }), r.noise.forEach(function (e) { const n = t.features[e]; n.properties || (n.properties = {}), n.properties.cluster ? n.properties.dbscan = 'edge' : n.properties.dbscan = 'noise' }), t } }, 6398: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6565)); const o = n(1540); const s = r(n(1160)); e.default = function (t, e) { void 0 === e && (e = {}); const n = t.features.length; e.numberOfClusters = e.numberOfClusters || Math.round(Math.sqrt(n / 2)), e.numberOfClusters > n && (e.numberOfClusters = n), !0 !== e.mutate && (t = i.default(t)); const r = o.coordAll(t); const a = r.slice(0, e.numberOfClusters); const u = s.default(r, e.numberOfClusters, a); const l = {}; return u.centroids.forEach(function (t, e) { l[e] = t }), o.featureEach(t, function (t, e) { const n = u.idxs[e]; t.properties.cluster = n, t.properties.centroid = l[n] }), t } }, 3140: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(1540); const i = n(4102); function o (t, e, n) { if (!t) throw new Error('geojson is required'); if (t.type !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection'); if (e == null) throw new Error('property is required'); for (let r = s(t, e), o = Object.keys(r), a = 0; a < o.length; a++) { for (var u = o[a], l = r[u], c = [], f = 0; f < l.length; f++)c.push(t.features[l[f]]); n(i.featureCollection(c), u, a) } } function s (t, e) { const n = {}; return r.featureEach(t, function (t, r) { const i = t.properties || {}; if (Object.prototype.hasOwnProperty.call(i, String(e))) { const o = i[e]; Object.prototype.hasOwnProperty.call(n, o) ? n[o].push(r) : n[o] = [r] } }), n } function a (t, e) { if (void 0 === t) return !1; const n = typeof e; if (n === 'number' || n === 'string') return Object.prototype.hasOwnProperty.call(t, e); if (Array.isArray(e)) { for (let r = 0; r < e.length; r++) if (!a(t, e[r])) return !1; return !0 } return u(t, e) } function u (t, e) { for (let n = Object.keys(e), r = 0; r < n.length; r++) { const i = n[r]; if (t[i] !== e[i]) return !1 } return !0 }e.getCluster = function (t, e) { if (!t) throw new Error('geojson is required'); if (t.type !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection'); if (e == null) throw new Error('filter is required'); const n = []; return r.featureEach(t, function (t) { a(t.properties, e) && n.push(t) }), i.featureCollection(n) }, e.clusterEach = o, e.clusterReduce = function (t, e, n, r) { let i = r; return o(t, e, function (t, e, o) { i = o === 0 && void 0 === r ? t : n(i, t, e, o) }), i }, e.createBins = s, e.applyFilter = a, e.propertiesContainsFilter = u, e.filterProperties = function (t, e) { if (!e) return {}; if (!e.length) return {}; for (var n = {}, r = 0; r < e.length; r++) { const i = e[r]; Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]) } return n } }, 305: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(9705)); const o = r(n(8147)); const s = r(n(5510)); e.default = function (t, e, n, r) { const a = s.default(6); const u = e.features.map(function (t) { let e; return { minX: t.geometry.coordinates[0], minY: t.geometry.coordinates[1], maxX: t.geometry.coordinates[0], maxY: t.geometry.coordinates[1], property: (e = t.properties) === null || void 0 === e ? void 0 : e[n] } }); return a.load(u), t.features.forEach(function (t) { t.properties || (t.properties = {}); const e = i.default(t); const n = a.search({ minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] }); const s = []; n.forEach(function (e) { o.default([e.minX, e.minY], t) && s.push(e.property) }), t.properties[r] = s }), t } }, 8141: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(1540); e.default = function (t) { const e = { MultiPoint: { coordinates: [], properties: [] }, MultiLineString: { coordinates: [], properties: [] }, MultiPolygon: { coordinates: [], properties: [] } }; return i.featureEach(t, function (t) { let n, r, i, o; switch ((o = t.geometry) === null || void 0 === o ? void 0 : o.type) { case 'Point':e.MultiPoint.coordinates.push(t.geometry.coordinates), e.MultiPoint.properties.push(t.properties); break; case 'MultiPoint':(n = e.MultiPoint.coordinates).push.apply(n, t.geometry.coordinates), e.MultiPoint.properties.push(t.properties); break; case 'LineString':e.MultiLineString.coordinates.push(t.geometry.coordinates), e.MultiLineString.properties.push(t.properties); break; case 'MultiLineString':(r = e.MultiLineString.coordinates).push.apply(r, t.geometry.coordinates), e.MultiLineString.properties.push(t.properties); break; case 'Polygon':e.MultiPolygon.coordinates.push(t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties); break; case 'MultiPolygon':(i = e.MultiPolygon.coordinates).push.apply(i, t.geometry.coordinates), e.MultiPolygon.properties.push(t.properties) } }), r.featureCollection(Object.keys(e).filter(function (t) { return e[t].coordinates.length }).sort().map(function (t) { const n = { type: t, coordinates: e[t].coordinates }; const i = { collectedProperties: e[t].properties }; return r.feature(n, i) })) } }, 8538: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1013)); const o = n(4102); const s = n(1540); const a = r(n(8829)); const u = r(n(5878)); e.default = function (t, e) { void 0 === e && (e = {}); const n = e.maxEdge || 1 / 0; const r = (function (t) { const e = []; const n = {}; return s.featureEach(t, function (t) { if (t.geometry) { const r = t.geometry.coordinates.join('-'); Object.prototype.hasOwnProperty.call(n, r) || (e.push(t), n[r] = !0) } }), o.featureCollection(e) }(t)); const l = a.default(r); if (l.features = l.features.filter(function (t) { const r = t.geometry.coordinates[0][0]; const o = t.geometry.coordinates[0][1]; const s = t.geometry.coordinates[0][2]; const a = i.default(r, o, e); const u = i.default(o, s, e); const l = i.default(r, s, e); return a <= n && u <= n && l <= n }), l.features.length < 1) return null; const c = u.default(l); return c.coordinates.length === 1 && (c.coordinates = c.coordinates[0], c.type = 'Polygon'), o.feature(c) } }, 5878: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6565)); const o = n(4102); const s = n(611); const a = n(1540); const u = r(n(4692)); const l = r(n(2387)); e.default = function (t, e) { if (void 0 === e && (e = {}), e = e || {}, !o.isObject(e)) throw new Error('options is invalid'); const n = e.mutate; if (s.getType(t) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection'); if (!t.features.length) throw new Error('geojson is empty'); !1 !== n && void 0 !== n || (t = i.default(t)); const r = (function (t) { const e = {}; a.flattenEach(t, function (t) { e[t.geometry.type] = !0 }); const n = Object.keys(e); return n.length === 1 ? n[0] : null }(t)); if (!r) throw new Error('geojson must be homogenous'); const c = t; switch (r) { case 'LineString':return u.default(c, e); case 'Polygon':return l.default(c, e); default:throw new Error(r + ' is not supported') } } }, 4692: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6565)); const o = n(4102); const s = n(611); const a = n(1540); function u (t) { return t[0].toString() + ',' + t[1].toString() }e.default = function (t, e) { if (void 0 === e && (e = {}), e = e || {}, !o.isObject(e)) throw new Error('options is invalid'); const n = e.mutate; if (s.getType(t) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection'); if (!t.features.length) throw new Error('geojson is empty'); !1 !== n && void 0 !== n || (t = i.default(t)); const r = []; const l = a.lineReduce(t, function (t, e) { return (function (t, e) { let n; const r = t.geometry.coordinates; const i = e.geometry.coordinates; const s = u(r[0]); const a = u(r[r.length - 1]); const l = u(i[0]); const c = u(i[i.length - 1]); if (s === c)n = i.concat(r.slice(1)); else if (l === a)n = r.concat(i.slice(1)); else if (s === l)n = r.slice(1).reverse().concat(i); else { if (a !== c) return null; n = r.concat(i.reverse().slice(1)) } return o.lineString(n) }(t, e)) || (r.push(t), e) }); return l && r.push(l), r.length ? r.length === 1 ? r[0] : o.multiLineString(r.map(function (t) { return t.coordinates })) : null } }, 2387: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6565)); const o = n(4102); const s = n(611); const a = n(1540); const u = n(8146); const l = n(4255); e.default = function (t, e) { if (void 0 === e && (e = {}), s.getType(t) !== 'FeatureCollection') throw new Error('geojson must be a FeatureCollection'); if (!t.features.length) throw new Error('geojson is empty'); !1 !== e.mutate && void 0 !== e.mutate || (t = i.default(t)); const n = []; a.flattenEach(t, function (t) { n.push(t.geometry) }); const r = l.topology({ geoms: o.geometryCollection(n).geometry }); return u.merge(r, r.objects.geoms.geometries) } }, 7382: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4102); const o = n(1540); const s = r(n(2273)); e.default = function (t, e) { void 0 === e && (e = {}), e.concavity = e.concavity || 1 / 0; const n = []; if (o.coordEach(t, function (t) { n.push([t[0], t[1]]) }), !n.length) return null; const r = s.default(n, e.concavity); return r.length > 3 ? i.polygon([r]) : null } }, 3737: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); e.default = function (t, e, n, o) { void 0 === o && (o = {}); const s = i.getCoord(t); const a = r.degreesToRadians(s[0]); const u = r.degreesToRadians(s[1]); const l = r.degreesToRadians(n); const c = r.lengthToRadians(e, o.units); const f = Math.asin(Math.sin(u) * Math.cos(c) + Math.cos(u) * Math.sin(c) * Math.cos(l)); const h = a + Math.atan2(Math.sin(l) * Math.sin(c) * Math.cos(u), Math.cos(c) - Math.sin(u) * Math.sin(f)); const p = r.radiansToDegrees(h); const g = r.radiansToDegrees(f); return r.point([p, g], o.properties) } }, 8727: (t, e, n) => { 'use strict'; const r = n(2676); const i = n(4102); const o = n(611); function s (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const a = s(r); function u (t, e) { const n = o.getGeom(t); const r = o.getGeom(e); const s = t.properties || {}; const u = a.default.difference(n.coordinates, r.coordinates); return u.length === 0 ? null : u.length === 1 ? i.polygon(u[0], s) : i.multiPolygon(u, s) }t.exports = u, t.exports.default = u }, 2407: (t, e, n) => { 'use strict'; const r = n(4102); const i = n(611); const o = n(1540); const s = n(4288); const a = n(2676); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(s); const c = u(a); function f (t, e) { if (e = e || {}, !r.isObject(e)) throw new Error('options is invalid'); const n = e.propertyName; i.collectionOf(t, 'Polygon', 'dissolve'); const s = []; if (!e.propertyName) return l.default(r.multiPolygon(c.default.union.apply(null, t.features.map(function (t) { return t.geometry.coordinates })))); const a = {}; o.featureEach(t, function (t) { Object.prototype.hasOwnProperty.call(a, t.properties[n]) || (a[t.properties[n]] = []), a[t.properties[n]].push(t) }); for (let u = Object.keys(a), f = 0; f < u.length; f++) { const h = r.multiPolygon(c.default.union.apply(null, a[u[f]].map(function (t) { return t.geometry.coordinates }))); h.properties[n] = u[f], s.push(h) } return l.default(r.featureCollection(s)) }t.exports = f, t.exports.default = f }, 5366: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6338)); const o = n(611); const s = n(1540); function a (t, e, n) { void 0 === n && (n = 2); const r = o.getCoord(t); const i = o.getCoord(e); const s = r[0] - i[0]; const a = r[1] - i[1]; return n === 1 ? Math.abs(s) + Math.abs(a) : Math.pow(Math.pow(s, n) + Math.pow(a, n), 1 / n) }e.pNormDistance = a, e.default = function (t, e) { const n = (e = e || {}).threshold || 1e4; const r = e.p || 2; const o = e.binary || !1; const u = e.alpha || -1; const l = e.standardization || !1; const c = []; s.featureEach(t, function (t) { c.push(i.default(t)) }); for (var f = [], h = 0; h < c.length; h++)f[h] = []; for (h = 0; h < c.length; h++) for (var p = h; p < c.length; p++) { h === p && (f[h][p] = 0); var g = a(c[h], c[p], r); f[h][p] = g, f[p][h] = g } for (h = 0; h < c.length; h++) for (p = 0; p < c.length; p++)(g = f[h][p]) !== 0 && (f[h][p] = o ? g <= n ? 1 : 0 : g <= n ? Math.pow(g, u) : 0); if (l) for (h = 0; h < c.length; h++) { const d = f[h].reduce(function (t, e) { return t + e }, 0); for (p = 0; p < c.length; p++)f[h][p] = f[h][p] / d } return f } }, 1013: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(611); const i = n(4102); e.default = function (t, e, n) { void 0 === n && (n = {}); const o = r.getCoord(t); const s = r.getCoord(e); const a = i.degreesToRadians(s[1] - o[1]); const u = i.degreesToRadians(s[0] - o[0]); const l = i.degreesToRadians(o[1]); const c = i.degreesToRadians(s[1]); const f = Math.pow(Math.sin(a / 2), 2) + Math.pow(Math.sin(u / 2), 2) * Math.cos(l) * Math.cos(c); return i.radiansToLength(2 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f)), n.units) } }, 1211: (t, e, n) => { 'use strict'; const r = n(4102); const i = n(6082); const o = n(67); const s = n(611); function a (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const u = a(i); const l = a(o); function c (t, e, n, i) { const o = (i = i || {}).steps || 64; const a = i.units || 'kilometers'; const c = i.angle || 0; const h = i.pivot || t; const p = i.properties || t.properties || {}; if (!t) throw new Error('center is required'); if (!e) throw new Error('xSemiAxis is required'); if (!n) throw new Error('ySemiAxis is required'); if (!r.isObject(i)) throw new Error('options must be an object'); if (!r.isNumber(o)) throw new Error('steps must be a number'); if (!r.isNumber(c)) throw new Error('angle must be a number'); const g = s.getCoord(t); if (a === 'degrees') var d = r.degreesToRadians(c); else e = u.default(t, e, 90, { units: a }), n = u.default(t, n, 0, { units: a }), e = s.getCoord(e)[0] - g[0], n = s.getCoord(n)[1] - g[1]; for (var y = [], v = 0; v < o; v += 1) { const _ = -360 * v / o; let m = e * n / Math.sqrt(Math.pow(n, 2) + Math.pow(e, 2) * Math.pow(f(_), 2)); let x = e * n / Math.sqrt(Math.pow(e, 2) + Math.pow(n, 2) / Math.pow(f(_), 2)); if (_ < -90 && _ >= -270 && (m = -m), _ < -180 && _ >= -360 && (x = -x), a === 'degrees') { const b = m * Math.cos(d) + x * Math.sin(d); const E = x * Math.cos(d) - m * Math.sin(d); m = b, x = E }y.push([m + g[0], x + g[1]]) } return y.push(y[0]), a === 'degrees' ? r.polygon([y], p) : l.default(r.polygon([y], p), c, { pivot: h }) } function f (t) { const e = t * Math.PI / 180; return Math.tan(e) }t.exports = c, t.exports.default = c }, 9062: (t, e, n) => { 'use strict'; const r = n(9705); const i = n(3652); function o (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const s = o(r); const a = o(i); function u (t) { return a.default(s.default(t)) }t.exports = u, t.exports.default = u }, 3922: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(4102); function o (t) { const e = []; return t.type === 'FeatureCollection' ? r.featureEach(t, function (t) { r.coordEach(t, function (n) { e.push(i.point(n, t.properties)) }) }) : r.coordEach(t, function (n) { e.push(i.point(n, t.properties)) }), i.featureCollection(e) }t.exports = o, t.exports.default = o }, 4288: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(4102); function o (t) { if (!t) throw new Error('geojson is required'); const e = []; return r.flattenEach(t, function (t) { e.push(t) }), i.featureCollection(e) }t.exports = o, t.exports.default = o }, 7970: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(4102); function o (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const s = o(n(6565)); function a (t, e) { if (e = e || {}, !i.isObject(e)) throw new Error('options is invalid'); const n = e.mutate; if (!t) throw new Error('geojson is required'); return !1 !== n && void 0 !== n || (t = s.default(t)), r.coordEach(t, function (t) { const e = t[0]; const n = t[1]; t[0] = n, t[1] = e }), t }t.exports = a, t.exports.default = a }, 5422: (t, e, n) => { 'use strict'; const r = n(611); const i = Math.PI / 180; const o = 180 / Math.PI; const s = function (t, e) { this.lon = t, this.lat = e, this.x = i * t, this.y = i * e }; s.prototype.view = function () { return String(this.lon).slice(0, 4) + ',' + String(this.lat).slice(0, 4) }, s.prototype.antipode = function () { const t = -1 * this.lat; const e = this.lon < 0 ? 180 + this.lon : -1 * (180 - this.lon); return new s(e, t) }; const a = function () { this.coords = [], this.length = 0 }; a.prototype.move_to = function (t) { this.length++, this.coords.push(t) }; const u = function (t) { this.properties = t || {}, this.geometries = [] }; u.prototype.json = function () { if (this.geometries.length <= 0) return { geometry: { type: 'LineString', coordinates: null }, type: 'Feature', properties: this.properties }; if (this.geometries.length === 1) return { geometry: { type: 'LineString', coordinates: this.geometries[0].coords }, type: 'Feature', properties: this.properties }; for (var t = [], e = 0; e < this.geometries.length; e++)t.push(this.geometries[e].coords); return { geometry: { type: 'MultiLineString', coordinates: t }, type: 'Feature', properties: this.properties } }, u.prototype.wkt = function () { for (var t = '', e = 'LINESTRING(', n = function (t) { e += t[0] + ' ' + t[1] + ',' }, r = 0; r < this.geometries.length; r++) { if (this.geometries[r].coords.length === 0) return 'LINESTRING(empty)'; this.geometries[r].coords.forEach(n), t += e.substring(0, e.length - 1) + ')' } return t }; const l = function (t, e, n) { if (!t || void 0 === t.x || void 0 === t.y) throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties'); if (!e || void 0 === e.x || void 0 === e.y) throw new Error('GreatCircle constructor expects two args: start and end objects with x and y properties'); this.start = new s(t.x, t.y), this.end = new s(e.x, e.y), this.properties = n || {}; const r = this.start.x - this.end.x; const i = this.start.y - this.end.y; const o = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(r / 2), 2); if (this.g = 2 * Math.asin(Math.sqrt(o)), this.g === Math.PI) throw new Error('it appears ' + t.view() + ' and ' + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"); if (isNaN(this.g)) throw new Error('could not calculate great circle between ' + t + ' and ' + e) }; function c (t, e, n) { if (typeof (n = n || {}) !== 'object') throw new Error('options is invalid'); let i = n.properties; let o = n.npoints; let s = n.offset; return t = r.getCoord(t), e = r.getCoord(e), i = i || {}, o = o || 100, s = s || 10, new l({ x: t[0], y: t[1] }, { x: e[0], y: e[1] }, i).Arc(o, { offset: s }).json() }l.prototype.interpolate = function (t) { const e = Math.sin((1 - t) * this.g) / Math.sin(this.g); const n = Math.sin(t * this.g) / Math.sin(this.g); const r = e * Math.cos(this.start.y) * Math.cos(this.start.x) + n * Math.cos(this.end.y) * Math.cos(this.end.x); const i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + n * Math.cos(this.end.y) * Math.sin(this.end.x); const s = e * Math.sin(this.start.y) + n * Math.sin(this.end.y); const a = o * Math.atan2(s, Math.sqrt(Math.pow(r, 2) + Math.pow(i, 2))); return [o * Math.atan2(i, r), a] }, l.prototype.Arc = function (t, e) { const n = []; if (!t || t <= 2)n.push([this.start.lon, this.start.lat]), n.push([this.end.lon, this.end.lat]); else for (let r = 1 / (t - 1), i = 0; i < t; ++i) { const o = r * i; const s = this.interpolate(o); n.push(s) } for (var l = !1, c = 0, f = e && e.offset ? e.offset : 10, h = 180 - f, p = -180 + f, g = 360 - f, d = 1; d < n.length; ++d) { const y = n[d - 1][0]; const v = n[d][0]; const _ = Math.abs(v - y); _ > g && (v > h && y < p || y > h && v < p) ? l = !0 : _ > c && (c = _) } const m = []; if (l && c < f) { let x = []; m.push(x); for (let b = 0; b < n.length; ++b) { const E = parseFloat(n[b][0]); if (b > 0 && Math.abs(E - n[b - 1][0]) > g) { let w = parseFloat(n[b - 1][0]); let I = parseFloat(n[b - 1][1]); let S = parseFloat(n[b][0]); let N = parseFloat(n[b][1]); if (w > -180 && w < p && S === 180 && b + 1 < n.length && n[b - 1][0] > -180 && n[b - 1][0] < p) { x.push([-180, n[b][1]]), b++, x.push([n[b][0], n[b][1]]); continue } if (w > h && w < 180 && S === -180 && b + 1 < n.length && n[b - 1][0] > h && n[b - 1][0] < 180) { x.push([180, n[b][1]]), b++, x.push([n[b][0], n[b][1]]); continue } if (w < p && S > h) { const P = w; w = S, S = P; const C = I; I = N, N = C } if (w > h && S < p && (S += 360), w <= 180 && S >= 180 && w < S) { const M = (180 - w) / (S - w); const O = M * N + (1 - M) * I; x.push([n[b - 1][0] > h ? 180 : -180, O]), (x = []).push([n[b - 1][0] > h ? -180 : 180, O]), m.push(x) } else x = [], m.push(x); x.push([E, n[b][1]]) } else x.push([n[b][0], n[b][1]]) } } else { const L = []; m.push(L); for (let R = 0; R < n.length; ++R)L.push([n[R][0], n[R][1]]) } for (var A = new u(this.properties), T = 0; T < m.length; ++T) { const D = new a(); A.geometries.push(D); for (let F = m[T], j = 0; j < F.length; ++j)D.move_to(F[j]) } return A }, t.exports = c, t.exports.default = c }, 4102: (t, e) => { 'use strict'; function n (t, e, n) { void 0 === n && (n = {}); const r = { type: 'Feature' }; return (n.id === 0 || n.id) && (r.id = n.id), n.bbox && (r.bbox = n.bbox), r.properties = e || {}, r.geometry = t, r } function r (t, e, r) { if (void 0 === r && (r = {}), !t) throw new Error('coordinates is required'); if (!Array.isArray(t)) throw new Error('coordinates must be an Array'); if (t.length < 2) throw new Error('coordinates must be at least 2 numbers long'); if (!p(t[0]) || !p(t[1])) throw new Error('coordinates must contain numbers'); return n({ type: 'Point', coordinates: t }, e, r) } function i (t, e, r) { void 0 === r && (r = {}); for (let i = 0, o = t; i < o.length; i++) { const s = o[i]; if (s.length < 4) throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.'); for (let a = 0; a < s[s.length - 1].length; a++) if (s[s.length - 1][a] !== s[0][a]) throw new Error('First and last Position are not equivalent.') } return n({ type: 'Polygon', coordinates: t }, e, r) } function o (t, e, r) { if (void 0 === r && (r = {}), t.length < 2) throw new Error('coordinates must be an array of two or more positions'); return n({ type: 'LineString', coordinates: t }, e, r) } function s (t, e) { void 0 === e && (e = {}); const n = { type: 'FeatureCollection' }; return e.id && (n.id = e.id), e.bbox && (n.bbox = e.bbox), n.features = t, n } function a (t, e, r) { return void 0 === r && (r = {}), n({ type: 'MultiLineString', coordinates: t }, e, r) } function u (t, e, r) { return void 0 === r && (r = {}), n({ type: 'MultiPoint', coordinates: t }, e, r) } function l (t, e, r) { return void 0 === r && (r = {}), n({ type: 'MultiPolygon', coordinates: t }, e, r) } function c (t, n) { void 0 === n && (n = 'kilometers'); const r = e.factors[n]; if (!r) throw new Error(n + ' units is invalid'); return t * r } function f (t, n) { void 0 === n && (n = 'kilometers'); const r = e.factors[n]; if (!r) throw new Error(n + ' units is invalid'); return t / r } function h (t) { return t % (2 * Math.PI) * 180 / Math.PI } function p (t) { return !isNaN(t) && t !== null && !Array.isArray(t) }Object.defineProperty(e, '__esModule', { value: !0 }), e.earthRadius = 6371008.8, e.factors = { centimeters: 100 * e.earthRadius, centimetres: 100 * e.earthRadius, degrees: e.earthRadius / 111325, feet: 3.28084 * e.earthRadius, inches: 39.37 * e.earthRadius, kilometers: e.earthRadius / 1e3, kilometres: e.earthRadius / 1e3, meters: e.earthRadius, metres: e.earthRadius, miles: e.earthRadius / 1609.344, millimeters: 1e3 * e.earthRadius, millimetres: 1e3 * e.earthRadius, nauticalmiles: e.earthRadius / 1852, radians: 1, yards: 1.0936 * e.earthRadius }, e.unitsFactors = { centimeters: 100, centimetres: 100, degrees: 1 / 111325, feet: 3.28084, inches: 39.37, kilometers: 0.001, kilometres: 0.001, meters: 1, metres: 1, miles: 1 / 1609.344, millimeters: 1e3, millimetres: 1e3, nauticalmiles: 1 / 1852, radians: 1 / e.earthRadius, yards: 1.0936133 }, e.areaFactors = { acres: 247105e-9, centimeters: 1e4, centimetres: 1e4, feet: 10.763910417, hectares: 1e-4, inches: 1550.003100006, kilometers: 1e-6, kilometres: 1e-6, meters: 1, metres: 1, miles: 386e-9, millimeters: 1e6, millimetres: 1e6, yards: 1.195990046 }, e.feature = n, e.geometry = function (t, e, n) { switch (void 0 === n && (n = {}), t) { case 'Point':return r(e).geometry; case 'LineString':return o(e).geometry; case 'Polygon':return i(e).geometry; case 'MultiPoint':return u(e).geometry; case 'MultiLineString':return a(e).geometry; case 'MultiPolygon':return l(e).geometry; default:throw new Error(t + ' is invalid') } }, e.point = r, e.points = function (t, e, n) { return void 0 === n && (n = {}), s(t.map(function (t) { return r(t, e) }), n) }, e.polygon = i, e.polygons = function (t, e, n) { return void 0 === n && (n = {}), s(t.map(function (t) { return i(t, e) }), n) }, e.lineString = o, e.lineStrings = function (t, e, n) { return void 0 === n && (n = {}), s(t.map(function (t) { return o(t, e) }), n) }, e.featureCollection = s, e.multiLineString = a, e.multiPoint = u, e.multiPolygon = l, e.geometryCollection = function (t, e, r) { return void 0 === r && (r = {}), n({ type: 'GeometryCollection', geometries: t }, e, r) }, e.round = function (t, e) { if (void 0 === e && (e = 0), e && !(e >= 0)) throw new Error('precision must be a positive number'); const n = Math.pow(10, e || 0); return Math.round(t * n) / n }, e.radiansToLength = c, e.lengthToRadians = f, e.lengthToDegrees = function (t, e) { return h(f(t, e)) }, e.bearingToAzimuth = function (t) { let e = t % 360; return e < 0 && (e += 360), e }, e.radiansToDegrees = h, e.degreesToRadians = function (t) { return t % 360 * Math.PI / 180 }, e.convertLength = function (t, e, n) { if (void 0 === e && (e = 'kilometers'), void 0 === n && (n = 'kilometers'), !(t >= 0)) throw new Error('length must be a positive number'); return c(f(t, e), n) }, e.convertArea = function (t, n, r) { if (void 0 === n && (n = 'meters'), void 0 === r && (r = 'kilometers'), !(t >= 0)) throw new Error('area must be a positive number'); const i = e.areaFactors[n]; if (!i) throw new Error('invalid original units'); const o = e.areaFactors[r]; if (!o) throw new Error('invalid final units'); return t / i * o }, e.isNumber = p, e.isObject = function (t) { return !!t && t.constructor === Object }, e.validateBBox = function (t) { if (!t) throw new Error('bbox is required'); if (!Array.isArray(t)) throw new Error('bbox must be an Array'); if (t.length !== 4 && t.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers'); t.forEach(function (t) { if (!p(t)) throw new Error('bbox must only contain numbers') }) }, e.validateId = function (t) { if (!t) throw new Error('id is required'); if (['string', 'number'].indexOf(typeof t) === -1) throw new Error('id must be a number or a string') } }, 5621: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1013)); const o = r(n(4170)); const s = n(4102); function a (t, e, n, r, i, o) { for (var a = [], u = 0; u < 6; u++) { const l = t[0] + e * i[u]; const c = t[1] + n * o[u]; a.push([l, c]) } return a.push(a[0].slice()), s.polygon([a], r) } function u (t, e, n, r, i, o) { for (var a = [], u = 0; u < 6; u++) { const l = []; l.push(t), l.push([t[0] + e * i[u], t[1] + n * o[u]]), l.push([t[0] + e * i[(u + 1) % 6], t[1] + n * o[(u + 1) % 6]]), l.push(t), a.push(s.polygon([l], r)) } return a }e.default = function (t, e, n) { void 0 === n && (n = {}); const r = JSON.stringify(n.properties || {}); const l = t[0]; const c = t[1]; const f = t[2]; const h = t[3]; const p = (c + h) / 2; const g = (l + f) / 2; const d = 2 * e / i.default([l, p], [f, p], n) * (f - l); const y = 2 * e / i.default([g, c], [g, h], n) * (h - c); const v = d / 2; const _ = 2 * v; const m = Math.sqrt(3) / 2 * y; const x = f - l; const b = h - c; const E = 3 / 4 * _; const w = m; const I = (x - _) / (_ - v / 2); const S = Math.floor(I); const N = (S * E - v / 2 - x) / 2 - v / 2 + E / 2; const P = Math.floor((b - m) / m); let C = (b - P * m) / 2; const M = P * m - b > m / 2; M && (C -= m / 4); for (var O = [], L = [], R = 0; R < 6; R++) { const A = 2 * Math.PI / 6 * R; O.push(Math.cos(A)), L.push(Math.sin(A)) } for (var T = [], D = 0; D <= S; D++) for (let F = 0; F <= P; F++) { const j = D % 2 == 1; if (!(F === 0 && j || F === 0 && M)) { const k = D * E + l - N; let G = F * w + c + C; if (j && (G -= m / 2), !0 === n.triangles)u([k, G], d / 2, y / 2, JSON.parse(r), O, L).forEach(function (t) { n.mask ? o.default(n.mask, t) && T.push(t) : T.push(t) }); else { const q = a([k, G], d / 2, y / 2, JSON.parse(r), O, L); n.mask ? o.default(n.mask, q) && T.push(q) : T.push(q) } } } return s.featureCollection(T) } }, 5566: (t, e, n) => { 'use strict'; const r = n(9705); const i = n(5621); const o = n(6813); const s = n(1013); const a = n(6338); const u = n(5434); const l = n(4686); const c = n(6565); const f = n(4102); const h = n(1540); const p = n(611); function g (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const d = g(r); const y = g(i); const v = g(o); const _ = g(s); const m = g(a); const x = g(u); const b = g(l); const E = g(c); function w (t, e, n) { if (typeof (n = n || {}) !== 'object') throw new Error('options is invalid'); let r = n.gridType; let i = n.property; let o = n.weight; if (!t) throw new Error('points is required'); if (p.collectionOf(t, 'Point', 'input must contain Points'), !e) throw new Error('cellSize is required'); if (void 0 !== o && typeof o !== 'number') throw new Error('weight must be a number'); i = i || 'elevation', r = r || 'square', o = o || 1; let s; const a = d.default(t); switch (r) { case 'point':case 'points':s = v.default(a, e, n); break; case 'square':case 'squares':s = x.default(a, e, n); break; case 'hex':case 'hexes':s = y.default(a, e, n); break; case 'triangle':case 'triangles':s = b.default(a, e, n); break; default:throw new Error('invalid gridType') } const u = []; return h.featureEach(s, function (e) { let s = 0; let a = 0; h.featureEach(t, function (t) { let u; const l = r === 'point' ? e : m.default(e); const c = _.default(l, t, n); if (void 0 !== i && (u = t.properties[i]), void 0 === u && (u = t.geometry.coordinates[2]), void 0 === u) throw new Error('zValue is missing'); c === 0 && (s = u); const f = 1 / Math.pow(c, o); a += f, s += f * u }); const l = E.default(e); l.properties[i] = s / a, u.push(l) }), f.featureCollection(u) }t.exports = w, t.exports.default = w }, 4170: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4102); const o = n(611); const s = r(n(2676)); e.default = function (t, e, n) { void 0 === n && (n = {}); const r = o.getGeom(t); const a = o.getGeom(e); const u = s.default.intersection(r.coordinates, a.coordinates); return u.length === 0 ? null : u.length === 1 ? i.polygon(u[0], n.properties) : i.multiPolygon(u, n.properties) } }, 611: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); e.getCoord = function (t) { if (!t) throw new Error('coord is required'); if (!Array.isArray(t)) { if (t.type === 'Feature' && t.geometry !== null && t.geometry.type === 'Point') return t.geometry.coordinates; if (t.type === 'Point') return t.coordinates } if (Array.isArray(t) && t.length >= 2 && !Array.isArray(t[0]) && !Array.isArray(t[1])) return t; throw new Error('coord must be GeoJSON Point or an Array of numbers') }, e.getCoords = function (t) { if (Array.isArray(t)) return t; if (t.type === 'Feature') { if (t.geometry !== null) return t.geometry.coordinates } else if (t.coordinates) return t.coordinates; throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array') }, e.containsNumber = function t (e) { if (e.length > 1 && r.isNumber(e[0]) && r.isNumber(e[1])) return !0; if (Array.isArray(e[0]) && e[0].length) return t(e[0]); throw new Error('coordinates must only contain numbers') }, e.geojsonType = function (t, e, n) { if (!e || !n) throw new Error('type and name required'); if (!t || t.type !== e) throw new Error('Invalid input to ' + n + ': must be a ' + e + ', given ' + t.type) }, e.featureOf = function (t, e, n) { if (!t) throw new Error('No feature passed'); if (!n) throw new Error('.featureOf() requires a name'); if (!t || t.type !== 'Feature' || !t.geometry) throw new Error('Invalid input to ' + n + ', Feature with geometry required'); if (!t.geometry || t.geometry.type !== e) throw new Error('Invalid input to ' + n + ': must be a ' + e + ', given ' + t.geometry.type) }, e.collectionOf = function (t, e, n) { if (!t) throw new Error('No featureCollection passed'); if (!n) throw new Error('.collectionOf() requires a name'); if (!t || t.type !== 'FeatureCollection') throw new Error('Invalid input to ' + n + ', FeatureCollection required'); for (let r = 0, i = t.features; r < i.length; r++) { const o = i[r]; if (!o || o.type !== 'Feature' || !o.geometry) throw new Error('Invalid input to ' + n + ', Feature with geometry required'); if (!o.geometry || o.geometry.type !== e) throw new Error('Invalid input to ' + n + ': must be a ' + e + ', given ' + o.geometry.type) } }, e.getGeom = function (t) { return t.type === 'Feature' ? t.geometry : t }, e.getType = function (t, e) { return t.type === 'FeatureCollection' ? 'FeatureCollection' : t.type === 'GeometryCollection' ? 'GeometryCollection' : t.type === 'Feature' && t.geometry !== null ? t.geometry.type : t.type } }, 7406: (t, e, n) => { 'use strict'; const r = n(9705); const i = n(1070); const o = n(8147); const s = n(3922); const a = n(611); const u = n(4102); const l = n(7418); const c = n(1540); function f (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const h = f(r); const p = f(i); const g = f(o); const d = f(s); const y = f(l); const v = { successCallback: null, verbose: !1, polygons: !1 }; const _ = {}; function m (t, e, n, r) { r = r || {}; for (let i = Object.keys(v), o = 0; o < i.length; o++) { const s = i[o]; let a = r[s]; a = a != null ? a : v[s], _[s] = a }_.verbose && console.log('MarchingSquaresJS-isoBands: computing isobands for [' + e + ':' + (e + n) + ']'); let u; const l = (function (t, e, n) { for (var r = t.length - 1, i = t[0].length - 1, o = { rows: r, cols: i, cells: [] }, s = e + Math.abs(n), a = 0; a < r; ++a) { o.cells[a] = []; for (let u = 0; u < i; ++u) { let l = 0; const c = t[a + 1][u]; const f = t[a + 1][u + 1]; const h = t[a][u + 1]; const p = t[a][u]; if (!(isNaN(c) || isNaN(f) || isNaN(h) || isNaN(p))) { l |= c < e ? 0 : c > s ? 128 : 64, l |= f < e ? 0 : f > s ? 32 : 16, l |= h < e ? 0 : h > s ? 8 : 4; const g = +(l |= p < e ? 0 : p > s ? 2 : 1); let d = 0; if (l === 17 || l === 18 || l === 33 || l === 34 || l === 38 || l === 68 || l === 72 || l === 98 || l === 102 || l === 132 || l === 136 || l === 137 || l === 152 || l === 153) { const y = (c + f + h + p) / 4; d = y > s ? 2 : y < e ? 0 : 1, l === 34 ? d === 1 ? l = 35 : d === 0 && (l = 136) : l === 136 ? d === 1 ? (l = 35, d = 4) : d === 0 && (l = 34) : l === 17 ? d === 1 ? (l = 155, d = 4) : d === 0 && (l = 153) : l === 68 ? d === 1 ? (l = 103, d = 4) : d === 0 && (l = 102) : l === 153 ? d === 1 && (l = 155) : l === 102 ? d === 1 && (l = 103) : l === 152 ? d < 2 && (l = 156, d = 1) : l === 137 ? d < 2 && (l = 139, d = 1) : l === 98 ? d < 2 && (l = 99, d = 1) : l === 38 ? d < 2 && (l = 39, d = 1) : l === 18 ? d > 0 ? (l = 156, d = 4) : l = 152 : l === 33 ? d > 0 ? (l = 139, d = 4) : l = 137 : l === 72 ? d > 0 ? (l = 99, d = 4) : l = 98 : l === 132 && (d > 0 ? (l = 39, d = 4) : l = 38) } if (l != 0 && l != 170) { var v, _, m, x, b, E, w, I; v = _ = m = x = b = E = w = I = 0.5; const S = []; l === 1 ? (m = 1 - lt(e, h, p), I = 1 - lt(e, c, p), S.push(rt[l])) : l === 169 ? (m = lt(s, p, h), I = lt(s, p, c), S.push(rt[l])) : l === 4 ? (E = 1 - lt(e, f, h), x = lt(e, p, h), S.push(et[l])) : l === 166 ? (E = lt(s, h, f), x = 1 - lt(s, h, p), S.push(et[l])) : l === 16 ? (b = lt(e, h, f), _ = lt(e, c, f), S.push(tt[l])) : l === 154 ? (b = 1 - lt(s, f, h), _ = 1 - lt(s, f, c), S.push(tt[l])) : l === 64 ? (w = lt(e, p, c), v = 1 - lt(e, f, c), S.push(ot[l])) : l === 106 ? (w = 1 - lt(s, c, p), v = lt(s, c, f), S.push(ot[l])) : l === 168 ? (x = lt(s, p, h), m = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), S.push(nt[l]), S.push(rt[l])) : l === 2 ? (x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), S.push(nt[l]), S.push(rt[l])) : l === 162 ? (b = lt(s, h, f), E = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), S.push(nt[l]), S.push(rt[l])) : l === 8 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), S.push(tt[l]), S.push(et[l])) : l === 138 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c), S.push(tt[l]), S.push(et[l])) : l === 32 ? (b = lt(s, h, f), E = lt(e, h, f), v = lt(e, c, f), _ = lt(s, c, f), S.push(tt[l]), S.push(et[l])) : l === 42 ? (I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f), S.push(it[l]), S.push(ot[l])) : l === 128 && (I = lt(e, p, c), w = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c), S.push(it[l]), S.push(ot[l])), l === 5 ? (E = 1 - lt(e, f, h), I = 1 - lt(e, c, p), S.push(et[l])) : l === 165 ? (E = lt(s, h, f), I = lt(s, p, c), S.push(et[l])) : l === 20 ? (x = lt(e, p, h), _ = lt(e, c, f), S.push(nt[l])) : l === 150 ? (x = 1 - lt(s, h, p), _ = 1 - lt(s, f, c), S.push(nt[l])) : l === 80 ? (b = lt(e, h, f), w = lt(e, p, c), S.push(tt[l])) : l === 90 ? (b = 1 - lt(s, f, h), w = 1 - lt(s, c, p), S.push(tt[l])) : l === 65 ? (m = 1 - lt(e, h, p), v = 1 - lt(e, f, c), S.push(rt[l])) : l === 105 ? (m = lt(s, p, h), v = lt(s, c, f), S.push(rt[l])) : l === 160 ? (b = lt(s, h, f), E = lt(e, h, f), I = lt(e, p, c), w = lt(s, p, c), S.push(tt[l]), S.push(et[l])) : l === 10 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), S.push(tt[l]), S.push(et[l])) : l === 130 ? (x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c), S.push(nt[l]), S.push(rt[l])) : l === 40 ? (x = lt(s, p, h), m = lt(e, p, h), v = lt(e, c, f), _ = lt(s, c, f), S.push(nt[l]), S.push(rt[l])) : l === 101 ? (E = lt(s, h, f), v = lt(s, c, f), S.push(et[l])) : l === 69 ? (E = 1 - lt(e, f, h), v = 1 - lt(e, f, c), S.push(et[l])) : l === 149 ? (I = lt(s, p, c), _ = 1 - lt(s, f, c), S.push(it[l])) : l === 21 ? (I = 1 - lt(e, c, p), _ = lt(e, c, f), S.push(it[l])) : l === 86 ? (x = 1 - lt(s, h, p), w = 1 - lt(s, c, p), S.push(nt[l])) : l === 84 ? (x = lt(e, p, h), w = lt(e, p, c), S.push(nt[l])) : l === 89 ? (b = 1 - lt(s, f, h), m = lt(s, p, h), S.push(rt[l])) : l === 81 ? (b = lt(e, h, f), m = 1 - lt(e, h, p), S.push(rt[l])) : l === 96 ? (b = lt(s, h, f), E = lt(e, h, f), w = lt(e, p, c), v = lt(s, c, f), S.push(tt[l]), S.push(et[l])) : l === 74 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), w = 1 - lt(s, c, p), v = 1 - lt(e, f, c), S.push(tt[l]), S.push(et[l])) : l === 24 ? (b = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), _ = lt(e, c, f), S.push(tt[l]), S.push(rt[l])) : l === 146 ? (b = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), _ = 1 - lt(s, f, c), S.push(tt[l]), S.push(rt[l])) : l === 6 ? (E = 1 - lt(e, f, h), x = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), S.push(et[l]), S.push(nt[l])) : l === 164 ? (E = lt(s, h, f), x = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), S.push(et[l]), S.push(nt[l])) : l === 129 ? (m = 1 - lt(e, h, p), I = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c), S.push(rt[l]), S.push(it[l])) : l === 41 ? (m = lt(s, p, h), I = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f), S.push(rt[l]), S.push(it[l])) : l === 66 ? (x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), w = 1 - lt(s, c, p), v = 1 - lt(e, f, c), S.push(nt[l]), S.push(rt[l])) : l === 104 ? (x = lt(s, p, h), m = lt(e, p, h), w = lt(e, p, c), v = lt(s, c, f), S.push(rt[l]), S.push(st[l])) : l === 144 ? (b = lt(e, h, f), I = lt(e, p, c), w = lt(s, p, c), _ = 1 - lt(s, f, c), S.push(tt[l]), S.push(ot[l])) : l === 26 ? (b = 1 - lt(s, f, h), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), _ = lt(e, c, f), S.push(tt[l]), S.push(ot[l])) : l === 36 ? (E = lt(s, h, f), x = lt(e, p, h), v = lt(e, c, f), _ = lt(s, c, f), S.push(et[l]), S.push(nt[l])) : l === 134 ? (E = 1 - lt(e, f, h), x = 1 - lt(s, h, p), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c), S.push(et[l]), S.push(nt[l])) : l === 9 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), m = lt(s, p, h), I = 1 - lt(e, c, p), S.push(tt[l]), S.push(et[l])) : l === 161 ? (b = lt(s, h, f), E = lt(e, h, f), m = 1 - lt(e, h, p), I = lt(s, p, c), S.push(tt[l]), S.push(et[l])) : l === 37 ? (E = lt(s, h, f), I = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f), S.push(et[l]), S.push(it[l])) : l === 133 ? (E = 1 - lt(e, f, h), I = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c), S.push(et[l]), S.push(it[l])) : l === 148 ? (x = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), _ = 1 - lt(s, f, c), S.push(nt[l]), S.push(ot[l])) : l === 22 ? (x = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), _ = lt(e, c, f), S.push(nt[l]), S.push(ot[l])) : l === 82 ? (b = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), w = 1 - lt(s, c, p), S.push(tt[l]), S.push(rt[l])) : l === 88 ? (b = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), w = lt(e, p, c), S.push(tt[l]), S.push(rt[l])) : l === 73 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), m = lt(s, p, h), v = 1 - lt(e, f, c), S.push(tt[l]), S.push(et[l])) : l === 97 ? (b = lt(s, h, f), E = lt(e, h, f), m = 1 - lt(e, h, p), v = lt(s, c, f), S.push(tt[l]), S.push(et[l])) : l === 145 ? (b = lt(e, h, f), m = 1 - lt(e, h, p), I = lt(s, p, c), _ = 1 - lt(s, f, c), S.push(tt[l]), S.push(it[l])) : l === 25 ? (b = 1 - lt(s, f, h), m = lt(s, p, h), I = 1 - lt(e, c, p), _ = lt(e, c, f), S.push(tt[l]), S.push(it[l])) : l === 70 ? (E = 1 - lt(e, f, h), x = 1 - lt(s, h, p), w = 1 - lt(s, c, p), v = 1 - lt(e, f, c), S.push(et[l]), S.push(nt[l])) : l === 100 ? (E = lt(s, h, f), x = lt(e, p, h), w = lt(e, p, c), v = lt(s, c, f), S.push(et[l]), S.push(nt[l])) : l === 34 ? (d === 0 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)) : (b = lt(s, h, f), E = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)), S.push(tt[l]), S.push(et[l]), S.push(it[l]), S.push(ot[l])) : l === 35 ? (d === 4 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)) : (b = lt(s, h, f), E = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)), S.push(tt[l]), S.push(et[l]), S.push(rt[l]), S.push(ot[l])) : l === 136 ? (d === 0 ? (b = lt(s, h, f), E = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)) : (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)), S.push(tt[l]), S.push(et[l]), S.push(it[l]), S.push(ot[l])) : l === 153 ? (d === 0 ? (b = lt(e, h, f), m = 1 - lt(e, h, p), I = 1 - lt(e, c, p), _ = lt(e, c, f)) : (b = 1 - lt(s, f, h), m = lt(s, p, h), I = lt(s, p, c), _ = 1 - lt(s, f, c)), S.push(tt[l]), S.push(rt[l])) : l === 102 ? (d === 0 ? (E = 1 - lt(e, f, h), x = lt(e, p, h), w = lt(e, p, c), v = 1 - lt(e, f, c)) : (E = lt(s, h, f), x = 1 - lt(s, h, p), w = 1 - lt(s, c, p), v = lt(s, c, f)), S.push(et[l]), S.push(ot[l])) : l === 155 ? (d === 4 ? (b = lt(e, h, f), m = 1 - lt(e, h, p), I = 1 - lt(e, c, p), _ = lt(e, c, f)) : (b = 1 - lt(s, f, h), m = lt(s, p, h), I = lt(s, p, c), _ = 1 - lt(s, f, c)), S.push(tt[l]), S.push(it[l])) : l === 103 ? (d === 4 ? (E = 1 - lt(e, f, h), x = lt(e, p, h), w = lt(e, p, c), v = 1 - lt(e, f, c)) : (E = lt(s, h, f), x = 1 - lt(s, h, p), w = 1 - lt(s, c, p), v = lt(s, c, f)), S.push(et[l]), S.push(nt[l])) : l === 152 ? (d === 0 ? (b = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), _ = lt(e, c, f)) : (b = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), _ = 1 - lt(s, f, c)), S.push(tt[l]), S.push(nt[l]), S.push(rt[l])) : l === 156 ? (d === 4 ? (b = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), _ = lt(e, c, f)) : (b = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), _ = 1 - lt(s, f, c)), S.push(tt[l]), S.push(rt[l]), S.push(ot[l])) : l === 137 ? (d === 0 ? (b = lt(s, h, f), E = lt(e, h, f), m = 1 - lt(e, h, p), I = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)) : (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), m = lt(s, p, h), I = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)), S.push(tt[l]), S.push(et[l]), S.push(rt[l])) : l === 139 ? (d === 4 ? (b = lt(s, h, f), E = lt(e, h, f), m = 1 - lt(e, h, p), I = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)) : (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), m = lt(s, p, h), I = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)), S.push(tt[l]), S.push(et[l]), S.push(it[l])) : l === 98 ? (d === 0 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), w = lt(e, p, c), v = 1 - lt(e, f, c)) : (b = lt(s, h, f), E = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), w = 1 - lt(s, c, p), v = lt(s, c, f)), S.push(tt[l]), S.push(et[l]), S.push(ot[l])) : l === 99 ? (d === 4 ? (b = 1 - lt(e, f, h), E = 1 - lt(s, f, h), x = lt(s, p, h), m = lt(e, p, h), w = lt(e, p, c), v = 1 - lt(e, f, c)) : (b = lt(s, h, f), E = lt(e, h, f), x = 1 - lt(e, h, p), m = 1 - lt(s, h, p), w = 1 - lt(s, c, p), v = lt(s, c, f)), S.push(tt[l]), S.push(et[l]), S.push(rt[l])) : l === 38 ? (d === 0 ? (E = 1 - lt(e, f, h), x = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)) : (E = lt(s, h, f), x = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)), S.push(et[l]), S.push(it[l]), S.push(ot[l])) : l === 39 ? (d === 4 ? (E = 1 - lt(e, f, h), x = lt(e, p, h), I = lt(e, p, c), w = lt(s, p, c), v = 1 - lt(s, f, c), _ = 1 - lt(e, f, c)) : (E = lt(s, h, f), x = 1 - lt(s, h, p), I = 1 - lt(s, c, p), w = 1 - lt(e, c, p), v = lt(e, c, f), _ = lt(s, c, f)), S.push(et[l]), S.push(nt[l]), S.push(ot[l])) : l === 85 && (b = 1, E = 0, x = 1, m = 0, I = 0, w = 1, v = 0, _ = 1), (v < 0 || v > 1 || _ < 0 || _ > 1 || b < 0 || b > 1 || x < 0 || x > 1 || I < 0 || I > 1 || w < 0 || w > 1) && console.log('MarchingSquaresJS-isoBands: ' + l + ' ' + g + ' ' + c + ',' + f + ',' + h + ',' + p + ' ' + d + ' ' + v + ' ' + _ + ' ' + b + ' ' + E + ' ' + x + ' ' + m + ' ' + I + ' ' + w), o.cells[a][u] = { cval: l, cval_real: g, flipped: d, topleft: v, topright: _, righttop: b, rightbottom: E, bottomright: x, bottomleft: m, leftbottom: I, lefttop: w, edges: S } } } } } return o }(t, e, n)); return _.polygons ? (_.verbose && console.log('MarchingSquaresJS-isoBands: returning single polygons for each grid cell'), u = (function (t) { const e = []; let n = 0; return t.cells.forEach(function (t, r) { t.forEach(function (t, i) { if (void 0 !== t) { const o = ut[t.cval](t); typeof o === 'object' && ct(o) ? typeof o[0] === 'object' && ct(o[0]) ? typeof o[0][0] === 'object' && ct(o[0][0]) ? o.forEach(function (t) { t.forEach(function (t) { t[0] += i, t[1] += r }), e[n++] = t }) : (o.forEach(function (t) { t[0] += i, t[1] += r }), e[n++] = o) : console.log('MarchingSquaresJS-isoBands: bandcell polygon with malformed coordinates') : console.log('MarchingSquaresJS-isoBands: bandcell polygon with null coordinates') } }) }), e }(l))) : (_.verbose && console.log('MarchingSquaresJS-isoBands: returning polygon paths for entire data grid'), u = (function (t) { for (var e = [], n = t.rows, r = t.cols, i = [], o = 0; o < n; o++) for (let s = 0; s < r; s++) if (void 0 !== t.cells[o][s] && t.cells[o][s].edges.length > 0) { let a = ht(t.cells[o][s]); let u = null; let l = s; let c = o; a !== null && i.push([a.p[0] + l, a.p[1] + c]); do { if ((u = pt(t.cells[c][l], a.x, a.y, a.o)) === null) break; if (i.push([u.p[0] + l, u.p[1] + c]), l += u.x, a = u, (c += u.y) < 0 || c >= n || l < 0 || l >= r || void 0 === t.cells[c][l]) { const f = ft(t, l -= u.x, c -= u.y, u.x, u.y, u.o); if (f === null) break; f.path.forEach(function (t) { i.push(t) }), l = f.i, c = f.j, a = f } } while (void 0 !== t.cells[c][l] && t.cells[c][l].edges.length > 0); e.push(i), i = [], t.cells[o][s].edges.length > 0 && s-- } return e }(l))), typeof _.successCallback === 'function' && _.successCallback(u), u } const x = 64; const b = 16; const E = []; const w = []; const I = []; const S = []; const N = []; const P = []; const C = []; const M = []; const O = []; const L = []; const R = []; const A = []; const T = []; const D = []; const F = []; const j = []; const k = []; const G = []; const q = []; const B = []; const z = []; const U = []; const X = []; const Y = []; C[85] = L[85] = -1, M[85] = R[85] = 0, O[85] = A[85] = 1, q[85] = U[85] = 1, B[85] = X[85] = 0, z[85] = Y[85] = 1, E[85] = S[85] = 0, w[85] = N[85] = -1, I[85] = F[85] = 0, j[85] = T[85] = 0, k[85] = D[85] = 1, P[85] = G[85] = 1, U[1] = U[169] = 0, X[1] = X[169] = -1, Y[1] = Y[169] = 0, T[1] = T[169] = -1, D[1] = D[169] = 0, F[1] = F[169] = 0, L[4] = L[166] = 0, R[4] = R[166] = -1, A[4] = A[166] = 1, j[4] = j[166] = 1, k[4] = k[166] = 0, G[4] = G[166] = 0, C[16] = C[154] = 0, M[16] = M[154] = 1, O[16] = O[154] = 1, S[16] = S[154] = 1, N[16] = N[154] = 0, P[16] = P[154] = 1, q[64] = q[106] = 0, B[64] = B[106] = 1, z[64] = z[106] = 0, E[64] = E[106] = -1, w[64] = w[106] = 0, I[64] = I[106] = 1, q[2] = q[168] = 0, B[2] = B[168] = -1, z[2] = z[168] = 1, U[2] = U[168] = 0, X[2] = X[168] = -1, Y[2] = Y[168] = 0, T[2] = T[168] = -1, D[2] = D[168] = 0, F[2] = F[168] = 0, j[2] = j[168] = -1, k[2] = k[168] = 0, G[2] = G[168] = 1, C[8] = C[162] = 0, M[8] = M[162] = -1, O[8] = O[162] = 0, L[8] = L[162] = 0, R[8] = R[162] = -1, A[8] = A[162] = 1, T[8] = T[162] = 1, D[8] = D[162] = 0, F[8] = F[162] = 1, j[8] = j[162] = 1, k[8] = k[162] = 0, G[8] = G[162] = 0, C[32] = C[138] = 0, M[32] = M[138] = 1, O[32] = O[138] = 1, L[32] = L[138] = 0, R[32] = R[138] = 1, A[32] = A[138] = 0, E[32] = E[138] = 1, w[32] = w[138] = 0, I[32] = I[138] = 0, S[32] = S[138] = 1, N[32] = N[138] = 0, P[32] = P[138] = 1, U[128] = U[42] = 0, X[128] = X[42] = 1, Y[128] = Y[42] = 1, q[128] = q[42] = 0, B[128] = B[42] = 1, z[128] = z[42] = 0, E[128] = E[42] = -1, w[128] = w[42] = 0, I[128] = I[42] = 1, S[128] = S[42] = -1, N[128] = N[42] = 0, P[128] = P[42] = 0, L[5] = L[165] = -1, R[5] = R[165] = 0, A[5] = A[165] = 0, U[5] = U[165] = 1, X[5] = X[165] = 0, Y[5] = Y[165] = 0, j[20] = j[150] = 0, k[20] = k[150] = 1, G[20] = G[150] = 1, S[20] = S[150] = 0, N[20] = N[150] = -1, P[20] = P[150] = 1, C[80] = C[90] = -1, M[80] = M[90] = 0, O[80] = O[90] = 1, q[80] = q[90] = 1, B[80] = B[90] = 0, z[80] = z[90] = 1, T[65] = T[105] = 0, D[65] = D[105] = 1, F[65] = F[105] = 0, E[65] = E[105] = 0, w[65] = w[105] = -1, I[65] = I[105] = 0, C[160] = C[10] = -1, M[160] = M[10] = 0, O[160] = O[10] = 1, L[160] = L[10] = -1, R[160] = R[10] = 0, A[160] = A[10] = 0, U[160] = U[10] = 1, X[160] = X[10] = 0, Y[160] = Y[10] = 0, q[160] = q[10] = 1, B[160] = B[10] = 0, z[160] = z[10] = 1, j[130] = j[40] = 0, k[130] = k[40] = 1, G[130] = G[40] = 1, T[130] = T[40] = 0, D[130] = D[40] = 1, F[130] = F[40] = 0, E[130] = E[40] = 0, w[130] = w[40] = -1, I[130] = I[40] = 0, S[130] = S[40] = 0, N[130] = N[40] = -1, P[130] = P[40] = 1, L[37] = L[133] = 0, R[37] = R[133] = 1, A[37] = A[133] = 1, U[37] = U[133] = 0, X[37] = X[133] = 1, Y[37] = Y[133] = 0, E[37] = E[133] = -1, w[37] = w[133] = 0, I[37] = I[133] = 0, S[37] = S[133] = 1, N[37] = N[133] = 0, P[37] = P[133] = 0, j[148] = j[22] = -1, k[148] = k[22] = 0, G[148] = G[22] = 0, U[148] = U[22] = 0, X[148] = X[22] = -1, Y[148] = Y[22] = 1, q[148] = q[22] = 0, B[148] = B[22] = 1, z[148] = z[22] = 1, S[148] = S[22] = -1, N[148] = N[22] = 0, P[148] = P[22] = 1, C[82] = C[88] = 0, M[82] = M[88] = -1, O[82] = O[88] = 1, j[82] = j[88] = 1, k[82] = k[88] = 0, G[82] = G[88] = 1, T[82] = T[88] = -1, D[82] = D[88] = 0, F[82] = F[88] = 1, q[82] = q[88] = 0, B[82] = B[88] = -1, z[82] = z[88] = 0, C[73] = C[97] = 0, M[73] = M[97] = 1, O[73] = O[97] = 0, L[73] = L[97] = 0, R[73] = R[97] = -1, A[73] = A[97] = 0, T[73] = T[97] = 1, D[73] = D[97] = 0, F[73] = F[97] = 0, E[73] = E[97] = 1, w[73] = w[97] = 0, I[73] = I[97] = 1, C[145] = C[25] = 0, M[145] = M[25] = -1, O[145] = O[25] = 0, T[145] = T[25] = 1, D[145] = D[25] = 0, F[145] = F[25] = 1, U[145] = U[25] = 0, X[145] = X[25] = 1, Y[145] = Y[25] = 1, S[145] = S[25] = -1, N[145] = N[25] = 0, P[145] = P[25] = 0, L[70] = L[100] = 0, R[70] = R[100] = 1, A[70] = A[100] = 0, j[70] = j[100] = -1, k[70] = k[100] = 0, G[70] = G[100] = 1, q[70] = q[100] = 0, B[70] = B[100] = -1, z[70] = z[100] = 1, E[70] = E[100] = 1, w[70] = w[100] = 0, I[70] = I[100] = 0, L[101] = L[69] = 0, R[101] = R[69] = 1, A[101] = A[69] = 0, E[101] = E[69] = 1, w[101] = w[69] = 0, I[101] = I[69] = 0, U[149] = U[21] = 0, X[149] = X[21] = 1, Y[149] = Y[21] = 1, S[149] = S[21] = -1, N[149] = N[21] = 0, P[149] = P[21] = 0, j[86] = j[84] = -1, k[86] = k[84] = 0, G[86] = G[84] = 1, q[86] = q[84] = 0, B[86] = B[84] = -1, z[86] = z[84] = 1, C[89] = C[81] = 0, M[89] = M[81] = -1, O[89] = O[81] = 0, T[89] = T[81] = 1, D[89] = D[81] = 0, F[89] = F[81] = 1, C[96] = C[74] = 0, M[96] = M[74] = 1, O[96] = O[74] = 0, L[96] = L[74] = -1, R[96] = R[74] = 0, A[96] = A[74] = 1, q[96] = q[74] = 1, B[96] = B[74] = 0, z[96] = z[74] = 0, E[96] = E[74] = 1, w[96] = w[74] = 0, I[96] = I[74] = 1, C[24] = C[146] = 0, M[24] = M[146] = -1, O[24] = O[146] = 1, j[24] = j[146] = 1, k[24] = k[146] = 0, G[24] = G[146] = 1, T[24] = T[146] = 0, D[24] = D[146] = 1, F[24] = F[146] = 1, S[24] = S[146] = 0, N[24] = N[146] = -1, P[24] = P[146] = 0, L[6] = L[164] = -1, R[6] = R[164] = 0, A[6] = A[164] = 1, j[6] = j[164] = -1, k[6] = k[164] = 0, G[6] = G[164] = 0, U[6] = U[164] = 0, X[6] = X[164] = -1, Y[6] = Y[164] = 1, q[6] = q[164] = 1, B[6] = B[164] = 0, z[6] = z[164] = 0, T[129] = T[41] = 0, D[129] = D[41] = 1, F[129] = F[41] = 1, U[129] = U[41] = 0, X[129] = X[41] = 1, Y[129] = Y[41] = 0, E[129] = E[41] = -1, w[129] = w[41] = 0, I[129] = I[41] = 0, S[129] = S[41] = 0, N[129] = N[41] = -1, P[129] = P[41] = 0, j[66] = j[104] = 0, k[66] = k[104] = 1, G[66] = G[104] = 0, T[66] = T[104] = -1, D[66] = D[104] = 0, F[66] = F[104] = 1, q[66] = q[104] = 0, B[66] = B[104] = -1, z[66] = z[104] = 0, E[66] = E[104] = 0, w[66] = w[104] = -1, I[66] = I[104] = 1, C[144] = C[26] = -1, M[144] = M[26] = 0, O[144] = O[26] = 0, U[144] = U[26] = 1, X[144] = X[26] = 0, Y[144] = Y[26] = 1, q[144] = q[26] = 0, B[144] = B[26] = 1, z[144] = z[26] = 1, S[144] = S[26] = -1, N[144] = N[26] = 0, P[144] = P[26] = 1, L[36] = L[134] = 0, R[36] = R[134] = 1, A[36] = A[134] = 1, j[36] = j[134] = 0, k[36] = k[134] = 1, G[36] = G[134] = 0, E[36] = E[134] = 0, w[36] = w[134] = -1, I[36] = I[134] = 1, S[36] = S[134] = 1, N[36] = N[134] = 0, P[36] = P[134] = 0, C[9] = C[161] = -1, M[9] = M[161] = 0, O[9] = O[161] = 0, L[9] = L[161] = 0, R[9] = R[161] = -1, A[9] = A[161] = 0, T[9] = T[161] = 1, D[9] = D[161] = 0, F[9] = F[161] = 0, U[9] = U[161] = 1, X[9] = X[161] = 0, Y[9] = Y[161] = 1, C[136] = 0, M[136] = 1, O[136] = 1, L[136] = 0, R[136] = 1, A[136] = 0, j[136] = -1, k[136] = 0, G[136] = 1, T[136] = -1, D[136] = 0, F[136] = 0, U[136] = 0, X[136] = -1, Y[136] = 0, q[136] = 0, B[136] = -1, z[136] = 1, E[136] = 1, w[136] = 0, I[136] = 0, S[136] = 1, N[136] = 0, P[136] = 1, C[34] = 0, M[34] = -1, O[34] = 0, L[34] = 0, R[34] = -1, A[34] = 1, j[34] = 1, k[34] = 0, G[34] = 0, T[34] = 1, D[34] = 0, F[34] = 1, U[34] = 0, X[34] = 1, Y[34] = 1, q[34] = 0, B[34] = 1, z[34] = 0, E[34] = -1, w[34] = 0, I[34] = 1, S[34] = -1, N[34] = 0, P[34] = 0, C[35] = 0, M[35] = 1, O[35] = 1, L[35] = 0, R[35] = -1, A[35] = 1, j[35] = 1, k[35] = 0, G[35] = 0, T[35] = -1, D[35] = 0, F[35] = 0, U[35] = 0, X[35] = -1, Y[35] = 0, q[35] = 0, B[35] = 1, z[35] = 0, E[35] = -1, w[35] = 0, I[35] = 1, S[35] = 1, N[35] = 0, P[35] = 1, C[153] = 0, M[153] = 1, O[153] = 1, T[153] = -1, D[153] = 0, F[153] = 0, U[153] = 0, X[153] = -1, Y[153] = 0, S[153] = 1, N[153] = 0, P[153] = 1, L[102] = 0, R[102] = -1, A[102] = 1, j[102] = 1, k[102] = 0, G[102] = 0, q[102] = 0, B[102] = 1, z[102] = 0, E[102] = -1, w[102] = 0, I[102] = 1, C[155] = 0, M[155] = -1, O[155] = 0, T[155] = 1, D[155] = 0, F[155] = 1, U[155] = 0, X[155] = 1, Y[155] = 1, S[155] = -1, N[155] = 0, P[155] = 0, L[103] = 0, R[103] = 1, A[103] = 0, j[103] = -1, k[103] = 0, G[103] = 1, q[103] = 0, B[103] = -1, z[103] = 1, E[103] = 1, w[103] = 0, I[103] = 0, C[152] = 0, M[152] = 1, O[152] = 1, j[152] = -1, k[152] = 0, G[152] = 1, T[152] = -1, D[152] = 0, F[152] = 0, U[152] = 0, X[152] = -1, Y[152] = 0, q[152] = 0, B[152] = -1, z[152] = 1, S[152] = 1, N[152] = 0, P[152] = 1, C[156] = 0, M[156] = -1, O[156] = 1, j[156] = 1, k[156] = 0, G[156] = 1, T[156] = -1, D[156] = 0, F[156] = 0, U[156] = 0, X[156] = -1, Y[156] = 0, q[156] = 0, B[156] = 1, z[156] = 1, S[156] = -1, N[156] = 0, P[156] = 1, C[137] = 0, M[137] = 1, O[137] = 1, L[137] = 0, R[137] = 1, A[137] = 0, T[137] = -1, D[137] = 0, F[137] = 0, U[137] = 0, X[137] = -1, Y[137] = 0, E[137] = 1, w[137] = 0, I[137] = 0, S[137] = 1, N[137] = 0, P[137] = 1, C[139] = 0, M[139] = 1, O[139] = 1, L[139] = 0, R[139] = -1, A[139] = 0, T[139] = 1, D[139] = 0, F[139] = 0, U[139] = 0, X[139] = 1, Y[139] = 0, E[139] = -1, w[139] = 0, I[139] = 0, S[139] = 1, N[139] = 0, P[139] = 1, C[98] = 0, M[98] = -1, O[98] = 0, L[98] = 0, R[98] = -1, A[98] = 1, j[98] = 1, k[98] = 0, G[98] = 0, T[98] = 1, D[98] = 0, F[98] = 1, q[98] = 0, B[98] = 1, z[98] = 0, E[98] = -1, w[98] = 0, I[98] = 1, C[99] = 0, M[99] = 1, O[99] = 0, L[99] = 0, R[99] = -1, A[99] = 1, j[99] = 1, k[99] = 0, G[99] = 0, T[99] = -1, D[99] = 0, F[99] = 1, q[99] = 0, B[99] = -1, z[99] = 0, E[99] = 1, w[99] = 0, I[99] = 1, L[38] = 0, R[38] = -1, A[38] = 1, j[38] = 1, k[38] = 0, G[38] = 0, U[38] = 0, X[38] = 1, Y[38] = 1, q[38] = 0, B[38] = 1, z[38] = 0, E[38] = -1, w[38] = 0, I[38] = 1, S[38] = -1, N[38] = 0, P[38] = 0, L[39] = 0, R[39] = 1, A[39] = 1, j[39] = -1, k[39] = 0, G[39] = 0, U[39] = 0, X[39] = -1, Y[39] = 1, q[39] = 0, B[39] = 1, z[39] = 0, E[39] = -1, w[39] = 0, I[39] = 1, S[39] = 1, N[39] = 0, P[39] = 0; const V = function (t) { return [[t.bottomleft, 0], [0, 0], [0, t.leftbottom]] }; const W = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0]] }; const H = function (t) { return [[t.topright, 1], [1, 1], [1, t.righttop]] }; const J = function (t) { return [[0, t.lefttop], [0, 1], [t.topleft, 1]] }; const Z = function (t) { return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop]] }; const K = function (t) { return [[t.bottomright, 0], [t.bottomleft, 0], [1, t.righttop], [1, t.rightbottom]] }; const Q = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.topleft, 1], [t.topright, 1]] }; const $ = function (t) { return [[0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]] }; var tt = []; var et = []; var nt = []; var rt = []; var it = []; var ot = []; var st = []; const at = []; rt[1] = it[1] = 18, rt[169] = it[169] = 18, nt[4] = et[4] = 12, nt[166] = et[166] = 12, tt[16] = at[16] = 4, tt[154] = at[154] = 4, ot[64] = st[64] = 22, ot[106] = st[106] = 22, nt[2] = ot[2] = 17, rt[2] = it[2] = 18, nt[168] = ot[168] = 17, rt[168] = it[168] = 18, tt[8] = rt[8] = 9, et[8] = nt[8] = 12, tt[162] = rt[162] = 9, et[162] = nt[162] = 12, tt[32] = at[32] = 4, et[32] = st[32] = 1, tt[138] = at[138] = 4, et[138] = st[138] = 1, it[128] = at[128] = 21, ot[128] = st[128] = 22, it[42] = at[42] = 21, ot[42] = st[42] = 22, et[5] = it[5] = 14, et[165] = it[165] = 14, nt[20] = at[20] = 6, nt[150] = at[150] = 6, tt[80] = ot[80] = 11, tt[90] = ot[90] = 11, rt[65] = st[65] = 3, rt[105] = st[105] = 3, tt[160] = ot[160] = 11, et[160] = it[160] = 14, tt[10] = ot[10] = 11, et[10] = it[10] = 14, nt[130] = at[130] = 6, rt[130] = st[130] = 3, nt[40] = at[40] = 6, rt[40] = st[40] = 3, et[101] = st[101] = 1, et[69] = st[69] = 1, it[149] = at[149] = 21, it[21] = at[21] = 21, nt[86] = ot[86] = 17, nt[84] = ot[84] = 17, tt[89] = rt[89] = 9, tt[81] = rt[81] = 9, tt[96] = st[96] = 0, et[96] = ot[96] = 15, tt[74] = st[74] = 0, et[74] = ot[74] = 15, tt[24] = nt[24] = 8, rt[24] = at[24] = 7, tt[146] = nt[146] = 8, rt[146] = at[146] = 7, et[6] = ot[6] = 15, nt[6] = it[6] = 16, et[164] = ot[164] = 15, nt[164] = it[164] = 16, rt[129] = at[129] = 7, it[129] = st[129] = 20, rt[41] = at[41] = 7, it[41] = st[41] = 20, nt[66] = st[66] = 2, rt[66] = ot[66] = 19, nt[104] = st[104] = 2, rt[104] = ot[104] = 19, tt[144] = it[144] = 10, ot[144] = at[144] = 23, tt[26] = it[26] = 10, ot[26] = at[26] = 23, et[36] = at[36] = 5, nt[36] = st[36] = 2, et[134] = at[134] = 5, nt[134] = st[134] = 2, tt[9] = it[9] = 10, et[9] = rt[9] = 13, tt[161] = it[161] = 10, et[161] = rt[161] = 13, et[37] = at[37] = 5, it[37] = st[37] = 20, et[133] = at[133] = 5, it[133] = st[133] = 20, nt[148] = it[148] = 16, ot[148] = at[148] = 23, nt[22] = it[22] = 16, ot[22] = at[22] = 23, tt[82] = nt[82] = 8, rt[82] = ot[82] = 19, tt[88] = nt[88] = 8, rt[88] = ot[88] = 19, tt[73] = st[73] = 0, et[73] = rt[73] = 13, tt[97] = st[97] = 0, et[97] = rt[97] = 13, tt[145] = rt[145] = 9, it[145] = at[145] = 21, tt[25] = rt[25] = 9, it[25] = at[25] = 21, et[70] = st[70] = 1, nt[70] = ot[70] = 17, et[100] = st[100] = 1, nt[100] = ot[100] = 17, tt[34] = rt[34] = 9, et[34] = nt[34] = 12, it[34] = at[34] = 21, ot[34] = st[34] = 22, tt[136] = at[136] = 4, et[136] = st[136] = 1, nt[136] = ot[136] = 17, rt[136] = it[136] = 18, tt[35] = at[35] = 4, et[35] = nt[35] = 12, rt[35] = it[35] = 18, ot[35] = st[35] = 22, tt[153] = at[153] = 4, rt[153] = it[153] = 18, et[102] = nt[102] = 12, ot[102] = st[102] = 22, tt[155] = rt[155] = 9, it[155] = at[155] = 23, et[103] = st[103] = 1, nt[103] = ot[103] = 17, tt[152] = at[152] = 4, nt[152] = ot[152] = 17, rt[152] = it[152] = 18, tt[156] = nt[156] = 8, rt[156] = it[156] = 18, ot[156] = at[156] = 23, tt[137] = at[137] = 4, et[137] = st[137] = 1, rt[137] = it[137] = 18, tt[139] = at[139] = 4, et[139] = rt[139] = 13, it[139] = st[139] = 20, tt[98] = rt[98] = 9, et[98] = nt[98] = 12, ot[98] = st[98] = 22, tt[99] = st[99] = 0, et[99] = nt[99] = 12, rt[99] = ot[99] = 19, et[38] = nt[38] = 12, it[38] = at[38] = 21, ot[38] = st[38] = 22, et[39] = at[39] = 5, nt[39] = it[39] = 16, ot[39] = st[39] = 22; var ut = []; function lt (t, e, n) { return (t - e) / (n - e) } function ct (t) { return t.constructor.toString().indexOf('Array') > -1 } function ft (t, e, n, r, i, o) { for (var s = t.cells[n][e], a = s.cval_real, u = e + r, l = n + i, c = [], f = !1; !f;) { if (void 0 === t.cells[l] || void 0 === t.cells[l][u]) if (l -= i, u -= r, a = (s = t.cells[l][u]).cval_real, i === -1) if (o === 0) if (1 & a)c.push([u, l]), r = -1, i = 0, o = 0; else { if (!(4 & a)) { c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, f = !0; break }c.push([u + 1, l]), r = 1, i = 0, o = 0 } else { if (!(1 & a)) { if (4 & a) { c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, f = !0; break }c.push([u + s.bottomleft, l]), r = 0, i = 1, o = 0, f = !0; break }c.push([u, l]), r = -1, i = 0, o = 0 } else if (i === 1) if (o === 0) { if (!(a & b)) { if (a & x) { c.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, f = !0; break }c.push([u + s.topright, l + 1]), r = 0, i = -1, o = 1, f = !0; break }c.push([u + 1, l + 1]), r = 1, i = 0, o = 1 } else c.push([u + 1, l + 1]), r = 1, i = 0, o = 1; else if (r === -1) if (o === 0) { if (!(a & x)) { if (1 & a) { c.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, f = !0; break }c.push([u, l + s.lefttop]), r = 1, i = 0, o = 1, f = !0; break }c.push([u, l + 1]), r = 0, i = 1, o = 0 } else { if (!(a & x)) { console.log('MarchingSquaresJS-isoBands: wtf'); break }c.push([u, l + 1]), r = 0, i = 1, o = 0 } else { if (r !== 1) { console.log('MarchingSquaresJS-isoBands: we came from nowhere!'); break } if (o === 0) { if (!(4 & a)) { c.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, f = !0; break }c.push([u + 1, l]), r = 0, i = -1, o = 1 } else { if (!(4 & a)) { if (a & b) { c.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1; break }c.push([u + 1, l + s.rightbottom]), r = -1, i = 0, o = 0, f = !0; break }c.push([u + 1, l]), r = 0, i = -1, o = 1 } } else if (a = (s = t.cells[l][u]).cval_real, r === -1) if (o === 0) if (void 0 !== t.cells[l - 1] && void 0 !== t.cells[l - 1][u])r = 0, i = -1, o = 1; else { if (!(1 & a)) { c.push([u + s.bottomright, l]), r = 0, i = 1, o = 1, f = !0; break }c.push([u, l]) } else { if (!(a & x)) { console.log('MarchingSquaresJS-isoBands: found entry from top at ' + u + ',' + l); break }console.log('MarchingSquaresJS-isoBands: proceeding in x-direction!') } else if (r === 1) { if (o === 0) { console.log('MarchingSquaresJS-isoBands: wtf'); break } if (void 0 !== t.cells[l + 1] && void 0 !== t.cells[l + 1][u])r = 0, i = 1, o = 0; else { if (!(a & b)) { c.push([u + s.topleft, l + 1]), r = 0, i = -1, o = 0, f = !0; break }c.push([u + 1, l + 1]), r = 1, i = 0, o = 1 } } else if (i === -1) { if (o !== 1) { console.log('MarchingSquaresJS-isoBands: wtf'); break } if (void 0 !== t.cells[l][u + 1])r = 1, i = 0, o = 1; else { if (!(4 & a)) { c.push([u + 1, l + s.righttop]), r = -1, i = 0, o = 1, f = !0; break }c.push([u + 1, l]), r = 0, i = -1, o = 1 } } else { if (i !== 1) { console.log('MarchingSquaresJS-isoBands: where did we came from???'); break } if (o !== 0) { console.log('MarchingSquaresJS-isoBands: wtf'); break } if (void 0 !== t.cells[l][u - 1])r = -1, i = 0, o = 0; else { if (!(a & x)) { c.push([u, l + s.leftbottom]), r = 1, i = 0, o = 0, f = !0; break }c.push([u, l + 1]), r = 0, i = 1, o = 0 } } if (l += i, (u += r) === e && l === n) break } return { path: c, i: u, j: l, x: r, y: i, o } } function ht (t) { if (t.edges.length > 0) { const e = t.edges[t.edges.length - 1]; const n = t.cval_real; switch (e) { case 0:return n & b ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [t.topleft, 1], x: 0, y: -1, o: 0 }; case 1:return 4 & n ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 2:return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [t.topleft, 1], x: 0, y: -1, o: 0 }; case 3:return 1 & n ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 4:return n & b ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; case 5:return 4 & n ? { p: [t.topright, 1], x: 0, y: -1, o: 1 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 6:return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; case 7:return 1 & n ? { p: [t.topright, 1], x: 0, y: -1, o: 1 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 8:return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [1, t.righttop], x: -1, y: 0, o: 1 }; case 9:return 1 & n ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 10:return 1 & n ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [1, t.righttop], x: -1, y: 0, o: 1 }; case 11:return n & x ? { p: [1, t.righttop], x: -1, y: 0, o: 1 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 12:return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 13:return 1 & n ? { p: [1, t.rightbottom], x: -1, y: 0, o: 0 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 14:return 1 & n ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [1, t.rightbottom], x: -1, y: 0, o: 0 }; case 15:return n & x ? { p: [1, t.rightbottom], x: -1, y: 0, o: 0 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 16:return 4 & n ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [0, t.leftbottom], x: 1, y: 0, o: 0 }; case 17:return n & x ? { p: [t.bottomright, 0], x: 0, y: 1, o: 1 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 18:return 1 & n ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 }; case 19:return n & x ? { p: [t.bottomleft, 0], x: 0, y: 1, o: 0 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 20:return n & x ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [0, t.leftbottom], x: 1, y: 0, o: 0 }; case 21:return n & b ? { p: [0, t.leftbottom], x: 1, y: 0, o: 0 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; case 22:return n & x ? { p: [t.topleft, 1], x: 0, y: -1, o: 0 } : { p: [0, t.lefttop], x: 1, y: 0, o: 1 }; case 23:return n & b ? { p: [0, t.lefttop], x: 1, y: 0, o: 1 } : { p: [t.topright, 1], x: 0, y: -1, o: 1 }; default:console.log('MarchingSquaresJS-isoBands: edge index out of range!'), console.log(t) } } return null } function pt (t, e, n, r) { let i; let o; let s; let a; let u; let l = t.cval; switch (e) { case -1:r === 0 ? (i = et[l], s = L[l], a = R[l], u = A[l]) : (i = tt[l], s = C[l], a = M[l], u = O[l]); break; case 1:r === 0 ? (i = it[l], s = U[l], a = X[l], u = Y[l]) : (i = ot[l], s = q[l], a = B[l], u = z[l]); break; default:switch (n) { case -1:r === 0 ? (i = st[l], s = E[l], a = w[l], u = I[l]) : (i = at[l], s = S[l], a = N[l], u = P[l]); break; case 1:r === 0 ? (i = rt[l], s = T[l], a = D[l], u = F[l]) : (i = nt[l], s = j[l], a = k[l], u = G[l]) } } if (o = t.edges.indexOf(i), void 0 === t.edges[o]) return null; switch ((function (t, e) { delete t.edges[e]; for (let n = e + 1; n < t.edges.length; n++)t.edges[n - 1] = t.edges[n]; t.edges.pop() }(t, o)), l = t.cval_real, i) { case 0:l & b ? (e = t.topleft, n = 1) : (e = 1, n = t.righttop); break; case 1:4 & l ? (e = 1, n = t.rightbottom) : (e = t.topleft, n = 1); break; case 2:4 & l ? (e = t.topleft, n = 1) : (e = t.bottomright, n = 0); break; case 3:1 & l ? (e = t.bottomleft, n = 0) : (e = t.topleft, n = 1); break; case 4:l & b ? (e = t.topright, n = 1) : (e = 1, n = t.righttop); break; case 5:4 & l ? (e = 1, n = t.rightbottom) : (e = t.topright, n = 1); break; case 6:4 & l ? (e = t.topright, n = 1) : (e = t.bottomright, n = 0); break; case 7:1 & l ? (e = t.bottomleft, n = 0) : (e = t.topright, n = 1); break; case 8:4 & l ? (e = 1, n = t.righttop) : (e = t.bottomright, n = 0); break; case 9:1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.righttop); break; case 10:1 & l ? (e = 1, n = t.righttop) : (e = 0, n = t.leftbottom); break; case 11:l & x ? (e = 0, n = t.lefttop) : (e = 1, n = t.righttop); break; case 12:4 & l ? (e = 1, n = t.rightbottom) : (e = t.bottomright, n = 0); break; case 13:1 & l ? (e = t.bottomleft, n = 0) : (e = 1, n = t.rightbottom); break; case 14:1 & l ? (e = 1, n = t.rightbottom) : (e = 0, n = t.leftbottom); break; case 15:l & x ? (e = 0, n = t.lefttop) : (e = 1, n = t.rightbottom); break; case 16:4 & l ? (e = 0, n = t.leftbottom) : (e = t.bottomright, n = 0); break; case 17:l & x ? (e = 0, n = t.lefttop) : (e = t.bottomright, n = 0); break; case 18:1 & l ? (e = t.bottomleft, n = 0) : (e = 0, n = t.leftbottom); break; case 19:l & x ? (e = 0, n = t.lefttop) : (e = t.bottomleft, n = 0); break; case 20:l & x ? (e = 0, n = t.leftbottom) : (e = t.topleft, n = 1); break; case 21:l & b ? (e = t.topright, n = 1) : (e = 0, n = t.leftbottom); break; case 22:l & x ? (e = 0, n = t.lefttop) : (e = t.topleft, n = 1); break; case 23:l & b ? (e = t.topright, n = 1) : (e = 0, n = t.lefttop); break; default:return console.log('MarchingSquaresJS-isoBands: edge index out of range!'), console.log(t), null } return void 0 !== e && void 0 !== n && void 0 !== s && void 0 !== a && void 0 !== u || (console.log('MarchingSquaresJS-isoBands: undefined value!'), console.log(t), console.log(e + ' ' + n + ' ' + s + ' ' + a + ' ' + u)), { p: [e, n], x: s, y: a, o: u } } function gt (t, e, n) { if (n = n || {}, !u.isObject(n)) throw new Error('options is invalid'); const r = n.zProperty || 'elevation'; const i = n.commonProperties || {}; const o = n.breaksProperties || []; if (a.collectionOf(t, 'Point', 'Input must contain Points'), !e) throw new Error('breaks is required'); if (!Array.isArray(e)) throw new Error('breaks is not an Array'); if (!u.isObject(i)) throw new Error('commonProperties is not an Object'); if (!Array.isArray(o)) throw new Error('breaksProperties is not an Array'); const s = (function (t, e) { if (e = e || {}, !u.isObject(e)) throw new Error('options is invalid'); const n = e.zProperty || 'elevation'; const r = e.flip; const i = e.flags; a.collectionOf(t, 'Point', 'input must contain Points'); for (var o = (function (t, e) { const n = {}; return c.featureEach(t, function (t) { const e = a.getCoords(t)[1]; n[e] || (n[e] = []), n[e].push(t) }), Object.keys(n).map(function (t) { return n[t].sort(function (t, e) { return a.getCoords(t)[0] - a.getCoords(e)[0] }) }).sort(function (t, n) { return e ? a.getCoords(t[0])[1] - a.getCoords(n[0])[1] : a.getCoords(n[0])[1] - a.getCoords(t[0])[1] }) }(t, r)), s = [], l = 0; l < o.length; l++) { for (var f = o[l], h = [], p = 0; p < f.length; p++) { const g = f[p]; g.properties[n] ? h.push(g.properties[n]) : h.push(0), !0 === i && (g.properties.matrixPosition = [l, p]) }s.push(h) } return s }(t, { zProperty: r, flip: !0 })); let l = (function (t, e, n) { for (var r = [], i = 1; i < e.length; i++) { const o = +e[i - 1]; const s = +e[i]; const a = yt(dt(m(t, o, s - o))); const u = {}; u.groupedRings = a, u[n] = o + '-' + s, r.push(u) } return r }(s, e, r)); l = (function (t, e, n) { const r = h.default(n); const i = r[2] - r[0]; const o = r[3] - r[1]; const s = r[0]; const a = r[1]; const u = e[0].length - 1; const l = e.length - 1; const c = i / u; const f = o / l; const p = function (t) { t[0] = t[0] * c + s, t[1] = t[1] * f + a }; return t.forEach(function (t) { t.groupedRings.forEach(function (t) { t.forEach(function (t) { t.forEach(p) }) }) }), t }(l, s, t)); const f = l.map(function (t, e) { if (o[e] && !u.isObject(o[e])) throw new Error('Each mappedProperty is required to be an Object'); const n = y.default({}, i, o[e]); return n[r] = t[r], u.multiPolygon(t.groupedRings, n) }); return u.featureCollection(f) } function dt (t) { const e = []; const n = []; t.forEach(function (t) { const r = p.default(u.polygon([t])); n.push(r), e.push({ ring: t, area: r }) }), n.sort(function (t, e) { return e - t }); const r = []; return n.forEach(function (t) { for (let n = 0; n < e.length; n++) if (e[n].area === t) { r.push(e[n].ring), e.splice(n, 1); break } }), r } function yt (t) { for (var e = t.map(function (t) { return { lrCoordinates: t, grouped: !1 } }), n = []; !_t(e);) for (let r = 0; r < e.length; r++) if (!e[r].grouped) { const i = []; i.push(e[r].lrCoordinates), e[r].grouped = !0; for (let o = u.polygon([e[r].lrCoordinates]), s = r + 1; s < e.length; s++)e[s].grouped || vt(u.polygon([e[s].lrCoordinates]), o) && (i.push(e[s].lrCoordinates), e[s].grouped = !0); n.push(i) } return n } function vt (t, e) { for (let n = d.default(t), r = 0; r < n.features.length; r++) if (!g.default(n.features[r], e)) return !1; return !0 } function _t (t) { for (let e = 0; e < t.length; e++) if (!1 === t[e].grouped) return !1; return !0 }ut[1] = ut[169] = V, ut[4] = ut[166] = W, ut[16] = ut[154] = H, ut[64] = ut[106] = J, ut[168] = ut[2] = Z, ut[162] = ut[8] = K, ut[138] = ut[32] = Q, ut[42] = ut[128] = $, ut[5] = ut[165] = function (t) { return [[0, 0], [0, t.leftbottom], [1, t.rightbottom], [1, 0]] }, ut[20] = ut[150] = function (t) { return [[1, 0], [t.bottomright, 0], [t.topright, 1], [1, 1]] }, ut[80] = ut[90] = function (t) { return [[1, 1], [1, t.righttop], [0, t.lefttop], [0, 1]] }, ut[65] = ut[105] = function (t) { return [[t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]] }, ut[160] = ut[10] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [0, t.leftbottom], [0, t.lefttop]] }, ut[130] = ut[40] = function (t) { return [[t.topleft, 1], [t.topright, 1], [t.bottomright, 0], [t.bottomleft, 0]] }, ut[85] = function () { return [[0, 0], [0, 1], [1, 1], [1, 0]] }, ut[101] = ut[69] = function (t) { return [[1, t.rightbottom], [1, 0], [0, 0], [0, 1], [t.topleft, 1]] }, ut[149] = ut[21] = function (t) { return [[t.topright, 1], [1, 1], [1, 0], [0, 0], [0, t.leftbottom]] }, ut[86] = ut[84] = function (t) { return [[1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [1, 1]] }, ut[89] = ut[81] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, 1]] }, ut[96] = ut[74] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, ut[24] = ut[146] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [t.topright, 1]] }, ut[6] = ut[164] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop]] }, ut[129] = ut[41] = function (t) { return [[t.topright, 1], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1]] }, ut[66] = ut[104] = function (t) { return [[t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, ut[144] = ut[26] = function (t) { return [[1, 1], [1, t.righttop], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]] }, ut[36] = ut[134] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [t.topleft, 1], [t.topright, 1]] }, ut[9] = ut[161] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom]] }, ut[37] = ut[133] = function (t) { return [[1, t.rightbottom], [1, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]] }, ut[148] = ut[22] = function (t) { return [[1, 1], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]] }, ut[82] = ut[88] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1]] }, ut[73] = ut[97] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, 1], [t.topleft, 1]] }, ut[145] = ut[25] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]] }, ut[70] = ut[100] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, ut[34] = function (t) { return [$(t), K(t)] }, ut[35] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]] }, ut[136] = function (t) { return [Q(t), Z(t)] }, ut[153] = function (t) { return [H(t), V(t)] }, ut[102] = function (t) { return [W(t), J(t)] }, ut[155] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topright, 1]] }, ut[103] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, ut[152] = function (t) { return [H(t), Z(t)] }, ut[156] = function (t) { return [[1, 1], [1, t.righttop], [t.bottomright, 0], [t.bottomleft, 0], [0, t.leftbottom], [0, t.lefttop], [t.topright, 1]] }, ut[137] = function (t) { return [Q(t), V(t)] }, ut[139] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomleft, 0], [0, 0], [0, t.leftbottom], [t.topleft, 1], [t.topright, 1]] }, ut[98] = function (t) { return [K(t), J(t)] }, ut[99] = function (t) { return [[1, t.righttop], [1, t.rightbottom], [t.bottomright, 0], [t.bottomleft, 0], [0, t.lefttop], [0, 1], [t.topleft, 1]] }, ut[38] = function (t) { return [W(t), $(t)] }, ut[39] = function (t) { return [[1, t.rightbottom], [1, 0], [t.bottomright, 0], [0, t.leftbottom], [0, t.lefttop], [t.topleft, 1], [t.topright, 1]] }, t.exports = gt, t.exports.default = gt }, 7928: (t, e, n) => { 'use strict'; const r = n(9705); const i = n(1540); const o = n(611); const s = n(4102); const a = n(7418); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(r); const c = u(a); const f = { successCallback: null, verbose: !1 }; const h = {}; function p (t, e, n) { n = n || {}; for (let r = Object.keys(f), i = 0; i < r.length; i++) { const o = r[i]; let s = n[o]; s = s != null ? s : f[o], h[o] = s }h.verbose && console.log('MarchingSquaresJS-isoContours: computing isocontour for ' + e); let a; let u; let l; const c = (a = (function (t, e) { for (var n = t.length - 1, r = t[0].length - 1, i = { rows: n, cols: r, cells: [] }, o = 0; o < n; ++o) { i.cells[o] = []; for (let s = 0; s < r; ++s) { let a = 0; const u = t[o + 1][s]; const l = t[o + 1][s + 1]; const c = t[o][s + 1]; const f = t[o][s]; if (!(isNaN(u) || isNaN(l) || isNaN(c) || isNaN(f))) { a |= u >= e ? 8 : 0, a |= l >= e ? 4 : 0, a |= c >= e ? 2 : 0; var h; var p; var d; var y; let v = !1; if ((a |= f >= e ? 1 : 0) == 5 || a === 10) { const _ = (u + l + c + f) / 4; a === 5 && _ < e ? (a = 10, v = !0) : a === 10 && _ < e && (a = 5, v = !0) }a !== 0 && a !== 15 && (h = p = d = y = 0.5, a === 1 ? (d = 1 - g(e, u, f), p = 1 - g(e, c, f)) : a === 2 ? (p = g(e, f, c), y = 1 - g(e, l, c)) : a === 3 ? (d = 1 - g(e, u, f), y = 1 - g(e, l, c)) : a === 4 ? (h = g(e, u, l), y = g(e, c, l)) : a === 5 ? (h = g(e, u, l), y = g(e, c, l), p = 1 - g(e, c, f), d = 1 - g(e, u, f)) : a === 6 ? (p = g(e, f, c), h = g(e, u, l)) : a === 7 ? (d = 1 - g(e, u, f), h = g(e, u, l)) : a === 8 ? (d = g(e, f, u), h = 1 - g(e, l, u)) : a === 9 ? (p = 1 - g(e, c, f), h = 1 - g(e, l, u)) : a === 10 ? (h = 1 - g(e, l, u), y = 1 - g(e, l, c), p = g(e, f, c), d = g(e, f, u)) : a === 11 ? (h = 1 - g(e, l, u), y = 1 - g(e, l, c)) : a === 12 ? (d = g(e, f, u), y = g(e, c, l)) : a === 13 ? (p = 1 - g(e, c, f), y = g(e, c, l)) : a === 14 ? (d = g(e, f, u), p = g(e, f, c)) : console.log('MarchingSquaresJS-isoContours: Illegal cval detected: ' + a), i.cells[o][s] = { cval: a, flipped: v, top: h, right: y, bottom: p, left: d }) } } } return i }(t, e)), u = [], l = 0, 1e-7, a.cells.forEach(function (t, e) { t.forEach(function (t, n) { if (void 0 !== t && (h = t).cval !== 5 && h.cval !== 10 && !d(t)) { const r = (function (t, e, n) { let r; let i; const o = t.length; const s = []; const a = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0]; const u = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0]; const l = ['none', 'bottom', 'right', 'right', 'top', 'top', 'top', 'top', 'left', 'bottom', 'right', 'right', 'left', 'bottom', 'left', 'none']; let c = t[e][n]; let f = c.cval; let h = ['none', 'left', 'bottom', 'left', 'right', 'none', 'bottom', 'left', 'top', 'top', 'none', 'top', 'right', 'right', 'bottom', 'none'][f]; let p = v(c, h); s.push([n + p[0], e + p[1]]), p = v(c, h = l[f]), s.push([n + p[0], e + p[1]]), y(c); for (let g = n + a[f], d = e + u[f], _ = f; g >= 0 && d >= 0 && d < o && (g != n || d != e) && void 0 !== (c = t[d][g]);) { if ((f = c.cval) === 0 || f === 15) return { path: s, info: 'mergeable' }; h = l[f], r = a[f], i = u[f], f !== 5 && f !== 10 || (f === 5 ? c.flipped ? u[_] === -1 ? (h = 'left', r = -1, i = 0) : (h = 'right', r = 1, i = 0) : a[_] === -1 && (h = 'bottom', r = 0, i = -1) : f === 10 && (c.flipped ? a[_] === -1 ? (h = 'top', r = 0, i = 1) : (h = 'bottom', r = 0, i = -1) : u[_] === 1 && (h = 'left', r = -1, i = 0))), p = v(c, h), s.push([g + p[0], d + p[1]]), y(c), g += r, d += i, _ = f } return { path: s, info: 'closed' } }(a.cells, e, n)); let i = !1; if (r.info === 'mergeable') for (let o = r.path[r.path.length - 1][0], s = r.path[r.path.length - 1][1], c = l - 1; c >= 0; c--) if (Math.abs(u[c][0][0] - o) <= 1e-7 && Math.abs(u[c][0][1] - s) <= 1e-7) { for (let f = r.path.length - 2; f >= 0; --f)u[c].unshift(r.path[f]); i = !0; break }i || (u[l++] = r.path) } let h }) }), u); return typeof h.successCallback === 'function' && h.successCallback(c), c } function g (t, e, n) { return (t - e) / (n - e) } function d (t) { return t.cval === 0 || t.cval === 15 } function y (t) { d(t) || t.cval === 5 || t.cval === 10 || (t.cval = 15) } function v (t, e) { return e === 'top' ? [t.top, 1] : e === 'bottom' ? [t.bottom, 0] : e === 'right' ? [1, t.right] : e === 'left' ? [0, t.left] : void 0 } function _ (t, e, n) { if (n = n || {}, !s.isObject(n)) throw new Error('options is invalid'); const r = n.zProperty || 'elevation'; const a = n.commonProperties || {}; const u = n.breaksProperties || []; if (o.collectionOf(t, 'Point', 'Input must contain Points'), !e) throw new Error('breaks is required'); if (!Array.isArray(e)) throw new Error('breaks must be an Array'); if (!s.isObject(a)) throw new Error('commonProperties must be an Object'); if (!Array.isArray(u)) throw new Error('breaksProperties must be an Array'); const f = (function (t, e) { if (e = e || {}, !s.isObject(e)) throw new Error('options is invalid'); const n = e.zProperty || 'elevation'; const r = e.flip; const a = e.flags; o.collectionOf(t, 'Point', 'input must contain Points'); for (var u = (function (t, e) { const n = {}; return i.featureEach(t, function (t) { const e = o.getCoords(t)[1]; n[e] || (n[e] = []), n[e].push(t) }), Object.keys(n).map(function (t) { return n[t].sort(function (t, e) { return o.getCoords(t)[0] - o.getCoords(e)[0] }) }).sort(function (t, n) { return e ? o.getCoords(t[0])[1] - o.getCoords(n[0])[1] : o.getCoords(n[0])[1] - o.getCoords(t[0])[1] }) }(t, r)), l = [], c = 0; c < u.length; c++) { for (var f = u[c], h = [], p = 0; p < f.length; p++) { const g = f[p]; g.properties[n] ? h.push(g.properties[n]) : h.push(0), !0 === a && (g.properties.matrixPosition = [c, p]) }l.push(h) } return l }(t, { zProperty: r, flip: !0 })); const h = (function (t, e, n, r, i) { for (var o = [], a = 1; a < e.length; a++) { const u = +e[a]; const l = c.default({}, r, i[a]); l[n] = u; const f = s.multiLineString(p(t, u), l); o.push(f) } return o }(f, e, r, a, u)); const g = (function (t, e, n) { const r = l.default(n); const o = r[2] - r[0]; const s = r[3] - r[1]; const a = r[0]; const u = r[1]; const c = e[0].length - 1; const f = e.length - 1; const h = o / c; const p = s / f; const g = function (t) { t[0] = t[0] * h + a, t[1] = t[1] * p + u }; return t.forEach(function (t) { i.coordEach(t, g) }), t }(h, f, t)); return s.featureCollection(g) }t.exports = _, t.exports.default = _ }, 1641: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); e.default = function (t) { let e; let n; const i = { type: 'FeatureCollection', features: [] }; if ((n = t.type === 'Feature' ? t.geometry : t).type === 'LineString')e = [n.coordinates]; else if (n.type === 'MultiLineString')e = n.coordinates; else if (n.type === 'MultiPolygon')e = [].concat.apply([], n.coordinates); else { if (n.type !== 'Polygon') throw new Error('Input must be a LineString, MultiLineString, Polygon, or MultiPolygon Feature or Geometry'); e = n.coordinates } return e.forEach(function (t) { e.forEach(function (e) { for (let n = 0; n < t.length - 1; n++) for (let o = n; o < e.length - 1; o++) { if (t === e) { if (Math.abs(n - o) === 1) continue; if (n === 0 && o === t.length - 2 && t[n][0] === t[t.length - 1][0] && t[n][1] === t[t.length - 1][1]) continue } const s = (a = t[n][0], u = t[n][1], l = t[n + 1][0], c = t[n + 1][1], f = e[o][0], h = e[o][1], p = e[o + 1][0], g = e[o + 1][1], d = void 0, y = void 0, v = void 0, _ = void 0, m = void 0, m = { x: null, y: null, onLine1: !1, onLine2: !1 }, (d = (g - h) * (l - a) - (p - f) * (c - u)) == 0 ? m.x !== null && m.y !== null && m : (_ = (l - a) * (y = u - h) - (c - u) * (v = a - f), y = ((p - f) * y - (g - h) * v) / d, v = _ / d, m.x = a + y * (l - a), m.y = u + y * (c - u), y >= 0 && y <= 1 && (m.onLine1 = !0), v >= 0 && v <= 1 && (m.onLine2 = !0), !(!m.onLine1 || !m.onLine2) && [m.x, m.y])); s && i.features.push(r.point([s[0], s[1]])) } let a, u, l, c, f, h, p, g, d, y, v, _, m }) }), i } }, 91: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1013)); const o = n(1540); e.default = function (t, e) { return void 0 === e && (e = {}), o.segmentReduce(t, function (t, n) { const r = n.geometry.coordinates; return t + i.default(r[0], r[1], e) }, 0) } }, 7272: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(265)); const o = r(n(3737)); const s = n(4102); function a (t) { let e = t % 360; return e < 0 && (e += 360), e }e.default = function (t, e, n, r, u) { void 0 === u && (u = {}); const l = u.steps || 64; const c = a(n); const f = a(r); const h = Array.isArray(t) || t.type !== 'Feature' ? {} : t.properties; if (c === f) return s.lineString(i.default(t, e, u).geometry.coordinates[0], h); for (var p = c, g = c < f ? f : f + 360, d = p, y = [], v = 0; d < g;)y.push(o.default(t, e, d, u).geometry.coordinates), d = p + 360 * ++v / l; return d > g && y.push(o.default(t, e, g, u).geometry.coordinates), s.lineString(y, h) } }, 9632: (t, e, n) => { 'use strict'; const r = n(91); const i = n(1378); const o = n(1540); const s = n(4102); function a (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const u = a(r); const l = a(i); function c (t, e, n) { if (n = n || {}, !s.isObject(n)) throw new Error('options is invalid'); const r = n.units; const i = n.reverse; if (!t) throw new Error('geojson is required'); if (e <= 0) throw new Error('segmentLength must be greater than 0'); const a = []; return o.flattenEach(t, function (t) { i && (t.geometry.coordinates = t.geometry.coordinates.reverse()), (function (t, e, n, r) { const i = u.default(t, { units: n }); if (i <= e) return r(t); let o = i / e; Number.isInteger(o) || (o = Math.floor(o) + 1); for (let s = 0; s < o; s++)r(l.default(t, e * s, e * (s + 1), { units: n })) }(t, e, r, function (t) { a.push(t) })) }), s.featureCollection(a) }t.exports = c, t.exports.default = c }, 3663: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4102); const o = n(611); const s = r(n(4590)); const a = n(1540); const u = r(n(1787)); function l (t, e) { const n = o.getCoords(t); const r = o.getCoords(e); if (n.length !== 2) throw new Error('<intersects> line1 must only contain 2 coordinates'); if (r.length !== 2) throw new Error('<intersects> line2 must only contain 2 coordinates'); const s = n[0][0]; const a = n[0][1]; const u = n[1][0]; const l = n[1][1]; const c = r[0][0]; const f = r[0][1]; const h = r[1][0]; const p = r[1][1]; const g = (p - f) * (u - s) - (h - c) * (l - a); if (g === 0) return null; const d = ((h - c) * (a - f) - (p - f) * (s - c)) / g; const y = ((u - s) * (a - f) - (l - a) * (s - c)) / g; if (d >= 0 && d <= 1 && y >= 0 && y <= 1) { const v = s + d * (u - s); const _ = a + d * (l - a); return i.point([v, _]) } return null }e.default = function (t, e) { const n = {}; const r = []; if (t.type === 'LineString' && (t = i.feature(t)), e.type === 'LineString' && (e = i.feature(e)), t.type === 'Feature' && e.type === 'Feature' && t.geometry !== null && e.geometry !== null && t.geometry.type === 'LineString' && e.geometry.type === 'LineString' && t.geometry.coordinates.length === 2 && e.geometry.coordinates.length === 2) { const c = l(t, e); return c && r.push(c), i.featureCollection(r) } const f = u.default(); return f.load(s.default(e)), a.featureEach(s.default(t), function (t) { a.featureEach(f.search(t), function (e) { const i = l(t, e); if (i) { const s = o.getCoords(i).join(','); n[s] || (n[s] = !0, r.push(i)) } }) }), i.featureCollection(r) } }, 5668: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(611); const o = n(4102); function s (t) { const e = t[0]; const n = t[1]; return [n[0] - e[0], n[1] - e[1]] } function a (t, e) { return t[0] * e[1] - e[0] * t[1] } function u (t, e, n) { if (n = n || {}, !o.isObject(n)) throw new Error('options is invalid'); const s = n.units; if (!t) throw new Error('geojson is required'); if (e == null || isNaN(e)) throw new Error('distance is required'); const a = i.getType(t); const u = t.properties; switch (a) { case 'LineString':return l(t, e, s); case 'MultiLineString':var c = []; return r.flattenEach(t, function (t) { c.push(l(t, e, s).geometry.coordinates) }), o.multiLineString(c, u); default:throw new Error('geometry ' + a + ' is not supported') } } function l (t, e, n) { const r = []; const u = o.lengthToDegrees(e, n); const l = i.getCoords(t); const c = []; return l.forEach(function (t, e) { if (e !== l.length - 1) { const n = (p = t, g = l[e + 1], d = u, y = Math.sqrt((p[0] - g[0]) * (p[0] - g[0]) + (p[1] - g[1]) * (p[1] - g[1])), v = p[0] + d * (g[1] - p[1]) / y, _ = g[0] + d * (g[1] - p[1]) / y, [[v, p[1] + d * (p[0] - g[0]) / y], [_, g[1] + d * (p[0] - g[0]) / y]]); if (r.push(n), e > 0) { const i = r[e - 1]; const o = !(function (t, e) { return a(s(t), s(e)) === 0 }(f = n, h = i)) && (function (t, e) { let n; let r; const i = t[0]; const o = s(t); const u = e[0]; const l = s(e); const c = a(o, l); const f = (function (t, e) { return [t[0] + e[0], t[1] + e[1]] }(i, (function (t, e) { return [t * e[0], t * e[1]] }(a((r = i, [(n = u)[0] - r[0], n[1] - r[1]]), l) / c, o)))); return f }(f, h)); !1 !== o && (i[1] = o, n[0] = o), c.push(i[0]), e === l.length - 2 && (c.push(n[0]), c.push(n[1])) }l.length === 2 && (c.push(n[0]), c.push(n[1])) } let f, h, p, g, d, y, v, _ }), o.lineString(c, t.properties) }t.exports = u, t.exports.default = u }, 273: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1787)); const o = r(n(4590)); const s = r(n(3807)); const a = r(n(2793)); const u = n(611); const l = n(1540); const c = n(4102); const f = r(n(251)); function h (t, e) { const n = u.getCoords(e); const r = u.getCoords(t); const i = r[0]; const o = r[r.length - 1]; const s = t.geometry.coordinates; return f.default(n[0], i) ? s.unshift(n[1]) : f.default(n[0], o) ? s.push(n[1]) : f.default(n[1], i) ? s.unshift(n[0]) : f.default(n[1], o) && s.push(n[0]), t }e.default = function (t, e, n) { if (void 0 === n && (n = {}), n = n || {}, !c.isObject(n)) throw new Error('options is invalid'); let r; const p = n.tolerance || 0; const g = []; const d = i.default(); const y = o.default(t); return d.load(y), l.segmentEach(e, function (t) { let e = !1; t && (l.featureEach(d.search(t), function (n) { if (!1 === e) { const i = u.getCoords(t).sort(); const o = u.getCoords(n).sort(); f.default(i, o) || (p === 0 ? a.default(i[0], n) && a.default(i[1], n) : s.default(n, i[0]).properties.dist <= p && s.default(n, i[1]).properties.dist <= p) ? (e = !0, r = r ? h(r, t) : t) : (p === 0 ? a.default(o[0], t) && a.default(o[1], t) : s.default(t, o[0]).properties.dist <= p && s.default(t, o[1]).properties.dist <= p) && (r = r ? h(r, n) : n) } }), !1 === e && r && (g.push(r), r = void 0)) }), r && g.push(r), c.featureCollection(g) } }, 4590: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); const o = n(1540); e.default = function (t) { if (!t) throw new Error('geojson is required'); const e = []; return o.flattenEach(t, function (t) { !(function (t, e) { let n = []; const o = t.geometry; if (o !== null) { switch (o.type) { case 'Polygon':n = i.getCoords(o); break; case 'LineString':n = [i.getCoords(o)] }n.forEach(function (n) { const i = (function (t, e) { const n = []; return t.reduce(function (t, i) { let o; let s; let a; let u; let l; let c; const f = r.lineString([t, i], e); return f.bbox = (s = i, a = (o = t)[0], u = o[1], [a < (l = s[0]) ? a : l, u < (c = s[1]) ? u : c, a > l ? a : l, u > c ? u : c]), n.push(f), i }), n }(n, t.properties)); i.forEach(function (t) { t.id = e.length, e.push(t) }) }) } }(t, e)) }), r.featureCollection(e) } }, 1378: (t, e, n) => { 'use strict'; const r = n(1208); const i = n(1013); const o = n(3737); const s = n(4102); function a (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const u = a(r); const l = a(i); const c = a(o); function f (t, e, n, r) { if (r = r || {}, !s.isObject(r)) throw new Error('options is invalid'); let i; const o = []; if (t.type === 'Feature')i = t.geometry.coordinates; else { if (t.type !== 'LineString') throw new Error('input must be a LineString Feature or Geometry'); i = t.coordinates } for (var a, f, h, p = i.length, g = 0, d = 0; d < i.length && !(e >= g && d === i.length - 1); d++) { if (g > e && o.length === 0) { if (!(a = e - g)) return o.push(i[d]), s.lineString(o); f = u.default(i[d], i[d - 1]) - 180, h = c.default(i[d], a, f, r), o.push(h.geometry.coordinates) } if (g >= n) return (a = n - g) ? (f = u.default(i[d], i[d - 1]) - 180, h = c.default(i[d], a, f, r), o.push(h.geometry.coordinates), s.lineString(o)) : (o.push(i[d]), s.lineString(o)); if (g >= e && o.push(i[d]), d === i.length - 1) return s.lineString(o); g += l.default(i[d], i[d + 1], r) } if (g < e && i.length === p) throw new Error('Start position is beyond line'); const y = i[i.length - 1]; return s.lineString([y, y]) }t.exports = f, t.exports.default = f }, 4792: (t, e, n) => { 'use strict'; const r = n(611); const i = n(4102); function o (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const s = o(n(3807)); function a (t, e, n) { const o = r.getCoords(n); if (r.getType(n) !== 'LineString') throw new Error('line must be a LineString'); for (var a, u = s.default(n, t), l = s.default(n, e), c = [(a = u.properties.index <= l.properties.index ? [u, l] : [l, u])[0].geometry.coordinates], f = a[0].properties.index + 1; f < a[1].properties.index + 1; f++)c.push(o[f]); return c.push(a[1].geometry.coordinates), i.lineString(c, n.properties) }t.exports = a, t.exports.default = a }, 7477: (t, e, n) => { 'use strict'; const r = n(1787); const i = n(5077); const o = n(9705); const s = n(5608); const a = n(4590); const u = n(3663); const l = n(3807); const c = n(611); const f = n(1540); const h = n(4102); function p (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const g = p(r); const d = p(i); const y = p(o); const v = p(s); const _ = p(a); const m = p(u); const x = p(l); function b (t, e) { if (!t) throw new Error('line is required'); if (!e) throw new Error('splitter is required'); const n = c.getType(t); const r = c.getType(e); if (n !== 'LineString') throw new Error('line must be LineString'); if (r === 'FeatureCollection') throw new Error('splitter cannot be a FeatureCollection'); if (r === 'GeometryCollection') throw new Error('splitter cannot be a GeometryCollection'); const i = v.default(e, { precision: 7 }); switch (r) { case 'Point':return w(t, i); case 'MultiPoint':return E(t, i); case 'LineString':case 'MultiLineString':case 'Polygon':case 'MultiPolygon':return E(t, m.default(t, i)) } } function E (t, e) { let n = []; const r = g.default(); return f.flattenEach(e, function (e) { if (n.forEach(function (t, e) { t.id = e }), n.length) { const i = r.search(e); if (i.features.length) { const o = I(e, i); n = n.filter(function (t) { return t.id !== o.id }), r.remove(o), f.featureEach(w(o, e), function (t) { n.push(t), r.insert(t) }) } } else (n = w(t, e).features).forEach(function (t) { t.bbox || (t.bbox = d.default(y.default(t))) }), r.load(h.featureCollection(n)) }), h.featureCollection(n) } function w (t, e) { const n = []; const r = c.getCoords(t)[0]; const i = c.getCoords(t)[t.geometry.coordinates.length - 1]; if (S(r, c.getCoord(e)) || S(i, c.getCoord(e))) return h.featureCollection([t]); const o = g.default(); const s = _.default(t); o.load(s); const a = o.search(e); if (!a.features.length) return h.featureCollection([t]); const u = I(e, a); const l = [r]; const p = f.featureReduce(s, function (t, r, i) { const o = c.getCoords(r)[1]; const s = c.getCoord(e); return i === u.id ? (t.push(s), n.push(h.lineString(t)), S(s, o) ? [s] : [s, o]) : (t.push(o), t) }, l); return p.length > 1 && n.push(h.lineString(p)), h.featureCollection(n) } function I (t, e) { if (!e.features.length) throw new Error('lines must contain features'); if (e.features.length === 1) return e.features[0]; let n; let r = 1 / 0; return f.featureEach(e, function (e) { const i = x.default(e, t).properties.dist; i < r && (n = e, r = i) }), n } function S (t, e) { return t[0] === e[0] && t[1] === e[1] }t.exports = b, t.exports.default = b }, 1933: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(9705)); const o = n(611); const s = n(4102); const a = r(n(6565)); function u (t, e, n, r) { e = e || (t.type === 'Feature' ? t.properties : {}); const a = o.getGeom(t); let u = a.coordinates; const c = a.type; if (!u.length) throw new Error('line must contain coordinates'); switch (c) { case 'LineString':return n && (u = l(u)), s.polygon([u], e); case 'MultiLineString':var f = []; var h = 0; return u.forEach(function (t) { if (n && (t = l(t)), r) { const e = (a = (o = i.default(s.lineString(t)))[0], u = o[1], c = o[2], p = o[3], Math.abs(a - c) * Math.abs(u - p)); e > h ? (f.unshift(t), h = e) : f.push(t) } else f.push(t); let o, a, u, c, p }), s.polygon(f, e); default:throw new Error('geometry type ' + c + ' is not supported') } } function l (t) { const e = t[0]; const n = e[0]; const r = e[1]; const i = t[t.length - 1]; const o = i[0]; const s = i[1]; return n === o && r === s || t.push(e), t }e.default = function (t, e) { let n, r, i; void 0 === e && (e = {}); const l = e.properties; const c = (n = e.autoComplete) === null || void 0 === n || n; const f = (r = e.orderCoords) === null || void 0 === r || r; if ((i = e.mutate) !== null && void 0 !== i && i || (t = a.default(t)), t.type === 'FeatureCollection') { const h = []; return t.features.forEach(function (t) { h.push(o.getCoords(u(t, {}, c, f))) }), s.multiPolygon(h, l) } return u(t, l, c, f) } }, 482: (t, e, n) => { 'use strict'; const r = n(4102); function i (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const o = i(n(2676)); function s (t, e) { let n; const i = (function (t) { const e = t && t.geometry.coordinates || [[[180, 90], [-180, 90], [-180, -90], [180, -90], [180, 90]]]; return r.polygon(e) }(e)); return (t.type === 'FeatureCollection' ? a((n = t).features.length === 2 ? o.default.union(n.features[0].geometry.coordinates, n.features[1].geometry.coordinates) : o.default.union.apply(o.default, n.features.map(function (t) { return t.geometry.coordinates }))) : a(o.default.union(t.geometry.coordinates))).geometry.coordinates.forEach(function (t) { i.geometry.coordinates.push(t[0]) }), i } function a (t) { return r.multiPolygon(t) }t.exports = s, t.exports.default = s }, 1540: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); function i (t, e, n) { if (t !== null) for (var r, o, s, a, u, l, c, f, h = 0, p = 0, g = t.type, d = g === 'FeatureCollection', y = g === 'Feature', v = d ? t.features.length : 1, _ = 0; _ < v; _++) { u = (f = !!(c = d ? t.features[_].geometry : y ? t.geometry : t) && c.type === 'GeometryCollection') ? c.geometries.length : 1; for (let m = 0; m < u; m++) { let x = 0; let b = 0; if ((a = f ? c.geometries[m] : c) !== null) { l = a.coordinates; const E = a.type; switch (h = !n || E !== 'Polygon' && E !== 'MultiPolygon' ? 0 : 1, E) { case null:break; case 'Point':if (!1 === e(l, p, _, x, b)) return !1; p++, x++; break; case 'LineString':case 'MultiPoint':for (r = 0; r < l.length; r++) { if (!1 === e(l[r], p, _, x, b)) return !1; p++, E === 'MultiPoint' && x++ }E === 'LineString' && x++; break; case 'Polygon':case 'MultiLineString':for (r = 0; r < l.length; r++) { for (o = 0; o < l[r].length - h; o++) { if (!1 === e(l[r][o], p, _, x, b)) return !1; p++ }E === 'MultiLineString' && x++, E === 'Polygon' && b++ }E === 'Polygon' && x++; break; case 'MultiPolygon':for (r = 0; r < l.length; r++) { for (b = 0, o = 0; o < l[r].length; o++) { for (s = 0; s < l[r][o].length - h; s++) { if (!1 === e(l[r][o][s], p, _, x, b)) return !1; p++ }b++ }x++ } break; case 'GeometryCollection':for (r = 0; r < a.geometries.length; r++) if (!1 === i(a.geometries[r], e, n)) return !1; break; default:throw new Error('Unknown Geometry Type') } } } } } function o (t, e) { let n; switch (t.type) { case 'FeatureCollection':for (n = 0; n < t.features.length && !1 !== e(t.features[n].properties, n); n++);break; case 'Feature':e(t.properties, 0) } } function s (t, e) { if (t.type === 'Feature')e(t, 0); else if (t.type === 'FeatureCollection') for (let n = 0; n < t.features.length && !1 !== e(t.features[n], n); n++); } function a (t, e) { let n; let r; let i; let o; let s; let a; let u; let l; let c; let f; let h = 0; const p = t.type === 'FeatureCollection'; const g = t.type === 'Feature'; const d = p ? t.features.length : 1; for (n = 0; n < d; n++) { for (a = p ? t.features[n].geometry : g ? t.geometry : t, l = p ? t.features[n].properties : g ? t.properties : {}, c = p ? t.features[n].bbox : g ? t.bbox : void 0, f = p ? t.features[n].id : g ? t.id : void 0, s = (u = !!a && a.type === 'GeometryCollection') ? a.geometries.length : 1, i = 0; i < s; i++) if ((o = u ? a.geometries[i] : a) !== null) switch (o.type) { case 'Point':case 'LineString':case 'MultiPoint':case 'Polygon':case 'MultiLineString':case 'MultiPolygon':if (!1 === e(o, h, l, c, f)) return !1; break; case 'GeometryCollection':for (r = 0; r < o.geometries.length; r++) if (!1 === e(o.geometries[r], h, l, c, f)) return !1; break; default:throw new Error('Unknown Geometry Type') } else if (!1 === e(null, h, l, c, f)) return !1; h++ } } function u (t, e) { a(t, function (t, n, i, o, s) { let a; const u = t === null ? null : t.type; switch (u) { case null:case 'Point':case 'LineString':case 'Polygon':return !1 !== e(r.feature(t, i, { bbox: o, id: s }), n, 0) && void 0 } switch (u) { case 'MultiPoint':a = 'Point'; break; case 'MultiLineString':a = 'LineString'; break; case 'MultiPolygon':a = 'Polygon' } for (let l = 0; l < t.coordinates.length; l++) { const c = { type: a, coordinates: t.coordinates[l] }; if (!1 === e(r.feature(c, i), n, l)) return !1 } }) } function l (t, e) { u(t, function (t, n, o) { let s = 0; if (t.geometry) { const a = t.geometry.type; if (a !== 'Point' && a !== 'MultiPoint') { let u; let l = 0; let c = 0; let f = 0; return !1 !== i(t, function (i, a, h, p, g) { if (void 0 === u || n > l || p > c || g > f) return u = i, l = n, c = p, f = g, void (s = 0); const d = r.lineString([u, i], t.properties); if (!1 === e(d, n, o, g, s)) return !1; s++, u = i }) && void 0 } } }) } function c (t, e) { if (!t) throw new Error('geojson is required'); u(t, function (t, n, i) { if (t.geometry !== null) { const o = t.geometry.type; const s = t.geometry.coordinates; switch (o) { case 'LineString':if (!1 === e(t, n, i, 0, 0)) return !1; break; case 'Polygon':for (let a = 0; a < s.length; a++) if (!1 === e(r.lineString(s[a], t.properties), n, i, a)) return !1 } } }) }e.coordAll = function (t) { const e = []; return i(t, function (t) { e.push(t) }), e }, e.coordEach = i, e.coordReduce = function (t, e, n, r) { let o = n; return i(t, function (t, r, i, s, a) { o = r === 0 && void 0 === n ? t : e(o, t, r, i, s, a) }, r), o }, e.featureEach = s, e.featureReduce = function (t, e, n) { let r = n; return s(t, function (t, i) { r = i === 0 && void 0 === n ? t : e(r, t, i) }), r }, e.findPoint = function (t, e) { if (e = e || {}, !r.isObject(e)) throw new Error('options is invalid'); let n; let i = e.featureIndex || 0; let o = e.multiFeatureIndex || 0; let s = e.geometryIndex || 0; let a = e.coordIndex || 0; let u = e.properties; switch (t.type) { case 'FeatureCollection':i < 0 && (i = t.features.length + i), u = u || t.features[i].properties, n = t.features[i].geometry; break; case 'Feature':u = u || t.properties, n = t.geometry; break; case 'Point':case 'MultiPoint':return null; case 'LineString':case 'Polygon':case 'MultiLineString':case 'MultiPolygon':n = t; break; default:throw new Error('geojson is invalid') } if (n === null) return null; const l = n.coordinates; switch (n.type) { case 'Point':return r.point(l, u, e); case 'MultiPoint':return o < 0 && (o = l.length + o), r.point(l[o], u, e); case 'LineString':return a < 0 && (a = l.length + a), r.point(l[a], u, e); case 'Polygon':return s < 0 && (s = l.length + s), a < 0 && (a = l[s].length + a), r.point(l[s][a], u, e); case 'MultiLineString':return o < 0 && (o = l.length + o), a < 0 && (a = l[o].length + a), r.point(l[o][a], u, e); case 'MultiPolygon':return o < 0 && (o = l.length + o), s < 0 && (s = l[o].length + s), a < 0 && (a = l[o][s].length - a), r.point(l[o][s][a], u, e) } throw new Error('geojson is invalid') }, e.findSegment = function (t, e) { if (e = e || {}, !r.isObject(e)) throw new Error('options is invalid'); let n; let i = e.featureIndex || 0; let o = e.multiFeatureIndex || 0; let s = e.geometryIndex || 0; let a = e.segmentIndex || 0; let u = e.properties; switch (t.type) { case 'FeatureCollection':i < 0 && (i = t.features.length + i), u = u || t.features[i].properties, n = t.features[i].geometry; break; case 'Feature':u = u || t.properties, n = t.geometry; break; case 'Point':case 'MultiPoint':return null; case 'LineString':case 'Polygon':case 'MultiLineString':case 'MultiPolygon':n = t; break; default:throw new Error('geojson is invalid') } if (n === null) return null; const l = n.coordinates; switch (n.type) { case 'Point':case 'MultiPoint':return null; case 'LineString':return a < 0 && (a = l.length + a - 1), r.lineString([l[a], l[a + 1]], u, e); case 'Polygon':return s < 0 && (s = l.length + s), a < 0 && (a = l[s].length + a - 1), r.lineString([l[s][a], l[s][a + 1]], u, e); case 'MultiLineString':return o < 0 && (o = l.length + o), a < 0 && (a = l[o].length + a - 1), r.lineString([l[o][a], l[o][a + 1]], u, e); case 'MultiPolygon':return o < 0 && (o = l.length + o), s < 0 && (s = l[o].length + s), a < 0 && (a = l[o][s].length - a - 1), r.lineString([l[o][s][a], l[o][s][a + 1]], u, e) } throw new Error('geojson is invalid') }, e.flattenEach = u, e.flattenReduce = function (t, e, n) { let r = n; return u(t, function (t, i, o) { r = i === 0 && o === 0 && void 0 === n ? t : e(r, t, i, o) }), r }, e.geomEach = a, e.geomReduce = function (t, e, n) { let r = n; return a(t, function (t, i, o, s, a) { r = i === 0 && void 0 === n ? t : e(r, t, i, o, s, a) }), r }, e.lineEach = c, e.lineReduce = function (t, e, n) { let r = n; return c(t, function (t, i, o, s) { r = i === 0 && void 0 === n ? t : e(r, t, i, o, s) }), r }, e.propEach = o, e.propReduce = function (t, e, n) { let r = n; return o(t, function (t, i) { r = i === 0 && void 0 === n ? t : e(r, t, i) }), r }, e.segmentEach = l, e.segmentReduce = function (t, e, n) { let r = n; let i = !1; return l(t, function (t, o, s, a, u) { r = !1 === i && void 0 === n ? t : e(r, t, o, s, a, u), i = !0 }), r } }, 9034: (t, e, n) => { 'use strict'; const r = n(1208); const i = n(3737); const o = n(1013); function s (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const a = s(r); const u = s(i); const l = s(o); function c (t, e) { const n = l.default(t, e); const r = a.default(t, e); return u.default(t, n / 2, r) }t.exports = c, t.exports.default = c }, 920: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(5366)); const o = n(1540); function s (t) { for (var e = 0, n = 0, r = t; n < r.length; n++)e += r[n]; return e / t.length }e.default = function (t, e) { const n = e.inputField; const r = e.threshold || 1e5; const a = e.p || 2; const u = e.binary || !1; const l = e.alpha || -1; const c = e.standardization || !0; const f = i.default(t, { alpha: l, binary: u, p: a, standardization: c, threshold: r }); const h = []; o.featureEach(t, function (t) { const e = t.properties || {}; h.push(e[n]) }); for (var p = s(h), g = (function (t) { for (var e = s(t), n = 0, r = 0, i = t; r < i.length; r++) { const o = i[r]; n += Math.pow(o - e, 2) } return n / t.length }(h)), d = 0, y = 0, v = 0, _ = 0, m = f.length, x = 0; x < m; x++) { for (var b = 0, E = 0; E < m; E++)d += f[x][E] * (h[x] - p) * (h[E] - p), y += f[x][E], v += Math.pow(f[x][E] + f[E][x], 2), b += f[x][E] + f[E][x]; _ += Math.pow(b, 2) } const w = d / y / g; const I = -1 / (m - 1); const S = (m * m * (v *= 0.5) - m * _ + y * y * 3) / ((m - 1) * (m + 1) * (y * y)) - I * I; const N = Math.sqrt(S); return { expectedMoranIndex: I, moranIndex: w, stdNorm: N, zNorm: (w - I) / N } } }, 3807: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1208)); const o = r(n(1013)); const s = r(n(3737)); const a = r(n(3663)); const u = n(1540); const l = n(4102); const c = n(611); e.default = function (t, e, n) { void 0 === n && (n = {}); let r = l.point([1 / 0, 1 / 0], { dist: 1 / 0 }); let f = 0; return u.flattenEach(t, function (t) { for (let u = c.getCoords(t), h = 0; h < u.length - 1; h++) { const p = l.point(u[h]); p.properties.dist = o.default(e, p, n); const g = l.point(u[h + 1]); g.properties.dist = o.default(e, g, n); const d = o.default(p, g, n); const y = Math.max(p.properties.dist, g.properties.dist); const v = i.default(p, g); const _ = s.default(e, y, v + 90, n); const m = s.default(e, y, v - 90, n); const x = a.default(l.lineString([_.geometry.coordinates, m.geometry.coordinates]), l.lineString([p.geometry.coordinates, g.geometry.coordinates])); let b = null; x.features.length > 0 && ((b = x.features[0]).properties.dist = o.default(e, b, n), b.properties.location = f + o.default(p, b, n)), p.properties.dist < r.properties.dist && ((r = p).properties.index = h, r.properties.location = f), g.properties.dist < r.properties.dist && ((r = g).properties.index = h + 1, r.properties.location = f + d), b && b.properties.dist < r.properties.dist && ((r = b).properties.index = h), f += d } }), r } }, 2059: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(611); const o = n(1540); const s = r(n(3892)); const a = r(n(7418)); e.default = function (t, e, n) { void 0 === n && (n = {}); const r = n.units; const u = n.properties || {}; const l = (function (t) { const e = []; switch (t.geometry ? t.geometry.type : t.type) { case 'GeometryCollection':return o.geomEach(t, function (t) { t.type === 'Point' && e.push({ type: 'Feature', properties: {}, geometry: t }) }), { type: 'FeatureCollection', features: e }; case 'FeatureCollection':return t.features = t.features.filter(function (t) { return t.geometry.type === 'Point' }), t; default:throw new Error('points must be a Point Collection') } }(t)); if (!l.features.length) throw new Error('points must contain features'); if (!e) throw new Error('line is required'); if (i.getType(e) !== 'LineString') throw new Error('line must be a LineString'); let c = 1 / 0; let f = null; return o.featureEach(l, function (t) { const n = s.default(t, e, { units: r }); n < c && (c = n, f = t) }), f && (f.properties = a.default({ dist: c }, f.properties, u)), f } }, 6379: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(6565)); const o = r(n(1013)); const s = n(1540); e.default = function (t, e) { if (!t) throw new Error('targetPoint is required'); if (!e) throw new Error('points is required'); let n; let r = 1 / 0; let a = 0; return s.featureEach(e, function (e, n) { const i = o.default(t, e); i < r && (a = n, r = i) }), (n = i.default(e.features[a])).properties.featureIndex = a, n.properties.distanceToPoint = r, n } }, 3377: (t, e, n) => { 'use strict'; const r = n(611); function i (t, e) { const n = r.getCoord(t); const i = r.getGeom(e).coordinates[0]; if (i.length < 4) throw new Error('OuterRing of a Polygon must have 4 or more Positions.'); const o = e.properties || {}; const s = o.a; const a = o.b; const u = o.c; const l = n[0]; const c = n[1]; const f = i[0][0]; const h = i[0][1]; const p = void 0 !== s ? s : i[0][2]; const g = i[1][0]; const d = i[1][1]; const y = void 0 !== a ? a : i[1][2]; const v = i[2][0]; const _ = i[2][1]; const m = void 0 !== u ? u : i[2][2]; return (m * (l - f) * (c - d) + p * (l - g) * (c - _) + y * (l - v) * (c - h) - y * (l - f) * (c - _) - m * (l - g) * (c - h) - p * (l - v) * (c - d)) / ((l - f) * (c - d) + (l - g) * (c - _) + (l - v) * (c - h) - (l - f) * (c - _) - (l - g) * (c - h) - (l - v) * (c - d)) }t.exports = i, t.exports.default = i }, 6813: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(5184)); const o = r(n(1013)); const s = n(4102); e.default = function (t, e, n) { void 0 === n && (n = {}), n.mask && !n.units && (n.units = 'kilometers'); for (var r = [], a = t[0], u = t[1], l = t[2], c = t[3], f = e / o.default([a, u], [l, u], n) * (l - a), h = e / o.default([a, u], [a, c], n) * (c - u), p = l - a, g = c - u, d = Math.floor(p / f), y = (g - Math.floor(g / h) * h) / 2, v = a + (p - d * f) / 2; v <= l;) { for (let _ = u + y; _ <= c;) { const m = s.point([v, _], n.properties); n.mask ? i.default(m, n.mask) && r.push(m) : r.push(m), _ += h }v += f } return s.featureCollection(r) } }, 5771: (t, e, n) => { 'use strict'; const r = n(3922); const i = n(8230); const o = n(6379); const s = n(8147); const a = n(4102); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(r); const c = u(i); const f = u(o); const h = u(s); function p (t) { for (var e = (function (t) { return t.type !== 'FeatureCollection' ? t.type !== 'Feature' ? a.featureCollection([a.feature(t)]) : a.featureCollection([t]) : t }(t)), n = c.default(e), r = !1, i = 0; !r && i < e.features.length;) { var o; const s = e.features[i].geometry; let u = !1; if (s.type === 'Point')n.geometry.coordinates[0] === s.coordinates[0] && n.geometry.coordinates[1] === s.coordinates[1] && (r = !0); else if (s.type === 'MultiPoint') { let p = !1; for (o = 0; !p && o < s.coordinates.length;)n.geometry.coordinates[0] === s.coordinates[o][0] && n.geometry.coordinates[1] === s.coordinates[o][1] && (r = !0, p = !0), o++ } else if (s.type === 'LineString') for (o = 0; !u && o < s.coordinates.length - 1;)g(n.geometry.coordinates[0], n.geometry.coordinates[1], s.coordinates[o][0], s.coordinates[o][1], s.coordinates[o + 1][0], s.coordinates[o + 1][1]) && (u = !0, r = !0), o++; else if (s.type === 'MultiLineString') for (let d = 0; d < s.coordinates.length;) { u = !1, o = 0; for (let y = s.coordinates[d]; !u && o < y.length - 1;)g(n.geometry.coordinates[0], n.geometry.coordinates[1], y[o][0], y[o][1], y[o + 1][0], y[o + 1][1]) && (u = !0, r = !0), o++; d++ } else s.type !== 'Polygon' && s.type !== 'MultiPolygon' || h.default(n, s) && (r = !0); i++ } if (r) return n; const v = a.featureCollection([]); for (i = 0; i < e.features.length; i++)v.features = v.features.concat(l.default(e.features[i]).features); return a.point(f.default(n, v).geometry.coordinates) } function g (t, e, n, r, i, o) { return Math.sqrt((i - n) * (i - n) + (o - r) * (o - r)) === Math.sqrt((t - n) * (t - n) + (e - r) * (e - r)) + Math.sqrt((i - t) * (i - t) + (o - e) * (o - e)) }t.exports = p, t.exports.default = p }, 3892: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1013)); const o = n(4102); const s = n(611); const a = n(1540); const u = r(n(6213)); function l (t, e) { return t[0] * e[0] + t[1] * e[1] } function c (t, e, n) { return n.method === 'planar' ? u.default(t, e, n) : i.default(t, e, n) }e.default = function (t, e, n) { if (void 0 === n && (n = {}), n.method || (n.method = 'geodesic'), n.units || (n.units = 'kilometers'), !t) throw new Error('pt is required'); if (Array.isArray(t) ? t = o.point(t) : t.type === 'Point' ? t = o.feature(t) : s.featureOf(t, 'Point', 'point'), !e) throw new Error('line is required'); Array.isArray(e) ? e = o.lineString(e) : e.type === 'LineString' ? e = o.feature(e) : s.featureOf(e, 'LineString', 'line'); let r = 1 / 0; const i = t.geometry.coordinates; return a.segmentEach(e, function (t) { const e = t.geometry.coordinates[0]; const o = t.geometry.coordinates[1]; const s = (function (t, e, n, r) { const i = [n[0] - e[0], n[1] - e[1]]; const o = l([t[0] - e[0], t[1] - e[1]], i); if (o <= 0) return c(t, e, { method: r.method, units: 'degrees' }); const s = l(i, i); if (s <= o) return c(t, n, { method: r.method, units: 'degrees' }); const a = o / s; return c(t, [e[0] + a * i[0], e[1] + a * i[1]], { method: r.method, units: 'degrees' }) }(i, e, o, n)); s < r && (r = s) }), o.convertLength(r, 'degrees', n.units) } }, 187: (t, e, n) => { 'use strict'; const r = n(8147); const i = n(4102); const o = n(1540); function s (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const a = s(r); function u (t, e) { const n = []; return o.featureEach(t, function (t) { let r = !1; if (t.geometry.type === 'Point')o.geomEach(e, function (e) { a.default(t, e) && (r = !0) }), r && n.push(t); else { if (t.geometry.type !== 'MultiPoint') throw new Error('Input geometry must be a Point or MultiPoint'); const s = []; o.geomEach(e, function (e) { o.coordEach(t, function (t) { a.default(t, e) && (r = !0, s.push(t)) }) }), r && n.push(i.multiPoint(s)) } }), i.featureCollection(n) }t.exports = u, t.exports.default = u }, 4978: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(4102); function o (t, e) { const n = []; const o = e.iterations || 1; if (!t) throw new Error('inputPolys is required'); return r.geomEach(t, function (t, e, r) { let u, l, c; switch (t.type) { case 'Polygon':u = [[]]; for (let f = 0; f < o; f++)c = [[]], l = t, f > 0 && (l = i.polygon(u).geometry), s(l, c), u = c.slice(0); n.push(i.polygon(u, r)); break; case 'MultiPolygon':u = [[[]]]; for (let h = 0; h < o; h++)c = [[[]]], l = t, h > 0 && (l = i.multiPolygon(u).geometry), a(l, c), u = c.slice(0); n.push(i.multiPolygon(u, r)); break; default:throw new Error('geometry is invalid, must be Polygon or MultiPolygon') } }), i.featureCollection(n) } function s (t, e) { let n = 0; let i = 0; r.coordEach(t, function (r, o, s, a, u) { u > n && (n = u, i = o, e.push([])); const l = o - i; const c = t.coordinates[u][l + 1]; const f = r[0]; const h = r[1]; const p = c[0]; const g = c[1]; e[u].push([0.75 * f + 0.25 * p, 0.75 * h + 0.25 * g]), e[u].push([0.25 * f + 0.75 * p, 0.25 * h + 0.75 * g]) }, !0), e.forEach(function (t) { t.push(t[0]) }) } function a (t, e) { let n = 0; let i = 0; let o = 0; r.coordEach(t, function (r, s, a, u, l) { u > o && (o = u, i = s, e.push([[]])), l > n && (n = l, i = s, e[u].push([])); const c = s - i; const f = t.coordinates[u][l][c + 1]; const h = r[0]; const p = r[1]; const g = f[0]; const d = f[1]; e[u][l].push([0.75 * h + 0.25 * g, 0.75 * p + 0.25 * d]), e[u][l].push([0.25 * h + 0.75 * g, 0.25 * p + 0.75 * d]) }, !0), e.forEach(function (t) { t.forEach(function (t) { t.push(t[0]) }) }) }t.exports = o, t.exports.default = o }, 5215: (t, e, n) => { 'use strict'; const r = n(611); const i = n(4102); const o = n(9705); const s = n(3922); const a = n(6379); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(o); const c = u(s); const f = u(a); function h (t, e) { let n; let o; let s; let a; const u = r.getCoords(t); const h = r.getCoords(e); const d = l.default(e); let y = 0; let v = null; switch (u[0] > d[0] && u[0] < d[2] && u[1] > d[1] && u[1] < d[3] && (y = (v = f.default(t, c.default(e))).properties.featureIndex), r.getType(e)) { case 'Polygon':n = h[0][y], o = h[0][0], v !== null && v.geometry.coordinates[1] < u[1] && (o = h[0][y]), a = g(h[0][0], h[0][h[0].length - 1], u); var _ = p(h[0], u, a, s, n, o); n = _[0], o = _[1]; break; case 'MultiPolygon':for (var m = 0, x = 0, b = 0, E = 0; E < h[0].length; E++) { m = E; for (var w = !1, I = 0; I < h[0][E].length; I++) { if (x = I, b === y) { w = !0; break }b++ } if (w) break }n = h[0][m][x], o = h[0][m][x], a = g(h[0][0][0], h[0][0][h[0][0].length - 1], u), h.forEach(function (t) { const e = p(t[0], u, a, s, n, o); n = e[0], o = e[1] }) } return i.featureCollection([i.point(n), i.point(o)]) } function p (t, e, n, r, i, o) { for (let s = 0; s < t.length; s++) { const a = t[s]; let u = t[s + 1]; s === t.length - 1 && (u = t[0]), r = g(a, u, e), n <= 0 && r > 0 ? g(e, a, i) < 0 || (i = a) : n > 0 && r <= 0 && (g(e, a, o) > 0 || (o = a)), n = r } return [i, o] } function g (t, e, n) { return (e[0] - t[0]) * (n[1] - t[1]) - (n[0] - t[0]) * (e[1] - t[1]) }t.exports = h, t.exports.default = h }, 7383: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); function o (t, e) { return void 0 === e && (e = {}), a(i.getGeom(t).coordinates, e.properties ? e.properties : t.type === 'Feature' ? t.properties : {}) } function s (t, e) { void 0 === e && (e = {}); const n = i.getGeom(t).coordinates; const o = e.properties ? e.properties : t.type === 'Feature' ? t.properties : {}; const s = []; return n.forEach(function (t) { s.push(a(t, o)) }), r.featureCollection(s) } function a (t, e) { return t.length > 1 ? r.multiLineString(t, e) : r.lineString(t[0], e) }e.default = function (t, e) { void 0 === e && (e = {}); const n = i.getGeom(t); switch (e.properties || t.type !== 'Feature' || (e.properties = t.properties), n.type) { case 'Polygon':return o(n, e); case 'MultiPolygon':return s(n, e); default:throw new Error('invalid poly') } }, e.polygonToLine = o, e.multiPolygonToLine = s, e.coordsToLine = a }, 4312: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4102); const o = r(n(7254)); const s = r(n(6467)); e.default = function (t) { const e = o.default.fromGeoJson(t); e.deleteDangles(), e.deleteCutEdges(); const n = []; const r = []; return e.getEdgeRings().filter(function (t) { return t.isValid() }).forEach(function (t) { t.isHole() ? n.push(t) : r.push(t) }), n.forEach(function (t) { s.default.findEdgeRingContaining(t, r) && r.push(t) }), i.featureCollection(r.map(function (t) { return t.toPolygon() })) } }, 5344: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(4772); const o = (function () { function t (t, e) { this.from = t, this.to = e, this.next = void 0, this.label = void 0, this.symetric = void 0, this.ring = void 0, this.from.addOuterEdge(this), this.to.addInnerEdge(this) } return t.prototype.getSymetric = function () { return this.symetric || (this.symetric = new t(this.to, this.from), this.symetric.symetric = this), this.symetric }, t.prototype.deleteEdge = function () { this.from.removeOuterEdge(this), this.to.removeInnerEdge(this) }, t.prototype.isEqual = function (t) { return this.from.id === t.from.id && this.to.id === t.to.id }, t.prototype.toString = function () { return 'Edge { ' + this.from.id + ' -> ' + this.to.id + ' }' }, t.prototype.toLineString = function () { return r.lineString([this.from.coordinates, this.to.coordinates]) }, t.prototype.compareTo = function (t) { return i.orientationIndex(t.from.coordinates, t.to.coordinates, this.to.coordinates) }, t }()); e.default = o }, 6467: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4772); const o = n(4102); const s = r(n(9062)); const a = r(n(8147)); const u = (function () { function t () { this.edges = [], this.polygon = void 0, this.envelope = void 0 } return t.prototype.push = function (t) { this.edges.push(t), this.polygon = this.envelope = void 0 }, t.prototype.get = function (t) { return this.edges[t] }, Object.defineProperty(t.prototype, 'length', { get: function () { return this.edges.length }, enumerable: !0, configurable: !0 }), t.prototype.forEach = function (t) { this.edges.forEach(t) }, t.prototype.map = function (t) { return this.edges.map(t) }, t.prototype.some = function (t) { return this.edges.some(t) }, t.prototype.isValid = function () { return !0 }, t.prototype.isHole = function () { const t = this; const e = this.edges.reduce(function (e, n, r) { return n.from.coordinates[1] > t.edges[e].from.coordinates[1] && (e = r), e }, 0); const n = (e === 0 ? this.length : e) - 1; const r = (e + 1) % this.length; const o = i.orientationIndex(this.edges[n].from.coordinates, this.edges[e].from.coordinates, this.edges[r].from.coordinates); return o === 0 ? this.edges[n].from.coordinates[0] > this.edges[r].from.coordinates[0] : o > 0 }, t.prototype.toMultiPoint = function () { return o.multiPoint(this.edges.map(function (t) { return t.from.coordinates })) }, t.prototype.toPolygon = function () { if (this.polygon) return this.polygon; const t = this.edges.map(function (t) { return t.from.coordinates }); return t.push(this.edges[0].from.coordinates), this.polygon = o.polygon([t]) }, t.prototype.getEnvelope = function () { return this.envelope ? this.envelope : this.envelope = s.default(this.toPolygon()) }, t.findEdgeRingContaining = function (t, e) { let n; let r; const s = t.getEnvelope(); return e.forEach(function (e) { const a = e.getEnvelope(); if (r && (n = r.getEnvelope()), !i.envelopeIsEqual(a, s) && i.envelopeContains(a, s)) { for (var u = t.map(function (t) { return t.from.coordinates }), l = void 0, c = function (t) { e.some(function (e) { return i.coordinatesEqual(t, e.from.coordinates) }) || (l = t) }, f = 0, h = u; f < h.length; f++)c(h[f]); l && e.inside(o.point(l)) && (r && !i.envelopeContains(n, a) || (r = e)) } }), r }, t.prototype.inside = function (t) { return a.default(t, this.toPolygon()) }, t }()); e.default = u }, 7254: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(3424)); const o = r(n(5344)); const s = r(n(6467)); const a = n(1540); const u = n(611); const l = (function () { function t () { this.edges = [], this.nodes = {} } return t.fromGeoJson = function (e) { !(function (t) { if (!t) throw new Error('No geojson passed'); if (t.type !== 'FeatureCollection' && t.type !== 'GeometryCollection' && t.type !== 'MultiLineString' && t.type !== 'LineString' && t.type !== 'Feature') throw new Error("Invalid input type '" + t.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature") }(e)); const n = new t(); return a.flattenEach(e, function (t) { u.featureOf(t, 'LineString', 'Graph::fromGeoJson'), a.coordReduce(t, function (t, e) { if (t) { const r = n.getNode(t); const i = n.getNode(e); n.addEdge(r, i) } return e }) }), n }, t.prototype.getNode = function (t) { const e = i.default.buildId(t); let n = this.nodes[e]; return n || (n = this.nodes[e] = new i.default(t)), n }, t.prototype.addEdge = function (t, e) { const n = new o.default(t, e); const r = n.getSymetric(); this.edges.push(n), this.edges.push(r) }, t.prototype.deleteDangles = function () { const t = this; Object.keys(this.nodes).map(function (e) { return t.nodes[e] }).forEach(function (e) { return t._removeIfDangle(e) }) }, t.prototype._removeIfDangle = function (t) { const e = this; if (t.innerEdges.length <= 1) { const n = t.getOuterEdges().map(function (t) { return t.to }); this.removeNode(t), n.forEach(function (t) { return e._removeIfDangle(t) }) } }, t.prototype.deleteCutEdges = function () { const t = this; this._computeNextCWEdges(), this._findLabeledEdgeRings(), this.edges.forEach(function (e) { e.label === e.symetric.label && (t.removeEdge(e.symetric), t.removeEdge(e)) }) }, t.prototype._computeNextCWEdges = function (t) { const e = this; void 0 === t ? Object.keys(this.nodes).forEach(function (t) { return e._computeNextCWEdges(e.nodes[t]) }) : t.getOuterEdges().forEach(function (e, n) { t.getOuterEdge((n === 0 ? t.getOuterEdges().length : n) - 1).symetric.next = e }) }, t.prototype._computeNextCCWEdges = function (t, e) { for (var n, r, i = t.getOuterEdges(), o = i.length - 1; o >= 0; --o) { const s = i[o]; const a = s.symetric; let u = void 0; let l = void 0; s.label === e && (u = s), a.label === e && (l = a), u && l && (l && (r = l), u && (r && (r.next = u, r = void 0), n || (n = u))) }r && (r.next = n) }, t.prototype._findLabeledEdgeRings = function () { const t = []; let e = 0; return this.edges.forEach(function (n) { if (!(n.label >= 0)) { t.push(n); let r = n; do { r.label = e, r = r.next } while (!n.isEqual(r)); e++ } }), t }, t.prototype.getEdgeRings = function () { const t = this; this._computeNextCWEdges(), this.edges.forEach(function (t) { t.label = void 0 }), this._findLabeledEdgeRings().forEach(function (e) { t._findIntersectionNodes(e).forEach(function (n) { t._computeNextCCWEdges(n, e.label) }) }); const e = []; return this.edges.forEach(function (n) { n.ring || e.push(t._findEdgeRing(n)) }), e }, t.prototype._findIntersectionNodes = function (t) { const e = []; let n = t; const r = function () { let r = 0; n.from.getOuterEdges().forEach(function (e) { e.label === t.label && ++r }), r > 1 && e.push(n.from), n = n.next }; do { r() } while (!t.isEqual(n)); return e }, t.prototype._findEdgeRing = function (t) { let e = t; const n = new s.default(); do { n.push(e), e.ring = n, e = e.next } while (!t.isEqual(e)); return n }, t.prototype.removeNode = function (t) { const e = this; t.getOuterEdges().forEach(function (t) { return e.removeEdge(t) }), t.innerEdges.forEach(function (t) { return e.removeEdge(t) }), delete this.nodes[t.id] }, t.prototype.removeEdge = function (t) { this.edges = this.edges.filter(function (e) { return !e.isEqual(t) }), t.deleteEdge() }, t }()); e.default = l }, 3424: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4772); const i = (function () { function t (e) { this.id = t.buildId(e), this.coordinates = e, this.innerEdges = [], this.outerEdges = [], this.outerEdgesSorted = !1 } return t.buildId = function (t) { return t.join(',') }, t.prototype.removeInnerEdge = function (t) { this.innerEdges = this.innerEdges.filter(function (e) { return e.from.id !== t.from.id }) }, t.prototype.removeOuterEdge = function (t) { this.outerEdges = this.outerEdges.filter(function (e) { return e.to.id !== t.to.id }) }, t.prototype.addOuterEdge = function (t) { this.outerEdges.push(t), this.outerEdgesSorted = !1 }, t.prototype.sortOuterEdges = function () { const t = this; this.outerEdgesSorted || (this.outerEdges.sort(function (e, n) { const i = e.to; const o = n.to; if (i.coordinates[0] - t.coordinates[0] >= 0 && o.coordinates[0] - t.coordinates[0] < 0) return 1; if (i.coordinates[0] - t.coordinates[0] < 0 && o.coordinates[0] - t.coordinates[0] >= 0) return -1; if (i.coordinates[0] - t.coordinates[0] == 0 && o.coordinates[0] - t.coordinates[0] == 0) return i.coordinates[1] - t.coordinates[1] >= 0 || o.coordinates[1] - t.coordinates[1] >= 0 ? i.coordinates[1] - o.coordinates[1] : o.coordinates[1] - i.coordinates[1]; const s = r.orientationIndex(t.coordinates, i.coordinates, o.coordinates); return s < 0 ? 1 : s > 0 ? -1 : Math.pow(i.coordinates[0] - t.coordinates[0], 2) + Math.pow(i.coordinates[1] - t.coordinates[1], 2) - (Math.pow(o.coordinates[0] - t.coordinates[0], 2) + Math.pow(o.coordinates[1] - t.coordinates[1], 2)) }), this.outerEdgesSorted = !0) }, t.prototype.getOuterEdges = function () { return this.sortOuterEdges(), this.outerEdges }, t.prototype.getOuterEdge = function (t) { return this.sortOuterEdges(), this.outerEdges[t] }, t.prototype.addInnerEdge = function (t) { this.innerEdges.push(t) }, t }()); e.default = i }, 4772: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(8147)); const o = n(4102); e.orientationIndex = function (t, e, n) { let r; const i = e[0] - t[0]; const o = e[1] - t[1]; const s = n[0] - e[0]; return ((r = i * (n[1] - e[1]) - s * o) > 0) - (r < 0) || +r }, e.envelopeIsEqual = function (t, e) { const n = t.geometry.coordinates[0].map(function (t) { return t[0] }); const r = t.geometry.coordinates[0].map(function (t) { return t[1] }); const i = e.geometry.coordinates[0].map(function (t) { return t[0] }); const o = e.geometry.coordinates[0].map(function (t) { return t[1] }); return Math.max.apply(null, n) === Math.max.apply(null, i) && Math.max.apply(null, r) === Math.max.apply(null, o) && Math.min.apply(null, n) === Math.min.apply(null, i) && Math.min.apply(null, r) === Math.min.apply(null, o) }, e.envelopeContains = function (t, e) { return e.geometry.coordinates[0].every(function (e) { return i.default(o.point(e), t) }) }, e.coordinatesEqual = function (t, e) { return t[0] === e[0] && t[1] === e[1] } }, 981: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(1540); const o = n(4102); const s = r(n(6565)); function a (t, e, n) { void 0 === n && (n = {}); const r = (n = n || {}).mutate; if (!t) throw new Error('geojson is required'); return Array.isArray(t) && o.isNumber(t[0]) ? t = e === 'mercator' ? u(t) : l(t) : (!0 !== r && (t = s.default(t)), i.coordEach(t, function (t) { const n = e === 'mercator' ? u(t) : l(t); t[0] = n[0], t[1] = n[1] })), t } function u (t) { let e; const n = Math.PI / 180; const r = 6378137; const i = 20037508.342789244; const o = [r * (Math.abs(t[0]) <= 180 ? t[0] : t[0] - 360 * ((e = t[0]) < 0 ? -1 : e > 0 ? 1 : 0)) * n, r * Math.log(Math.tan(0.25 * Math.PI + 0.5 * t[1] * n))]; return o[0] > i && (o[0] = i), o[0] < -i && (o[0] = -i), o[1] > i && (o[1] = i), o[1] < -i && (o[1] = -i), o } function l (t) { const e = 180 / Math.PI; const n = 6378137; return [t[0] * e / n, (0.5 * Math.PI - 2 * Math.atan(Math.exp(-t[1] / n))) * e] }e.toMercator = function (t, e) { return void 0 === e && (e = {}), a(t, 'mercator', e) }, e.toWgs84 = function (t, e) { return void 0 === e && (e = {}), a(t, 'wgs84', e) } }, 6295: function (t, e, n) { 'use strict'; const r = this && this.__spreadArrays || function () { for (var t = 0, e = 0, n = arguments.length; e < n; e++)t += arguments[e].length; const r = Array(t); let i = 0; for (e = 0; e < n; e++) for (let o = arguments[e], s = 0, a = o.length; s < a; s++, i++)r[i] = o[s]; return r }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = n(4102); function o (t) { return Array.isArray(t) ? a(t) : t && t.bbox ? a(t.bbox) : [360 * s(), 180 * s()] } function s () { return Math.random() - 0.5 } function a (t) { return [Math.random() * (t[2] - t[0]) + t[0], Math.random() * (t[3] - t[1]) + t[1]] }e.randomPosition = o, e.randomPoint = function (t, e) { void 0 === e && (e = {}), t == null && (t = 1); for (var n = [], r = 0; r < t; r++)n.push(i.point(o(e.bbox))); return i.featureCollection(n) }, e.randomPolygon = function (t, e) { void 0 === e && (e = {}), t == null && (t = 1), i.isNumber(e.num_vertices) && void 0 !== e.num_vertices || (e.num_vertices = 10), i.isNumber(e.max_radial_length) && void 0 !== e.max_radial_length || (e.max_radial_length = 10); for (var n = [], s = function (t) { let s; let a = []; const u = r(Array(e.num_vertices + 1)).map(Math.random); u.forEach(function (t, e, n) { n[e] = e > 0 ? t + n[e - 1] : t }), u.forEach(function (t) { t = 2 * t * Math.PI / u[u.length - 1]; const n = Math.random(); a.push([n * (e.max_radial_length || 10) * Math.sin(t), n * (e.max_radial_length || 10) * Math.cos(t)]) }), a[a.length - 1] = a[0], a = a.map((s = o(e.bbox), function (t) { return [t[0] + s[0], t[1] + s[1]] })), n.push(i.polygon([a])) }, a = 0; a < t; a++)s(); return i.featureCollection(n) }, e.randomLineString = function (t, e) { if (void 0 === e && (e = {}), e = e || {}, !i.isObject(e)) throw new Error('options is invalid'); const n = e.bbox; let r = e.num_vertices; let s = e.max_length; let a = e.max_rotation; t == null && (t = 1), (!i.isNumber(r) || void 0 === r || r < 2) && (r = 10), i.isNumber(s) && void 0 !== s || (s = 1e-4), i.isNumber(a) && void 0 !== a || (a = Math.PI / 8); for (var u = [], l = 0; l < t; l++) { for (var c = [o(n)], f = 0; f < r - 1; f++) { const h = (f === 0 ? 2 * Math.random() * Math.PI : Math.tan((c[f][1] - c[f - 1][1]) / (c[f][0] - c[f - 1][0]))) + (Math.random() - 0.5) * a * 2; const p = Math.random() * s; c.push([c[f][0] + p * Math.cos(h), c[f][1] + p * Math.sin(h)]) }u.push(i.lineString(c)) } return i.featureCollection(u) } }, 4131: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(5745)); const o = r(n(1013)); const s = n(4102); e.default = function (t, e, n, r) { void 0 === r && (r = {}); for (var a = [], u = t[0], l = t[1], c = t[2], f = t[3], h = e / o.default([u, l], [c, l], r) * (c - u), p = n / o.default([u, l], [u, f], r) * (f - l), g = c - u, d = f - l, y = Math.floor(g / h), v = Math.floor(d / p), _ = (d - v * p) / 2, m = u + (g - y * h) / 2, x = 0; x < y; x++) { for (let b = l + _, E = 0; E < v; E++) { const w = s.polygon([[[m, b], [m, b + p], [m + h, b + p], [m + h, b], [m, b]]], r.properties); r.mask ? i.default(r.mask, w) && a.push(w) : a.push(w), b += p }m += h } return s.featureCollection(a) } }, 1138: (t, e, n) => { 'use strict'; const r = n(6565); const i = n(3809); const o = n(1540); const s = n(611); const a = n(4102); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(r); const c = u(i); function f (t, e) { if (e = e || {}, !a.isObject(e)) throw new Error('options is invalid'); const n = e.reverse || !1; const r = e.mutate || !1; if (!t) throw new Error('<geojson> is required'); if (typeof n !== 'boolean') throw new Error('<reverse> must be a boolean'); if (typeof r !== 'boolean') throw new Error('<mutate> must be a boolean'); !1 === r && (t = l.default(t)); const i = []; switch (t.type) { case 'GeometryCollection':return o.geomEach(t, function (t) { h(t, n) }), t; case 'FeatureCollection':return o.featureEach(t, function (t) { o.featureEach(h(t, n), function (t) { i.push(t) }) }), a.featureCollection(i) } return h(t, n) } function h (t, e) { switch (t.type === 'Feature' ? t.geometry.type : t.type) { case 'GeometryCollection':return o.geomEach(t, function (t) { h(t, e) }), t; case 'LineString':return p(s.getCoords(t), e), t; case 'Polygon':return g(s.getCoords(t), e), t; case 'MultiLineString':return s.getCoords(t).forEach(function (t) { p(t, e) }), t; case 'MultiPolygon':return s.getCoords(t).forEach(function (t) { g(t, e) }), t; case 'Point':case 'MultiPoint':return t } } function p (t, e) { c.default(t) === e && t.reverse() } function g (t, e) { c.default(t[0]) !== e && t[0].reverse(); for (let n = 1; n < t.length; n++)c.default(t[n]) === e && t[n].reverse() }t.exports = f, t.exports.default = f }, 2054: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); function o (t, e) { const n = r.degreesToRadians(t[1]); const i = r.degreesToRadians(e[1]); let o = r.degreesToRadians(e[0] - t[0]); o > Math.PI && (o -= 2 * Math.PI), o < -Math.PI && (o += 2 * Math.PI); const s = Math.log(Math.tan(i / 2 + Math.PI / 4) / Math.tan(n / 2 + Math.PI / 4)); const a = Math.atan2(o, s); return (r.radiansToDegrees(a) + 360) % 360 }e.default = function (t, e, n) { let r; return void 0 === n && (n = {}), (r = n.final ? o(i.getCoord(e), i.getCoord(t)) : o(i.getCoord(t), i.getCoord(e))) > 180 ? -(360 - r) : r } }, 6082: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); e.default = function (t, e, n, o) { void 0 === o && (o = {}); const s = e < 0; let a = r.convertLength(Math.abs(e), o.units, 'meters'); s && (a = -Math.abs(a)); const u = i.getCoord(t); const l = (function (t, e, n, i) { const o = e / (i = void 0 === i ? r.earthRadius : Number(i)); const s = t[0] * Math.PI / 180; const a = r.degreesToRadians(t[1]); const u = r.degreesToRadians(n); const l = o * Math.cos(u); let c = a + l; Math.abs(c) > Math.PI / 2 && (c = c > 0 ? Math.PI - c : -Math.PI - c); const f = Math.log(Math.tan(c / 2 + Math.PI / 4) / Math.tan(a / 2 + Math.PI / 4)); const h = Math.abs(f) > 1e-11 ? l / f : Math.cos(a); return [(180 * (s + o * Math.sin(u) / h) / Math.PI + 540) % 360 - 180, 180 * c / Math.PI] }(u, a, n)); return l[0] += l[0] - u[0] > 180 ? -360 : u[0] - l[0] > 180 ? 360 : 0, r.point(l, o.properties) } }, 6213: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); const i = n(611); e.default = function (t, e, n) { void 0 === n && (n = {}); const o = i.getCoord(t); const s = i.getCoord(e); s[0] += s[0] - o[0] > 180 ? -360 : o[0] - s[0] > 180 ? 360 : 0; const a = (function (t, e, n) { const i = n = void 0 === n ? r.earthRadius : Number(n); const o = t[1] * Math.PI / 180; const s = e[1] * Math.PI / 180; const a = s - o; let u = Math.abs(e[0] - t[0]) * Math.PI / 180; u > Math.PI && (u -= 2 * Math.PI); const l = Math.log(Math.tan(s / 2 + Math.PI / 4) / Math.tan(o / 2 + Math.PI / 4)); const c = Math.abs(l) > 1e-11 ? a / l : Math.cos(o); return Math.sqrt(a * a + c * c * u * u) * i }(o, s)); return r.convertLength(a, 'meters', n.units) } }, 3503: (t, e, n) => { 'use strict'; const r = n(4102); function i (t, e) { if (!t) throw new Error('featurecollection is required'); if (e == null) throw new Error('num is required'); if (typeof e !== 'number') throw new Error('num must be a number'); return r.featureCollection(function (t, e) { for (var n, r, i = t.slice(0), o = t.length, s = o - e; o-- > s;)n = i[r = Math.floor((o + 1) * Math.random())], i[r] = i[o], i[o] = n; return i.slice(s) }(t.features, e)) }t.exports = i, t.exports.default = i }, 1674: (t, e, n) => { 'use strict'; const r = n(265); const i = n(7272); const o = n(1540); const s = n(4102); const a = n(611); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(r); const c = u(i); function f (t, e, n, r, i) { if (i = i || {}, !s.isObject(i)) throw new Error('options is invalid'); const u = i.properties; if (!t) throw new Error('center is required'); if (n == null) throw new Error('bearing1 is required'); if (r == null) throw new Error('bearing2 is required'); if (!e) throw new Error('radius is required'); if (typeof i !== 'object') throw new Error('options must be an object'); if (h(n) === h(r)) return l.default(t, e, i); const f = a.getCoords(t); const p = c.default(t, e, n, r, i); const g = [[f]]; return o.coordEach(p, function (t) { g[0].push(t) }), g[0].push(f), s.polygon(g, u) } function h (t) { let e = t % 360; return e < 0 && (e += 360), e }t.exports = f, t.exports.default = f }, 3550: (t, e, n) => { 'use strict'; const r = n(9705); const i = n(8147); const o = n(1013); const s = n(7517); const a = n(1435); const u = n(3652); const l = n(611); const c = n(4102); function f (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const h = f(r); const p = f(i); const g = f(o); const d = f(s); const y = f(a); const v = f(u); function _ (t) { for (var e = t, n = []; e.parent;)n.unshift(e), e = e.parent; return n } var m = { search: function (t, e, n, r) { t.cleanDirty(); const i = (r = r || {}).heuristic || m.heuristics.manhattan; const o = r.closest || !1; const s = new E(function (t) { return t.f }); let a = e; for (e.h = i(e, n), s.push(e); s.size() > 0;) { const u = s.pop(); if (u === n) return _(u); u.closed = !0; for (let l = t.neighbors(u), c = 0, f = l.length; c < f; ++c) { const h = l[c]; if (!h.closed && !h.isWall()) { const p = u.g + h.getCost(u); const g = h.visited; (!g || p < h.g) && (h.visited = !0, h.parent = u, h.h = h.h || i(h, n), h.g = p, h.f = h.g + h.h, t.markDirty(h), o && (h.h < a.h || h.h === a.h && h.g < a.g) && (a = h), g ? s.rescoreElement(h) : s.push(h)) } } } return o ? _(a) : [] }, heuristics: { manhattan: function (t, e) { return Math.abs(e.x - t.x) + Math.abs(e.y - t.y) }, diagonal: function (t, e) { const n = Math.sqrt(2); const r = Math.abs(e.x - t.x); const i = Math.abs(e.y - t.y); return 1 * (r + i) + (n - 2) * Math.min(r, i) } }, cleanNode: function (t) { t.f = 0, t.g = 0, t.h = 0, t.visited = !1, t.closed = !1, t.parent = null } }; function x (t, e) { e = e || {}, this.nodes = [], this.diagonal = !!e.diagonal, this.grid = []; for (let n = 0; n < t.length; n++) { this.grid[n] = []; for (let r = 0, i = t[n]; r < i.length; r++) { const o = new b(n, r, i[r]); this.grid[n][r] = o, this.nodes.push(o) } } this.init() } function b (t, e, n) { this.x = t, this.y = e, this.weight = n } function E (t) { this.content = [], this.scoreFunction = t } function w (t, e, n) { if (n = n || {}, !c.isObject(n)) throw new Error('options is invalid'); let r = n.resolution; const i = n.minDistance; let o = n.obstacles || c.featureCollection([]); if (!t) throw new Error('start is required'); if (!e) throw new Error('end is required'); if (r && !c.isNumber(r) || r <= 0) throw new Error('options.resolution must be a number, greater than 0'); if (i) throw new Error('options.minDistance is not yet implemented'); const s = l.getCoord(t); const a = l.getCoord(e); switch (t = c.point(s), e = c.point(a), l.getType(o)) { case 'FeatureCollection':if (o.features.length === 0) return c.lineString([s, a]); break; case 'Polygon':o = c.featureCollection([c.feature(l.getGeom(o))]); break; default:throw new Error('invalid obstacles') } const u = o; u.features.push(t), u.features.push(e); const f = h.default(d.default(v.default(h.default(u)), 1.15)); r || (r = g.default([f[0], f[1]], [f[2], f[1]], n) / 100), u.features.pop(), u.features.pop(); for (var p = f[0], _ = f[1], b = f[2], E = f[3], w = r / g.default([p, _], [b, _], n) * (b - p), S = r / g.default([p, _], [p, E], n) * (E - _), N = b - p, P = E - _, C = Math.floor(N / w), M = Math.floor(P / S), O = (N - C * w) / 2, L = [], R = [], A = [], T = [], D = 1 / 0, F = 1 / 0, j = E - (P - M * S) / 2, k = 0; j >= _;) { for (var G = [], q = [], B = p + O, z = 0; B <= b;) { const U = c.point([B, j]); const X = I(U, o); G.push(X ? 0 : 1), q.push(B + '|' + j); const Y = g.default(U, t); !X && Y < D && (D = Y, A = { x: z, y: k }); const V = g.default(U, e); !X && V < F && (F = V, T = { x: z, y: k }), B += w, z++ }R.push(G), L.push(q), j -= S, k++ } const W = new x(R, { diagonal: !0 }); const H = W.grid[A.y][A.x]; const J = W.grid[T.y][T.x]; const Z = m.search(W, H, J); const K = [s]; return Z.forEach(function (t) { const e = L[t.x][t.y].split('|'); K.push([+e[0], +e[1]]) }), K.push(a), y.default(c.lineString(K)) } function I (t, e) { for (let n = 0; n < e.features.length; n++) if (p.default(t, e.features[n])) return !0; return !1 }x.prototype.init = function () { this.dirtyNodes = []; for (let t = 0; t < this.nodes.length; t++)m.cleanNode(this.nodes[t]) }, x.prototype.cleanDirty = function () { for (let t = 0; t < this.dirtyNodes.length; t++)m.cleanNode(this.dirtyNodes[t]); this.dirtyNodes = [] }, x.prototype.markDirty = function (t) { this.dirtyNodes.push(t) }, x.prototype.neighbors = function (t) { const e = []; const n = t.x; const r = t.y; const i = this.grid; return i[n - 1] && i[n - 1][r] && e.push(i[n - 1][r]), i[n + 1] && i[n + 1][r] && e.push(i[n + 1][r]), i[n] && i[n][r - 1] && e.push(i[n][r - 1]), i[n] && i[n][r + 1] && e.push(i[n][r + 1]), this.diagonal && (i[n - 1] && i[n - 1][r - 1] && e.push(i[n - 1][r - 1]), i[n + 1] && i[n + 1][r - 1] && e.push(i[n + 1][r - 1]), i[n - 1] && i[n - 1][r + 1] && e.push(i[n - 1][r + 1]), i[n + 1] && i[n + 1][r + 1] && e.push(i[n + 1][r + 1])), e }, x.prototype.toString = function () { for (var t, e, n, r, i = [], o = this.grid, s = 0, a = o.length; s < a; s++) { for (t = [], n = 0, r = (e = o[s]).length; n < r; n++)t.push(e[n].weight); i.push(t.join(' ')) } return i.join('\n') }, b.prototype.toString = function () { return '[' + this.x + ' ' + this.y + ']' }, b.prototype.getCost = function (t) { return t && t.x !== this.x && t.y !== this.y ? 1.41421 * this.weight : this.weight }, b.prototype.isWall = function () { return this.weight === 0 }, E.prototype = { push: function (t) { this.content.push(t), this.sinkDown(this.content.length - 1) }, pop: function () { const t = this.content[0]; const e = this.content.pop(); return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t }, remove: function (t) { const e = this.content.indexOf(t); const n = this.content.pop(); e !== this.content.length - 1 && (this.content[e] = n, this.scoreFunction(n) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e)) }, size: function () { return this.content.length }, rescoreElement: function (t) { this.sinkDown(this.content.indexOf(t)) }, sinkDown: function (t) { for (let e = this.content[t]; t > 0;) { const n = (t + 1 >> 1) - 1; const r = this.content[n]; if (!(this.scoreFunction(e) < this.scoreFunction(r))) break; this.content[n] = e, this.content[t] = r, t = n } }, bubbleUp: function (t) { for (let e = this.content.length, n = this.content[t], r = this.scoreFunction(n); ;) { var i; const o = t + 1 << 1; const s = o - 1; let a = null; if (s < e) { const u = this.content[s]; (i = this.scoreFunction(u)) < r && (a = s) } if (o < e) { const l = this.content[o]; this.scoreFunction(l) < (a === null ? r : i) && (a = o) } if (a === null) break; this.content[t] = this.content[a], this.content[a] = n, t = a } } }, t.exports = w, t.exports.default = w }, 7191: (t, e, n) => { 'use strict'; const r = n(1435); const i = n(6565); const o = n(1540); const s = n(4102); function a (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const u = a(r); const l = a(i); function c (t, e, n) { let r = e.x; let i = e.y; let o = n.x - r; let s = n.y - i; if (o !== 0 || s !== 0) { const a = ((t.x - r) * o + (t.y - i) * s) / (o * o + s * s); a > 1 ? (r = n.x, i = n.y) : a > 0 && (r += o * a, i += s * a) } return (o = t.x - r) * o + (s = t.y - i) * s } function f (t, e, n, r, i) { for (var o, s = r, a = e + 1; a < n; a++) { const u = c(t[a], t[e], t[n]); u > s && (o = a, s = u) }s > r && (o - e > 1 && f(t, e, o, r, i), i.push(t[o]), n - o > 1 && f(t, o, n, r, i)) } function h (t, e) { const n = t.length - 1; const r = [t[0]]; return f(t, 0, n, e, r), r.push(t[n]), r } function p (t, e, n) { if (t.length <= 2) return t; const r = void 0 !== e ? e * e : 1; return t = n ? t : (function (t, e) { for (var n, r, i, o, s, a = t[0], u = [a], l = 1, c = t.length; l < c; l++)i = a, void 0, void 0, (o = (r = n = t[l]).x - i.x) * o + (s = r.y - i.y) * s > e && (u.push(n), a = n); return a !== n && u.push(n), u }(t, r)), h(t, r) } function g (t, e) { if (e = e || {}, !s.isObject(e)) throw new Error('options is invalid'); const n = void 0 !== e.tolerance ? e.tolerance : 1; const r = e.highQuality || !1; const i = e.mutate || !1; if (!t) throw new Error('geojson is required'); if (n && n < 0) throw new Error('invalid tolerance'); return !0 !== i && (t = l.default(t)), o.geomEach(t, function (t) { !(function (t, e, n) { const r = t.type; if (r === 'Point' || r === 'MultiPoint') return t; u.default(t, !0); const i = t.coordinates; switch (r) { case 'LineString':t.coordinates = d(i, e, n); break; case 'MultiLineString':t.coordinates = i.map(function (t) { return d(t, e, n) }); break; case 'Polygon':t.coordinates = y(i, e, n); break; case 'MultiPolygon':t.coordinates = i.map(function (t) { return y(t, e, n) }) } }(t, n, r)) }), t } function d (t, e, n) { return p(t.map(function (t) { return { x: t[0], y: t[1], z: t[2] } }), e, n).map(function (t) { return t.z ? [t.x, t.y, t.z] : [t.x, t.y] }) } function y (t, e, n) { return t.map(function (t) { const r = t.map(function (t) { return { x: t[0], y: t[1] } }); if (r.length < 4) throw new Error('invalid polygon'); for (var i = p(r, e, n).map(function (t) { return [t.x, t.y] }); !v(i);)i = p(r, e -= 0.01 * e, n).map(function (t) { return [t.x, t.y] }); return i[i.length - 1][0] === i[0][0] && i[i.length - 1][1] === i[0][1] || i.push(i[0]), i }) } function v (t) { return !(t.length < 3 || t.length === 3 && t[2][0] === t[0][0] && t[2][1] === t[0][1]) }t.exports = g, t.exports.default = g }, 5434: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(4131)); e.default = function (t, e, n) { return void 0 === n && (n = {}), i.default(t, e, e, n) } }, 5077: (t, e, n) => { 'use strict'; function r (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const i = r(n(1013)); function o (t) { const e = t[0]; const n = t[1]; const r = t[2]; const o = t[3]; if (i.default(t.slice(0, 2), [r, n]) >= i.default(t.slice(0, 2), [e, o])) { const s = (n + o) / 2; return [e, s - (r - e) / 2, r, s + (r - e) / 2] } const a = (e + r) / 2; return [a - (o - n) / 2, n, a + (o - n) / 2, o] }t.exports = o, t.exports.default = o }, 3955: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(611); const o = n(4102); const s = n(6320); const a = n(187); const u = n(1211); function l (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const c = l(s); const f = l(a); const h = l(u); function p (t, e) { if (e = e || {}, !o.isObject(e)) throw new Error('options is invalid'); const n = e.steps || 64; const s = e.weight; const a = e.properties || {}; if (!o.isNumber(n)) throw new Error('steps must be a number'); if (!o.isObject(a)) throw new Error('properties must be a number'); const u = r.coordAll(t).length; const l = c.default(t, { weight: s }); let p = 0; let d = 0; let y = 0; r.featureEach(t, function (t) { const e = t.properties[s] || 1; const n = g(i.getCoords(t), i.getCoords(l)); p += Math.pow(n.x, 2) * e, d += Math.pow(n.y, 2) * e, y += n.x * n.y * e }); const v = p - d; const _ = Math.sqrt(Math.pow(v, 2) + 4 * Math.pow(y, 2)); const m = 2 * y; const x = Math.atan((v + _) / m); const b = 180 * x / Math.PI; let E = 0; let w = 0; let I = 0; r.featureEach(t, function (t) { const e = t.properties[s] || 1; const n = g(i.getCoords(t), i.getCoords(l)); E += Math.pow(n.x * Math.cos(x) - n.y * Math.sin(x), 2) * e, w += Math.pow(n.x * Math.sin(x) + n.y * Math.cos(x), 2) * e, I += e }); const S = Math.sqrt(2 * E / I); const N = Math.sqrt(2 * w / I); const P = h.default(l, S, N, { units: 'degrees', angle: b, steps: n, properties: a }); const C = f.default(t, o.featureCollection([P])); const M = { meanCenterCoordinates: i.getCoords(l), semiMajorAxis: S, semiMinorAxis: N, numberOfFeatures: u, angle: b, percentageWithinEllipse: 100 * r.coordAll(C).length / u }; return P.properties.standardDeviationalEllipse = M, P } function g (t, e) { return { x: t[0] - e[0], y: t[1] - e[1] } }t.exports = p, t.exports.default = p }, 2015: (t, e, n) => { 'use strict'; const r = n(8147); const i = n(6565); const o = n(1540); function s (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const a = s(r); const u = s(i); function l (t, e, n, r) { return t = u.default(t), e = u.default(e), o.featureEach(t, function (t) { t.properties || (t.properties = {}), o.featureEach(e, function (e) { void 0 === t.properties[r] && a.default(t, e) && (t.properties[r] = e.properties[n]) }) }), t }t.exports = l, t.exports.default = l }, 5845: (t, e, n) => { 'use strict'; const r = n(9187); const i = n(4102); function o (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const s = o(r); function a (t) { if (!t.geometry || t.geometry.type !== 'Polygon' && t.geometry.type !== 'MultiPolygon') throw new Error('input must be a Polygon or MultiPolygon'); const e = { type: 'FeatureCollection', features: [] }; return t.geometry.type === 'Polygon' ? e.features = u(t.geometry.coordinates) : t.geometry.coordinates.forEach(function (t) { e.features = e.features.concat(u(t)) }), e } function u (t) { const e = (function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (let o = 0; o < t[i].length; o++) for (let s = 0; s < e; s++)n.vertices.push(t[i][o][s]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n }(t)); const n = s.default(e.vertices, e.holes, 2); const r = []; const o = []; n.forEach(function (t, r) { const i = n[r]; o.push([e.vertices[2 * i], e.vertices[2 * i + 1]]) }); for (let a = 0; a < o.length; a += 3) { const u = o.slice(a, a + 3); u.push(o[a]), r.push(i.polygon([u])) } return r }t.exports = a, t.exports.default = a }, 8829: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(4102); e.default = function (t, e) { let n = !1; return r.featureCollection((function (t) { if (t.length < 3) return []; t.sort(o); for (var e, n, r, a, u, l, c = t.length - 1, f = t[c].x, h = t[0].x, p = t[c].y, g = p; c--;)t[c].y < p && (p = t[c].y), t[c].y > g && (g = t[c].y); let d; let y = h - f; let v = g - p; const _ = y > v ? y : v; const m = 0.5 * (h + f); const x = 0.5 * (g + p); const b = [new i({ __sentinel: !0, x: m - 20 * _, y: x - _ }, { __sentinel: !0, x: m, y: x + 20 * _ }, { __sentinel: !0, x: m + 20 * _, y: x - _ })]; const E = []; const w = []; for (c = t.length; c--;) { for (w.length = 0, d = b.length; d--;)(y = t[c].x - b[d].x) > 0 && y * y > b[d].r ? (E.push(b[d]), b.splice(d, 1)) : y * y + (v = t[c].y - b[d].y) * v > b[d].r || (w.push(b[d].a, b[d].b, b[d].b, b[d].c, b[d].c, b[d].a), b.splice(d, 1)); for (s(w), d = w.length; d;)n = w[--d], e = w[--d], r = t[c], a = n.x - e.x, u = n.y - e.y, l = 2 * (a * (r.y - n.y) - u * (r.x - n.x)), Math.abs(l) > 1e-12 && b.push(new i(e, n, r)) } for (Array.prototype.push.apply(E, b), c = E.length; c--;)(E[c].a.__sentinel || E[c].b.__sentinel || E[c].c.__sentinel) && E.splice(c, 1); return E }(t.features.map(function (t) { const r = { x: t.geometry.coordinates[0], y: t.geometry.coordinates[1] }; return e ? r.z = t.properties[e] : t.geometry.coordinates.length === 3 && (n = !0, r.z = t.geometry.coordinates[2]), r }))).map(function (t) { const e = [t.a.x, t.a.y]; const i = [t.b.x, t.b.y]; const o = [t.c.x, t.c.y]; let s = {}; return n ? (e.push(t.a.z), i.push(t.b.z), o.push(t.c.z)) : s = { a: t.a.z, b: t.b.z, c: t.c.z }, r.polygon([[e, i, o, e]], s) })) }; var i = function (t, e, n) { this.a = t, this.b = e, this.c = n; let r; let i; const o = e.x - t.x; const s = e.y - t.y; const a = n.x - t.x; const u = n.y - t.y; const l = o * (t.x + e.x) + s * (t.y + e.y); const c = a * (t.x + n.x) + u * (t.y + n.y); const f = 2 * (o * (n.y - e.y) - s * (n.x - e.x)); this.x = (u * l - s * c) / f, this.y = (o * c - a * l) / f, r = this.x - t.x, i = this.y - t.y, this.r = r * r + i * i }; function o (t, e) { return e.x - t.x } function s (t) { let e; let n; let r; let i; let o; let s = t.length; t:for (;s;) for (n = t[--s], e = t[--s], r = s; r;) if (o = t[--r], e === (i = t[--r]) && n === o || e === o && n === i) { t.splice(s, 2), t.splice(r, 2), s -= 2; continue t } } }, 67: (t, e, n) => { 'use strict'; const r = n(6338); const i = n(2054); const o = n(6213); const s = n(6082); const a = n(6565); const u = n(1540); const l = n(611); const c = n(4102); function f (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const h = f(r); const p = f(i); const g = f(o); const d = f(s); const y = f(a); function v (t, e, n) { if (n = n || {}, !c.isObject(n)) throw new Error('options is invalid'); let r = n.pivot; const i = n.mutate; if (!t) throw new Error('geojson is required'); if (e == null || isNaN(e)) throw new Error('angle is required'); return e === 0 || (r || (r = h.default(t)), !1 !== i && void 0 !== i || (t = y.default(t)), u.coordEach(t, function (t) { const n = p.default(r, t) + e; const i = g.default(r, t); const o = l.getCoords(d.default(r, i, n)); t[0] = o[0], t[1] = o[1] })), t }t.exports = v, t.exports.default = v }, 7517: (t, e, n) => { 'use strict'; const r = n(6565); const i = n(8230); const o = n(6338); const s = n(9705); const a = n(2054); const u = n(6213); const l = n(6082); const c = n(1540); const f = n(4102); const h = n(611); function p (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const g = p(r); const d = p(i); const y = p(o); const v = p(s); const _ = p(a); const m = p(u); const x = p(l); function b (t, e, n) { if (n = n || {}, !f.isObject(n)) throw new Error('options is invalid'); const r = n.origin; const i = n.mutate; if (!t) throw new Error('geojson required'); if (typeof e !== 'number' || e === 0) throw new Error('invalid factor'); const o = Array.isArray(r) || typeof r === 'object'; return !0 !== i && (t = g.default(t)), t.type !== 'FeatureCollection' || o ? E(t, e, r) : (c.featureEach(t, function (n, i) { t.features[i] = E(n, e, r) }), t) } function E (t, e, n) { const r = h.getType(t) === 'Point'; return n = (function (t, e) { if (e == null && (e = 'centroid'), Array.isArray(e) || typeof e === 'object') return h.getCoord(e); const n = t.bbox ? t.bbox : v.default(t); const r = n[0]; const i = n[1]; const o = n[2]; const s = n[3]; switch (e) { case 'sw':case 'southwest':case 'westsouth':case 'bottomleft':return f.point([r, i]); case 'se':case 'southeast':case 'eastsouth':case 'bottomright':return f.point([o, i]); case 'nw':case 'northwest':case 'westnorth':case 'topleft':return f.point([r, s]); case 'ne':case 'northeast':case 'eastnorth':case 'topright':return f.point([o, s]); case 'center':return d.default(t); case void 0:case null:case 'centroid':return y.default(t); default:throw new Error('invalid origin') } }(t, n)), e === 1 || r || c.coordEach(t, function (t) { const r = m.default(n, t); const i = _.default(n, t); const o = r * e; const s = h.getCoords(x.default(n, o, i)); t[0] = s[0], t[1] = s[1], t.length === 3 && (t[2] *= e) }), t }t.exports = b, t.exports.default = b }, 2418: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(4102); const o = n(611); const s = n(6565); const a = n(6082); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(s); const c = u(a); function f (t, e, n, s) { if (s = s || {}, !i.isObject(s)) throw new Error('options is invalid'); const a = s.units; let u = s.zTranslation; const f = s.mutate; if (!t) throw new Error('geojson is required'); if (e == null || isNaN(e)) throw new Error('distance is required'); if (u && typeof u !== 'number' && isNaN(u)) throw new Error('zTranslation is not a number'); if (u = void 0 !== u ? u : 0, e === 0 && u === 0) return t; if (n == null || isNaN(n)) throw new Error('direction is required'); return e < 0 && (e = -e, n += 180), !1 !== f && void 0 !== f || (t = l.default(t)), r.coordEach(t, function (t) { const r = o.getCoords(c.default(t, e, n, { units: a })); t[0] = r[0], t[1] = r[1], u && t.length === 3 && (t[2] += u) }), t }t.exports = f, t.exports.default = f }, 4686: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(1013)); const o = r(n(4170)); const s = n(4102); e.default = function (t, e, n) { void 0 === n && (n = {}); for (var r = [], a = e / i.default([t[0], t[1]], [t[2], t[1]], n) * (t[2] - t[0]), u = e / i.default([t[0], t[1]], [t[0], t[3]], n) * (t[3] - t[1]), l = 0, c = t[0]; c <= t[2];) { for (let f = 0, h = t[1]; h <= t[3];) { let p = null; let g = null; l % 2 == 0 && f % 2 == 0 ? (p = s.polygon([[[c, h], [c, h + u], [c + a, h], [c, h]]], n.properties), g = s.polygon([[[c, h + u], [c + a, h + u], [c + a, h], [c, h + u]]], n.properties)) : l % 2 == 0 && f % 2 == 1 ? (p = s.polygon([[[c, h], [c + a, h + u], [c + a, h], [c, h]]], n.properties), g = s.polygon([[[c, h], [c, h + u], [c + a, h + u], [c, h]]], n.properties)) : f % 2 == 0 && l % 2 == 1 ? (p = s.polygon([[[c, h], [c, h + u], [c + a, h + u], [c, h]]], n.properties), g = s.polygon([[[c, h], [c + a, h + u], [c + a, h], [c, h]]], n.properties)) : f % 2 == 1 && l % 2 == 1 && (p = s.polygon([[[c, h], [c, h + u], [c + a, h], [c, h]]], n.properties), g = s.polygon([[[c, h + u], [c + a, h + u], [c + a, h], [c, h + u]]], n.properties)), n.mask ? (o.default(n.mask, p) && r.push(p), o.default(n.mask, g) && r.push(g)) : (r.push(p), r.push(g)), h += u, f++ }l++, c += a } return s.featureCollection(r) } }, 5608: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(1540); e.default = function (t, e) { void 0 === e && (e = {}); let n = e.precision; let i = e.coordinates; const o = e.mutate; if (n = n == null || isNaN(n) ? 6 : n, i = i == null || isNaN(i) ? 3 : i, !t) throw new Error('<geojson> is required'); if (typeof n !== 'number') throw new Error('<precision> must be a number'); if (typeof i !== 'number') throw new Error('<coordinates> must be a number'); !1 !== o && void 0 !== o || (t = JSON.parse(JSON.stringify(t))); const s = Math.pow(10, n); return r.coordEach(t, function (t) { !(function (t, e, n) { t.length > n && t.splice(n, t.length); for (let r = 0; r < t.length; r++)t[r] = Math.round(t[r] * e) / e }(t, s, i)) }), t } }, 8347: (t, e, n) => { 'use strict'; Object.defineProperty(e, '__esModule', { value: !0 }); const r = n(7928); const i = n(7382); const o = n(187); const s = n(8538); const a = n(305); const u = n(7970); const l = n(7191); const c = n(7478); const f = n(2015); const h = n(3503); const p = n(9062); const g = n(5077); const d = n(265); const y = n(9034); const v = n(8230); const _ = n(5084); const m = n(6338); const x = n(8141); const b = n(1013); const E = n(3922); const w = n(9705); const I = n(5845); const S = n(3652); const N = n(8147); const P = n(6379); const C = n(3807); const M = n(2059); const O = n(3377); const L = n(8829); const R = n(1208); const A = n(3737); const T = n(1641); const D = n(5771); const F = n(1070); const j = n(5913); const k = n(91); const G = n(4792); const q = n(1378); const B = n(6813); const z = n(5608); const U = n(4288); const X = n(3663); const Y = n(9632); const V = n(4404); const W = n(5422); const H = n(4590); const J = n(7477); const Z = n(7272); const K = n(7383); const Q = n(1933); const $ = n(173); const tt = n(273); const et = n(1674); const nt = n(2054); const rt = n(6213); const it = n(6082); const ot = n(5215); const st = n(1138); const at = n(7406); const ut = n(67); const lt = n(7517); const ct = n(2418); const ft = n(5668); const ht = n(4312); const pt = n(5883); const gt = n(4766); const dt = n(7656); const yt = n(3809); const vt = n(7612); const _t = n(2793); const mt = n(9482); const xt = n(5184); const bt = n(5745); const Et = n(6565); const wt = n(1435); const It = n(1495); const St = n(6398); const Nt = n(3892); const Pt = n(4840); const Ct = n(3550); const Mt = n(2276); const Ot = n(1211); const Lt = n(6320); const Rt = n(2935); const At = n(3955); const Tt = n(8517); const Dt = n(4978); const Ft = n(920); const jt = n(5366); const kt = n(981); const Gt = n(6295); const qt = n(3140); const Bt = n(4102); const zt = n(611); const Ut = n(1540); const Xt = n(8727); const Yt = n(5950); const Vt = n(1959); const Wt = n(4170); const Ht = n(2407); const Jt = n(5621); const Zt = n(482); const Kt = n(5434); const Qt = n(4686); const $t = n(5566); function te (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } function ee (t) { if (t && t.__esModule) return t; const e = Object.create(null); return t && Object.keys(t).forEach(function (n) { if (n !== 'default') { const r = Object.getOwnPropertyDescriptor(t, n); Object.defineProperty(e, n, r.get ? r : { enumerable: !0, get: function () { return t[n] } }) } }), e.default = t, Object.freeze(e) } const ne = te(r); const re = te(i); const ie = te(o); const oe = te(s); const se = te(a); const ae = te(u); const ue = te(l); const le = te(c); const ce = te(f); const fe = te(h); const he = te(p); const pe = te(g); const ge = te(d); const de = te(y); const ye = te(v); const ve = te(_); const _e = te(m); const me = te(x); const xe = te(b); const be = te(E); const Ee = te(w); const we = te(I); const Ie = te(S); const Se = te(N); const Ne = te(P); const Pe = te(C); const Ce = te(M); const Me = te(O); const Oe = te(L); const Le = te(R); const Re = te(A); const Ae = te(T); const Te = te(D); const De = te(F); const Fe = te(j); const je = te(k); const ke = te(G); const Ge = te(q); const qe = te(B); const Be = te(z); const ze = te(U); const Ue = te(X); const Xe = te(Y); const Ye = te(V); const Ve = te(W); const We = te(H); const He = te(J); const Je = te(Z); const Ze = te(K); const Ke = te(Q); const Qe = te($); const $e = te(tt); const tn = te(et); const en = te(nt); const nn = te(rt); const rn = te(it); const on = te(ot); const sn = te(st); const an = te(at); const un = te(ut); const ln = te(lt); const cn = te(ct); const fn = te(ft); const hn = te(ht); const pn = te(pt); const gn = te(gt); const dn = te(dt); const yn = te(yt); const vn = te(vt); const _n = te(_t); const mn = te(mt); const xn = te(xt); const bn = te(bt); const En = te(Et); const wn = te(wt); const In = te(It); const Sn = te(St); const Nn = te(Nt); const Pn = te(Pt); const Cn = te(Ct); const Mn = te(Mt); const On = te(Ot); const Ln = te(Lt); const Rn = te(Rt); const An = te(At); const Tn = te(Tt); const Dn = te(Dt); const Fn = te(Ft); const jn = te(jt); const kn = ee(kt); const Gn = ee(Gt); const qn = ee(qt); const Bn = ee(Bt); const zn = ee(zt); const Un = ee(Ut); const Xn = te(Xt); const Yn = te(Yt); const Vn = te(Vt); const Wn = te(Wt); const Hn = te(Ht); const Jn = te(Jt); const Zn = te(Zt); const Kn = te(Kt); const Qn = te(Qt); const $n = te($t); Object.keys(kt).forEach(function (t) { t !== 'default' && Object.defineProperty(e, t, { enumerable: !0, get: function () { return kt[t] } }) }), Object.keys(Gt).forEach(function (t) { t !== 'default' && Object.defineProperty(e, t, { enumerable: !0, get: function () { return Gt[t] } }) }), Object.keys(qt).forEach(function (t) { t !== 'default' && Object.defineProperty(e, t, { enumerable: !0, get: function () { return qt[t] } }) }), Object.keys(Bt).forEach(function (t) { t !== 'default' && Object.defineProperty(e, t, { enumerable: !0, get: function () { return Bt[t] } }) }), Object.keys(zt).forEach(function (t) { t !== 'default' && Object.defineProperty(e, t, { enumerable: !0, get: function () { return zt[t] } }) }), Object.keys(Ut).forEach(function (t) { t !== 'default' && Object.defineProperty(e, t, { enumerable: !0, get: function () { return Ut[t] } }) }), Object.defineProperty(e, 'isolines', { enumerable: !0, get: function () { return ne.default } }), Object.defineProperty(e, 'convex', { enumerable: !0, get: function () { return re.default } }), Object.defineProperty(e, 'pointsWithinPolygon', { enumerable: !0, get: function () { return ie.default } }), Object.defineProperty(e, 'within', { enumerable: !0, get: function () { return ie.default } }), Object.defineProperty(e, 'concave', { enumerable: !0, get: function () { return oe.default } }), Object.defineProperty(e, 'collect', { enumerable: !0, get: function () { return se.default } }), Object.defineProperty(e, 'flip', { enumerable: !0, get: function () { return ae.default } }), Object.defineProperty(e, 'simplify', { enumerable: !0, get: function () { return ue.default } }), Object.defineProperty(e, 'bezier', { enumerable: !0, get: function () { return le.default } }), Object.defineProperty(e, 'bezierSpline', { enumerable: !0, get: function () { return le.default } }), Object.defineProperty(e, 'tag', { enumerable: !0, get: function () { return ce.default } }), Object.defineProperty(e, 'sample', { enumerable: !0, get: function () { return fe.default } }), Object.defineProperty(e, 'envelope', { enumerable: !0, get: function () { return he.default } }), Object.defineProperty(e, 'square', { enumerable: !0, get: function () { return pe.default } }), Object.defineProperty(e, 'circle', { enumerable: !0, get: function () { return ge.default } }), Object.defineProperty(e, 'midpoint', { enumerable: !0, get: function () { return de.default } }), Object.defineProperty(e, 'center', { enumerable: !0, get: function () { return ye.default } }), Object.defineProperty(e, 'centerOfMass', { enumerable: !0, get: function () { return ve.default } }), Object.defineProperty(e, 'centroid', { enumerable: !0, get: function () { return _e.default } }), Object.defineProperty(e, 'combine', { enumerable: !0, get: function () { return me.default } }), Object.defineProperty(e, 'distance', { enumerable: !0, get: function () { return xe.default } }), Object.defineProperty(e, 'explode', { enumerable: !0, get: function () { return be.default } }), Object.defineProperty(e, 'bbox', { enumerable: !0, get: function () { return Ee.default } }), Object.defineProperty(e, 'tesselate', { enumerable: !0, get: function () { return we.default } }), Object.defineProperty(e, 'bboxPolygon', { enumerable: !0, get: function () { return Ie.default } }), Object.defineProperty(e, 'booleanPointInPolygon', { enumerable: !0, get: function () { return Se.default } }), Object.defineProperty(e, 'inside', { enumerable: !0, get: function () { return Se.default } }), Object.defineProperty(e, 'nearest', { enumerable: !0, get: function () { return Ne.default } }), Object.defineProperty(e, 'nearestPoint', { enumerable: !0, get: function () { return Ne.default } }), Object.defineProperty(e, 'nearestPointOnLine', { enumerable: !0, get: function () { return Pe.default } }), Object.defineProperty(e, 'pointOnLine', { enumerable: !0, get: function () { return Pe.default } }), Object.defineProperty(e, 'nearestPointToLine', { enumerable: !0, get: function () { return Ce.default } }), Object.defineProperty(e, 'planepoint', { enumerable: !0, get: function () { return Me.default } }), Object.defineProperty(e, 'tin', { enumerable: !0, get: function () { return Oe.default } }), Object.defineProperty(e, 'bearing', { enumerable: !0, get: function () { return Le.default } }), Object.defineProperty(e, 'destination', { enumerable: !0, get: function () { return Re.default } }), Object.defineProperty(e, 'kinks', { enumerable: !0, get: function () { return Ae.default } }), Object.defineProperty(e, 'pointOnFeature', { enumerable: !0, get: function () { return Te.default } }), Object.defineProperty(e, 'pointOnSurface', { enumerable: !0, get: function () { return Te.default } }), Object.defineProperty(e, 'area', { enumerable: !0, get: function () { return De.default } }), Object.defineProperty(e, 'along', { enumerable: !0, get: function () { return Fe.default } }), Object.defineProperty(e, 'length', { enumerable: !0, get: function () { return je.default } }), Object.defineProperty(e, 'lineDistance', { enumerable: !0, get: function () { return je.default } }), Object.defineProperty(e, 'lineSlice', { enumerable: !0, get: function () { return ke.default } }), Object.defineProperty(e, 'lineSliceAlong', { enumerable: !0, get: function () { return Ge.default } }), Object.defineProperty(e, 'pointGrid', { enumerable: !0, get: function () { return qe.default } }), Object.defineProperty(e, 'truncate', { enumerable: !0, get: function () { return Be.default } }), Object.defineProperty(e, 'flatten', { enumerable: !0, get: function () { return ze.default } }), Object.defineProperty(e, 'lineIntersect', { enumerable: !0, get: function () { return Ue.default } }), Object.defineProperty(e, 'lineChunk', { enumerable: !0, get: function () { return Xe.default } }), Object.defineProperty(e, 'unkinkPolygon', { enumerable: !0, get: function () { return Ye.default } }), Object.defineProperty(e, 'greatCircle', { enumerable: !0, get: function () { return Ve.default } }), Object.defineProperty(e, 'lineSegment', { enumerable: !0, get: function () { return We.default } }), Object.defineProperty(e, 'lineSplit', { enumerable: !0, get: function () { return He.default } }), Object.defineProperty(e, 'lineArc', { enumerable: !0, get: function () { return Je.default } }), Object.defineProperty(e, 'polygonToLine', { enumerable: !0, get: function () { return Ze.default } }), Object.defineProperty(e, 'polygonToLineString', { enumerable: !0, get: function () { return Ze.default } }), Object.defineProperty(e, 'lineStringToPolygon', { enumerable: !0, get: function () { return Ke.default } }), Object.defineProperty(e, 'lineToPolygon', { enumerable: !0, get: function () { return Ke.default } }), Object.defineProperty(e, 'bboxClip', { enumerable: !0, get: function () { return Qe.default } }), Object.defineProperty(e, 'lineOverlap', { enumerable: !0, get: function () { return $e.default } }), Object.defineProperty(e, 'sector', { enumerable: !0, get: function () { return tn.default } }), Object.defineProperty(e, 'rhumbBearing', { enumerable: !0, get: function () { return en.default } }), Object.defineProperty(e, 'rhumbDistance', { enumerable: !0, get: function () { return nn.default } }), Object.defineProperty(e, 'rhumbDestination', { enumerable: !0, get: function () { return rn.default } }), Object.defineProperty(e, 'polygonTangents', { enumerable: !0, get: function () { return on.default } }), Object.defineProperty(e, 'rewind', { enumerable: !0, get: function () { return sn.default } }), Object.defineProperty(e, 'isobands', { enumerable: !0, get: function () { return an.default } }), Object.defineProperty(e, 'transformRotate', { enumerable: !0, get: function () { return un.default } }), Object.defineProperty(e, 'transformScale', { enumerable: !0, get: function () { return ln.default } }), Object.defineProperty(e, 'transformTranslate', { enumerable: !0, get: function () { return cn.default } }), Object.defineProperty(e, 'lineOffset', { enumerable: !0, get: function () { return fn.default } }), Object.defineProperty(e, 'polygonize', { enumerable: !0, get: function () { return hn.default } }), Object.defineProperty(e, 'booleanDisjoint', { enumerable: !0, get: function () { return pn.default } }), Object.defineProperty(e, 'booleanContains', { enumerable: !0, get: function () { return gn.default } }), Object.defineProperty(e, 'booleanCrosses', { enumerable: !0, get: function () { return dn.default } }), Object.defineProperty(e, 'booleanClockwise', { enumerable: !0, get: function () { return yn.default } }), Object.defineProperty(e, 'booleanOverlap', { enumerable: !0, get: function () { return vn.default } }), Object.defineProperty(e, 'booleanPointOnLine', { enumerable: !0, get: function () { return _n.default } }), Object.defineProperty(e, 'booleanEqual', { enumerable: !0, get: function () { return mn.default } }), Object.defineProperty(e, 'booleanWithin', { enumerable: !0, get: function () { return xn.default } }), Object.defineProperty(e, 'booleanIntersects', { enumerable: !0, get: function () { return bn.default } }), Object.defineProperty(e, 'clone', { enumerable: !0, get: function () { return En.default } }), Object.defineProperty(e, 'cleanCoords', { enumerable: !0, get: function () { return wn.default } }), Object.defineProperty(e, 'clustersDbscan', { enumerable: !0, get: function () { return In.default } }), Object.defineProperty(e, 'clustersKmeans', { enumerable: !0, get: function () { return Sn.default } }), Object.defineProperty(e, 'pointToLineDistance', { enumerable: !0, get: function () { return Nn.default } }), Object.defineProperty(e, 'booleanParallel', { enumerable: !0, get: function () { return Pn.default } }), Object.defineProperty(e, 'shortestPath', { enumerable: !0, get: function () { return Cn.default } }), Object.defineProperty(e, 'voronoi', { enumerable: !0, get: function () { return Mn.default } }), Object.defineProperty(e, 'ellipse', { enumerable: !0, get: function () { return On.default } }), Object.defineProperty(e, 'centerMean', { enumerable: !0, get: function () { return Ln.default } }), Object.defineProperty(e, 'centerMedian', { enumerable: !0, get: function () { return Rn.default } }), Object.defineProperty(e, 'standardDeviationalEllipse', { enumerable: !0, get: function () { return An.default } }), Object.defineProperty(e, 'angle', { enumerable: !0, get: function () { return Tn.default } }), Object.defineProperty(e, 'polygonSmooth', { enumerable: !0, get: function () { return Dn.default } }), Object.defineProperty(e, 'moranIndex', { enumerable: !0, get: function () { return Fn.default } }), Object.defineProperty(e, 'distanceWeight', { enumerable: !0, get: function () { return jn.default } }), e.projection = kn, e.random = Gn, e.clusters = qn, Object.defineProperty(e, 'bearingToAngle', { enumerable: !0, get: function () { return Bt.bearingToAzimuth } }), Object.defineProperty(e, 'convertDistance', { enumerable: !0, get: function () { return Bt.convertLength } }), Object.defineProperty(e, 'degrees2radians', { enumerable: !0, get: function () { return Bt.degreesToRadians } }), Object.defineProperty(e, 'distanceToDegrees', { enumerable: !0, get: function () { return Bt.lengthToDegrees } }), Object.defineProperty(e, 'distanceToRadians', { enumerable: !0, get: function () { return Bt.lengthToRadians } }), e.helpers = Bn, Object.defineProperty(e, 'radians2degrees', { enumerable: !0, get: function () { return Bt.radiansToDegrees } }), Object.defineProperty(e, 'radiansToDistance', { enumerable: !0, get: function () { return Bt.radiansToLength } }), e.invariant = zn, e.meta = Un, Object.defineProperty(e, 'difference', { enumerable: !0, get: function () { return Xn.default } }), Object.defineProperty(e, 'buffer', { enumerable: !0, get: function () { return Yn.default } }), Object.defineProperty(e, 'union', { enumerable: !0, get: function () { return Vn.default } }), Object.defineProperty(e, 'intersect', { enumerable: !0, get: function () { return Wn.default } }), Object.defineProperty(e, 'dissolve', { enumerable: !0, get: function () { return Hn.default } }), Object.defineProperty(e, 'hexGrid', { enumerable: !0, get: function () { return Jn.default } }), Object.defineProperty(e, 'mask', { enumerable: !0, get: function () { return Zn.default } }), Object.defineProperty(e, 'squareGrid', { enumerable: !0, get: function () { return Kn.default } }), Object.defineProperty(e, 'triangleGrid', { enumerable: !0, get: function () { return Qn.default } }), Object.defineProperty(e, 'interpolate', { enumerable: !0, get: function () { return $n.default } }) }, 1959: function (t, e, n) { 'use strict'; const r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, '__esModule', { value: !0 }); const i = r(n(2676)); const o = n(611); const s = n(4102); e.default = function (t, e, n) { void 0 === n && (n = {}); const r = o.getGeom(t); const a = o.getGeom(e); const u = i.default.union(r.coordinates, a.coordinates); return u.length === 0 ? null : u.length === 1 ? s.polygon(u[0], n.properties) : s.multiPolygon(u, n.properties) } }, 4404: (t, e, n) => { 'use strict'; const r = n(1540); const i = n(4102); const o = n(5510); const s = n(1070); const a = n(8147); function u (t) { return t && typeof t === 'object' && 'default' in t ? t : { default: t } } const l = u(o); const c = u(s); const f = u(a); function h (t, e) { if (!t || !e) return !1; if (t.length !== e.length) return !1; for (let n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) { if (!h(t[n], e[n])) return !1 } else if (t[n] !== e[n]) return !1; return !0 } function p (t) { if (t.type != 'Feature') throw new Error('The input must a geojson object of type Feature'); if (void 0 === t.geometry || t.geometry == null) throw new Error('The input must a geojson object with a non-empty geometry'); if (t.geometry.type != 'Polygon') throw new Error('The input must be a geojson Polygon'); for (var e = t.geometry.coordinates.length, n = [], r = 0; r < e; r++) { const o = t.geometry.coordinates[r]; _(o[0], o[o.length - 1]) || o.push(o[0]), n.push.apply(n, o.slice(0, o.length - 1)) } if (!(function (t) { for (var e = {}, n = 1, r = 0, i = t.length; r < i; ++r) { if (Object.prototype.hasOwnProperty.call(e, t[r])) { n = 0; break }e[t[r]] = 1 } return n }(n))) throw new Error('The input polygon may not have duplicate vertices (except for the first and last vertex of each ring)'); const s = n.length; const a = (function (t, e, n) { if (t.geometry.type !== 'Polygon') throw new Error('The input feature must be a Polygon'); void 0 === n && (n = 1); const r = t.geometry.coordinates; let i = []; const o = {}; if (n) { for (var s = [], a = 0; a < r.length; a++) for (let u = 0; u < r[a].length - 1; u++)s.push(v(a, u)); var c = l.default(); c.load(s) } for (var f = 0; f < r.length; f++) for (var p = 0; p < r[f].length - 1; p++) if (n)c.search(v(f, p)).forEach(function (t) { const e = t.ring; const n = t.edge; y(f, p, e, n) }); else for (let g = 0; g < r.length; g++) for (let d = 0; d < r[g].length - 1; d++)y(f, p, g, d); return e || (i = { type: 'Feature', geometry: { type: 'MultiPoint', coordinates: i } }), i; function y (t, n, s, a) { let u; let l; const c = r[t][n]; const f = r[t][n + 1]; const p = r[s][a]; const g = r[s][a + 1]; const d = (function (t, e, n, r) { if (h(t, n) || h(t, r) || h(e, n) || h(r, n)) return null; const i = t[0]; const o = t[1]; const s = e[0]; const a = e[1]; const u = n[0]; const l = n[1]; const c = r[0]; const f = r[1]; const p = (i - s) * (l - f) - (o - a) * (u - c); return p === 0 ? null : [((i * a - o * s) * (u - c) - (i - s) * (u * f - l * c)) / p, ((i * a - o * s) * (l - f) - (o - a) * (u * f - l * c)) / p] }(c, f, p, g)); if (d !== null && (u = f[0] !== c[0] ? (d[0] - c[0]) / (f[0] - c[0]) : (d[1] - c[1]) / (f[1] - c[1]), l = g[0] !== p[0] ? (d[0] - p[0]) / (g[0] - p[0]) : (d[1] - p[1]) / (g[1] - p[1]), !(u >= 1 || u <= 0 || l >= 1 || l <= 0))) { const y = d; const v = !o[y]; v && (o[y] = !0), e ? i.push(e(d, t, n, c, f, u, s, a, p, g, l, v)) : i.push(d) } } function v (t, e) { let n; let i; let o; let s; const a = r[t][e]; const u = r[t][e + 1]; return a[0] < u[0] ? (n = a[0], i = u[0]) : (n = u[0], i = a[0]), a[1] < u[1] ? (o = a[1], s = u[1]) : (o = u[1], s = a[1]), { minX: n, minY: o, maxX: i, maxY: s, ring: t, edge: e } } }(t, function (t, e, n, r, i, o, s, a, u, l, c, f) { return [t, e, n, r, i, o, s, a, u, l, c, f] })); const u = a.length; if (u == 0) { var p = []; for (r = 0; r < e; r++)p.push(i.polygon([t.geometry.coordinates[r]], { parent: -1, winding: v(t.geometry.coordinates[r]) })); var x = i.featureCollection(p); return W(), H(), x } const b = []; const E = []; for (r = 0; r < e; r++) { b.push([]); for (var w = 0; w < t.geometry.coordinates[r].length - 1; w++)b[r].push([new g(t.geometry.coordinates[r][m(w + 1, t.geometry.coordinates[r].length - 1)], 1, [r, w], [r, m(w + 1, t.geometry.coordinates[r].length - 1)], void 0)]), E.push(new d(t.geometry.coordinates[r][w], [r, m(w - 1, t.geometry.coordinates[r].length - 1)], [r, w], void 0, void 0, !1, !0)) } for (r = 0; r < u; r++)b[a[r][1]][a[r][2]].push(new g(a[r][0], a[r][5], [a[r][1], a[r][2]], [a[r][6], a[r][7]], void 0)), a[r][11] && E.push(new d(a[r][0], [a[r][1], a[r][2]], [a[r][6], a[r][7]], void 0, void 0, !0, !0)); const I = E.length; for (r = 0; r < b.length; r++) for (w = 0; w < b[r].length; w++)b[r][w].sort(function (t, e) { return t.param < e.param ? -1 : 1 }); const S = []; for (r = 0; r < I; r++)S.push({ minX: E[r].coord[0], minY: E[r].coord[1], maxX: E[r].coord[0], maxY: E[r].coord[1], index: r }); const N = l.default(); for (N.load(S), r = 0; r < b.length; r++) for (w = 0; w < b[r].length; w++) for (var P = 0; P < b[r][w].length; P++) { M = P == b[r][w].length - 1 ? b[r][m(w + 1, t.geometry.coordinates[r].length - 1)][0].coord : b[r][w][P + 1].coord; var C = N.search({ minX: M[0], minY: M[1], maxX: M[0], maxY: M[1] })[0]; b[r][w][P].nxtIsectAlongEdgeIn = C.index } for (r = 0; r < b.length; r++) for (w = 0; w < b[r].length; w++) for (P = 0; P < b[r][w].length; P++) { var M = b[r][w][P].coord; const O = (C = N.search({ minX: M[0], minY: M[1], maxX: M[0], maxY: M[1] })[0]).index; O < s ? E[O].nxtIsectAlongRingAndEdge2 = b[r][w][P].nxtIsectAlongEdgeIn : _(E[O].ringAndEdge1, b[r][w][P].ringAndEdgeIn) ? E[O].nxtIsectAlongRingAndEdge1 = b[r][w][P].nxtIsectAlongEdgeIn : E[O].nxtIsectAlongRingAndEdge2 = b[r][w][P].nxtIsectAlongEdgeIn } const L = []; for (r = 0, w = 0; w < e; w++) { let R = r; for (P = 0; P < t.geometry.coordinates[w].length - 1; P++)E[r].coord[0] < E[R].coord[0] && (R = r), r++; const A = E[R].nxtIsectAlongRingAndEdge2; for (P = 0; P < E.length; P++) if (E[P].nxtIsectAlongRingAndEdge1 == R || E[P].nxtIsectAlongRingAndEdge2 == R) { var T = P; break } const D = y([E[T].coord, E[R].coord, E[A].coord], !0) ? 1 : -1; L.push({ isect: R, parent: -1, winding: D }) } for (L.sort(function (t, e) { return E[t.isect].coord > E[e.isect].coord ? -1 : 1 }), p = []; L.length > 0;) { const F = L.pop(); const j = F.isect; const k = F.parent; const G = F.winding; const q = p.length; const B = [E[j].coord]; let z = j; if (E[j].ringAndEdge1Walkable) var U = E[j].ringAndEdge1, X = E[j].nxtIsectAlongRingAndEdge1; else U = E[j].ringAndEdge2, X = E[j].nxtIsectAlongRingAndEdge2; for (;!_(E[j].coord, E[X].coord);) { B.push(E[X].coord); let Y = void 0; for (r = 0; r < L.length; r++) if (L[r].isect == X) { Y = r; break } if (Y != null && L.splice(Y, 1), _(U, E[X].ringAndEdge1)) { if (U = E[X].ringAndEdge2, E[X].ringAndEdge2Walkable = !1, E[X].ringAndEdge1Walkable) { var V = { isect: X }; y([E[z].coord, E[X].coord, E[E[X].nxtIsectAlongRingAndEdge2].coord], G == 1) ? (V.parent = k, V.winding = -G) : (V.parent = q, V.winding = G), L.push(V) }z = X, X = E[X].nxtIsectAlongRingAndEdge2 } else U = E[X].ringAndEdge1, E[X].ringAndEdge1Walkable = !1, E[X].ringAndEdge2Walkable && (V = { isect: X }, y([E[z].coord, E[X].coord, E[E[X].nxtIsectAlongRingAndEdge1].coord], G == 1) ? (V.parent = k, V.winding = -G) : (V.parent = q, V.winding = G), L.push(V)), z = X, X = E[X].nxtIsectAlongRingAndEdge1 }B.push(E[X].coord), p.push(i.polygon([B], { index: q, parent: k, winding: G, netWinding: void 0 })) } function W () { for (var t = [], e = 0; e < x.features.length; e++)x.features[e].properties.parent == -1 && t.push(e); if (t.length > 1) for (e = 0; e < t.length; e++) { for (var n = -1, r = 0; r < x.features.length; r++)t[e] != r && f.default(x.features[t[e]].geometry.coordinates[0][0], x.features[r], { ignoreBoundary: !0 }) && c.default(x.features[r]) < 1 / 0 && (n = r); x.features[t[e]].properties.parent = n } } function H () { for (let t = 0; t < x.features.length; t++) if (x.features[t].properties.parent == -1) { const e = x.features[t].properties.winding; x.features[t].properties.netWinding = e, J(t, e) } } function J (t, e) { for (let n = 0; n < x.features.length; n++) if (x.features[n].properties.parent == t) { const r = e + x.features[n].properties.winding; x.features[n].properties.netWinding = r, J(n, r) } } return x = i.featureCollection(p), W(), H(), x } var g = function (t, e, n, r, i) { this.coord = t, this.param = e, this.ringAndEdgeIn = n, this.ringAndEdgeOut = r, this.nxtIsectAlongEdgeIn = i }; var d = function (t, e, n, r, i, o, s) { this.coord = t, this.ringAndEdge1 = e, this.ringAndEdge2 = n, this.nxtIsectAlongRingAndEdge1 = r, this.nxtIsectAlongRingAndEdge2 = i, this.ringAndEdge1Walkable = o, this.ringAndEdge2Walkable = s }; function y (t, e) { if (void 0 === e && (e = !0), t.length != 3) throw new Error('This function requires an array of three points [x,y]'); return (t[1][0] - t[0][0]) * (t[2][1] - t[0][1]) - (t[1][1] - t[0][1]) * (t[2][0] - t[0][0]) >= 0 == e } function v (t) { for (var e = 0, n = 0; n < t.length - 1; n++)t[n][0] < t[e][0] && (e = n); if (y([t[m(e - 1, t.length - 1)], t[e], t[m(e + 1, t.length - 1)]], !0)) var r = 1; else r = -1; return r } function _ (t, e) { if (!t || !e) return !1; if (t.length != e.length) return !1; for (let n = 0, r = t.length; n < r; n++) if (t[n] instanceof Array && e[n] instanceof Array) { if (!_(t[n], e[n])) return !1 } else if (t[n] != e[n]) return !1; return !0 } function m (t, e) { return (t % e + e) % e } function x (t) { const e = []; return r.flattenEach(t, function (t) { t.geometry.type === 'Polygon' && r.featureEach(p(t), function (n) { e.push(i.polygon(n.geometry.coordinates, t.properties)) }) }), i.featureCollection(e) }t.exports = x, t.exports.default = x }, 2276: (t, e, n) => { 'use strict'; const r = n(4102); const i = n(611); const o = n(1704); function s (t) { return (t = t.slice()).push(t[0]), r.polygon([t]) } function a (t, e) { if (e = e || {}, !r.isObject(e)) throw new Error('options is invalid'); const n = e.bbox || [-180, -85, 180, 85]; if (!t) throw new Error('points is required'); if (!Array.isArray(n)) throw new Error('bbox is invalid'); return i.collectionOf(t, 'Point', 'points'), r.featureCollection(o.voronoi().x(function (t) { return t.geometry.coordinates[0] }).y(function (t) { return t.geometry.coordinates[1] }).extent([[n[0], n[1]], [n[2], n[3]]]).polygons(t.features).map(s)) }t.exports = a, t.exports.default = a }, 1924: (t, e, n) => { 'use strict'; const r = n(210); const i = n(5559); const o = i(r('String.prototype.indexOf')); t.exports = function (t, e) { const n = r(t, !!e); return typeof n === 'function' && o(t, '.prototype.') > -1 ? i(n) : n } }, 5559: (t, e, n) => { 'use strict'; const r = n(8612); const i = n(210); const o = i('%Function.prototype.apply%'); const s = i('%Function.prototype.call%'); const a = i('%Reflect.apply%', !0) || r.call(s, o); const u = i('%Object.getOwnPropertyDescriptor%', !0); let l = i('%Object.defineProperty%', !0); const c = i('%Math.max%'); if (l) try { l({}, 'a', { value: 1 }) } catch (t) { l = null }t.exports = function (t) { const e = a(r, s, arguments); if (u && l) { const n = u(e, 'length'); n.configurable && l(e, 'length', { value: 1 + c(0, t.length - (arguments.length - 1)) }) } return e }; const f = function () { return a(r, o, arguments) }; l ? l(t.exports, 'apply', { value: f }) : t.exports.apply = f }, 2273: (t, e, n) => { 'use strict'; const r = n(1662); let i = n(3842); const o = n(6960); const s = n(8639).orient2d; function a (t, e, n) { e = Math.max(0, void 0 === e ? 2 : e), n = n || 0; const i = (function (t) { for (var e = t[0], n = t[0], r = t[0], i = t[0], s = 0; s < t.length; s++) { const a = t[s]; a[0] < e[0] && (e = a), a[0] > r[0] && (r = a), a[1] < n[1] && (n = a), a[1] > i[1] && (i = a) } const u = [e, n, r, i]; const l = u.slice(); for (s = 0; s < t.length; s++)o(t[s], u) || l.push(t[s]); return (function (t) { t.sort(m); for (var e = [], n = 0; n < t.length; n++) { for (;e.length >= 2 && p(e[e.length - 2], e[e.length - 1], t[n]) <= 0;)e.pop(); e.push(t[n]) } for (var r = [], i = t.length - 1; i >= 0; i--) { for (;r.length >= 2 && p(r[r.length - 2], r[r.length - 1], t[i]) <= 0;)r.pop(); r.push(t[i]) } return r.pop(), e.pop(), e.concat(r) }(l)) }(t)); const s = new r(16); s.toBBox = function (t) { return { minX: t[0], minY: t[1], maxX: t[0], maxY: t[1] } }, s.compareMinX = function (t, e) { return t[0] - e[0] }, s.compareMinY = function (t, e) { return t[1] - e[1] }, s.load(t); for (var a, l = [], c = 0; c < i.length; c++) { var f = i[c]; s.remove(f), a = d(f, a), l.push(a) } const h = new r(16); for (c = 0; c < l.length; c++)h.insert(g(l[c])); for (let v = e * e, _ = n * n; l.length;) { var x = l.shift(); const b = x.p; const E = x.next.p; const w = y(b, E); if (!(w < _)) { const I = w / v; (f = u(s, x.prev.p, b, E, x.next.next.p, I, h)) && Math.min(y(f, b), y(f, E)) <= I && (l.push(x), l.push(d(f, x)), s.remove(f), h.remove(x), h.insert(g(x)), h.insert(g(x.next))) } }x = a; const S = []; do { S.push(x.p), x = x.next } while (x !== a); return S.push(x.p), S } function u (t, e, n, r, o, s, a) { for (let u = new i([], l), f = t.data; f;) { for (let p = 0; p < f.children.length; p++) { const g = f.children[p]; const d = f.leaf ? v(g, n, r) : c(n, r, g); d > s || u.push({ node: g, dist: d }) } for (;u.length && !u.peek().node.children;) { const y = u.pop(); const _ = y.node; const m = v(_, e, n); const x = v(_, r, o); if (y.dist < m && y.dist < x && h(n, _, a) && h(r, _, a)) return _ }(f = u.pop()) && (f = f.node) } return null } function l (t, e) { return t.dist - e.dist } function c (t, e, n) { if (f(t, n) || f(e, n)) return 0; const r = _(t[0], t[1], e[0], e[1], n.minX, n.minY, n.maxX, n.minY); if (r === 0) return 0; const i = _(t[0], t[1], e[0], e[1], n.minX, n.minY, n.minX, n.maxY); if (i === 0) return 0; const o = _(t[0], t[1], e[0], e[1], n.maxX, n.minY, n.maxX, n.maxY); if (o === 0) return 0; const s = _(t[0], t[1], e[0], e[1], n.minX, n.maxY, n.maxX, n.maxY); return s === 0 ? 0 : Math.min(r, i, o, s) } function f (t, e) { return t[0] >= e.minX && t[0] <= e.maxX && t[1] >= e.minY && t[1] <= e.maxY } function h (t, e, n) { for (var r, i, o, s, a = Math.min(t[0], e[0]), u = Math.min(t[1], e[1]), l = Math.max(t[0], e[0]), c = Math.max(t[1], e[1]), f = n.search({ minX: a, minY: u, maxX: l, maxY: c }), h = 0; h < f.length; h++) if (r = f[h].p, i = f[h].next.p, o = t, r !== (s = e) && i !== o && p(r, i, o) > 0 != p(r, i, s) > 0 && p(o, s, r) > 0 != p(o, s, i) > 0) return !1; return !0 } function p (t, e, n) { return s(t[0], t[1], e[0], e[1], n[0], n[1]) } function g (t) { const e = t.p; const n = t.next.p; return t.minX = Math.min(e[0], n[0]), t.minY = Math.min(e[1], n[1]), t.maxX = Math.max(e[0], n[0]), t.maxY = Math.max(e[1], n[1]), t } function d (t, e) { const n = { p: t, prev: null, next: null, minX: 0, minY: 0, maxX: 0, maxY: 0 }; return e ? (n.next = e.next, n.prev = e, e.next.prev = n, e.next = n) : (n.prev = n, n.next = n), n } function y (t, e) { const n = t[0] - e[0]; const r = t[1] - e[1]; return n * n + r * r } function v (t, e, n) { let r = e[0]; let i = e[1]; let o = n[0] - r; let s = n[1] - i; if (o !== 0 || s !== 0) { const a = ((t[0] - r) * o + (t[1] - i) * s) / (o * o + s * s); a > 1 ? (r = n[0], i = n[1]) : a > 0 && (r += o * a, i += s * a) } return (o = t[0] - r) * o + (s = t[1] - i) * s } function _ (t, e, n, r, i, o, s, a) { let u; let l; let c; let f; const h = n - t; const p = r - e; const g = s - i; const d = a - o; const y = t - i; const v = e - o; const _ = h * h + p * p; const m = h * g + p * d; const x = g * g + d * d; const b = h * y + p * v; const E = g * y + d * v; const w = _ * x - m * m; let I = w; let S = w; w === 0 ? (l = 0, I = 1, f = E, S = x) : (f = _ * E - m * b, (l = m * E - x * b) < 0 ? (l = 0, f = E, S = x) : l > I && (l = I, f = E + m, S = x)), f < 0 ? (f = 0, -b < 0 ? l = 0 : -b > _ ? l = I : (l = -b, I = _)) : f > S && (f = S, -b + m < 0 ? l = 0 : -b + m > _ ? l = I : (l = -b + m, I = _)); const N = (1 - (c = f === 0 ? 0 : f / S)) * i + c * s - ((1 - (u = l === 0 ? 0 : l / I)) * t + u * n); const P = (1 - c) * o + c * a - ((1 - u) * e + u * r); return N * N + P * P } function m (t, e) { return t[0] === e[0] ? t[1] - e[1] : t[0] - e[0] }i.default && (i = i.default), t.exports = a, t.exports.default = a }, 1662: function (t) { t.exports = (function () { 'use strict'; function t (t, r, i, o, s) { !(function t (n, r, i, o, s) { for (;o > i;) { if (o - i > 600) { const a = o - i + 1; const u = r - i + 1; const l = Math.log(a); const c = 0.5 * Math.exp(2 * l / 3); const f = 0.5 * Math.sqrt(l * c * (a - c) / a) * (u - a / 2 < 0 ? -1 : 1); t(n, r, Math.max(i, Math.floor(r - u * c / a + f)), Math.min(o, Math.floor(r + (a - u) * c / a + f)), s) } const h = n[r]; let p = i; let g = o; for (e(n, i, r), s(n[o], h) > 0 && e(n, i, o); p < g;) { for (e(n, p, g), p++, g--; s(n[p], h) < 0;)p++; for (;s(n[g], h) > 0;)g-- }s(n[i], h) === 0 ? e(n, i, g) : e(n, ++g, o), g <= r && (i = g + 1), r <= g && (o = g - 1) } }(t, r, i || 0, o || t.length - 1, s || n)) } function e (t, e, n) { const r = t[e]; t[e] = t[n], t[n] = r } function n (t, e) { return t < e ? -1 : t > e ? 1 : 0 } const r = function (t) { void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear() }; function i (t, e, n) { if (!n) return e.indexOf(t); for (let r = 0; r < e.length; r++) if (n(t, e[r])) return r; return -1 } function o (t, e) { s(t, 0, t.children.length, e, t) } function s (t, e, n, r, i) { i || (i = g(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0; for (let o = e; o < n; o++) { const s = t.children[o]; a(i, t.leaf ? r(s) : s) } return i } function a (t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function u (t, e) { return t.minX - e.minX } function l (t, e) { return t.minY - e.minY } function c (t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function f (t) { return t.maxX - t.minX + (t.maxY - t.minY) } function h (t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function p (t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function g (t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function d (e, n, r, i, o) { for (let s = [n, r]; s.length;) if (!((r = s.pop()) - (n = s.pop()) <= i)) { const a = n + Math.ceil((r - n) / i / 2) * i; t(e, a, n, r, o), s.push(n, a, a, r) } } return r.prototype.all = function () { return this._all(this.data, []) }, r.prototype.search = function (t) { let e = this.data; const n = []; if (!p(t, e)) return n; for (let r = this.toBBox, i = []; e;) { for (let o = 0; o < e.children.length; o++) { const s = e.children[o]; const a = e.leaf ? r(s) : s; p(t, a) && (e.leaf ? n.push(s) : h(t, a) ? this._all(s, n) : i.push(s)) }e = i.pop() } return n }, r.prototype.collides = function (t) { let e = this.data; if (!p(t, e)) return !1; for (let n = []; e;) { for (let r = 0; r < e.children.length; r++) { const i = e.children[r]; const o = e.leaf ? this.toBBox(i) : i; if (p(t, o)) { if (e.leaf || h(t, o)) return !0; n.push(i) } }e = n.pop() } return !1 }, r.prototype.load = function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0; e < t.length; e++) this.insert(t[e]); return this } let n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { const r = this.data; this.data = n, n = r } this._insert(n, this.data.height - n.height - 1, !0) } else this.data = n; return this }, r.prototype.insert = function (t) { return t && this._insert(t, this.data.height - 1), this }, r.prototype.clear = function () { return this.data = g([]), this }, r.prototype.remove = function (t, e) { if (!t) return this; for (var n, r, o, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) { if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), o = !0), s.leaf) { const c = i(t, s.children, e); if (c !== -1) return s.children.splice(c, 1), u.push(s), this._condense(u), this }o || s.leaf || !h(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0]) } return this }, r.prototype.toBBox = function (t) { return t }, r.prototype.compareMinX = function (t, e) { return t.minX - e.minX }, r.prototype.compareMinY = function (t, e) { return t.minY - e.minY }, r.prototype.toJSON = function () { return this.data }, r.prototype.fromJSON = function (t) { return this.data = t, this }, r.prototype._all = function (t, e) { for (let n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, r.prototype._build = function (t, e, n, r) { let i; const s = n - e + 1; let a = this._maxEntries; if (s <= a) return o(i = g(t.slice(e, n + 1)), this.toBBox), i; r || (r = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, r - 1))), (i = g([])).leaf = !1, i.height = r; const u = Math.ceil(s / a); const l = u * Math.ceil(Math.sqrt(a)); d(t, e, n, l, this.compareMinX); for (let c = e; c <= n; c += l) { const f = Math.min(c + l - 1, n); d(t, c, f, u, this.compareMinY); for (let h = c; h <= f; h += u) { const p = Math.min(h + u - 1, f); i.children.push(this._build(t, h, p, r - 1)) } } return o(i, this.toBBox), i }, r.prototype._chooseSubtree = function (t, e, n, r) { for (;r.push(e), !e.leaf && r.length - 1 !== n;) { for (var i = 1 / 0, o = 1 / 0, s = void 0, a = 0; a < e.children.length; a++) { const u = e.children[a]; const l = c(u); const f = (h = t, p = u, (Math.max(p.maxX, h.maxX) - Math.min(p.minX, h.minX)) * (Math.max(p.maxY, h.maxY) - Math.min(p.minY, h.minY)) - l); f < o ? (o = f, i = l < i ? l : i, s = u) : f === o && l < i && (i = l, s = u) }e = s || e.children[0] } let h, p; return e }, r.prototype._insert = function (t, e, n) { const r = n ? t : this.toBBox(t); const i = []; const o = this._chooseSubtree(r, this.data, e, i); for (o.children.push(t), a(o, r); e >= 0 && i[e].children.length > this._maxEntries;) this._split(i, e), e--; this._adjustParentBBoxes(r, i, e) }, r.prototype._split = function (t, e) { const n = t[e]; const r = n.children.length; const i = this._minEntries; this._chooseSplitAxis(n, i, r); const s = this._chooseSplitIndex(n, i, r); const a = g(n.children.splice(s, n.children.length - s)); a.height = n.height, a.leaf = n.leaf, o(n, this.toBBox), o(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) }, r.prototype._splitRoot = function (t, e) { this.data = g([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox) }, r.prototype._chooseSplitIndex = function (t, e, n) { for (var r, i, o, a, u, l, f, h = 1 / 0, p = 1 / 0, g = e; g <= n - e; g++) { const d = s(t, 0, g, this.toBBox); const y = s(t, g, n, this.toBBox); const v = (i = d, o = y, void 0, void 0, void 0, void 0, a = Math.max(i.minX, o.minX), u = Math.max(i.minY, o.minY), l = Math.min(i.maxX, o.maxX), f = Math.min(i.maxY, o.maxY), Math.max(0, l - a) * Math.max(0, f - u)); const _ = c(d) + c(y); v < h ? (h = v, r = g, p = _ < p ? _ : p) : v === h && _ < p && (p = _, r = g) } return r || n - e }, r.prototype._chooseSplitAxis = function (t, e, n) { const r = t.leaf ? this.compareMinX : u; const i = t.leaf ? this.compareMinY : l; this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r) }, r.prototype._allDistMargin = function (t, e, n, r) { t.children.sort(r); for (var i = this.toBBox, o = s(t, 0, e, i), u = s(t, n - e, n, i), l = f(o) + f(u), c = e; c < n - e; c++) { const h = t.children[c]; a(o, t.leaf ? i(h) : h), l += f(o) } for (let p = n - e - 1; p >= e; p--) { const g = t.children[p]; a(u, t.leaf ? i(g) : g), l += f(u) } return l }, r.prototype._adjustParentBBoxes = function (t, e, n) { for (let r = n; r >= 0; r--)a(e[r], t) }, r.prototype._condense = function (t) { for (let e = t.length - 1, n = void 0; e >= 0; e--)t[e].children.length === 0 ? e > 0 ? (n = t[e - 1].children).splice(n.indexOf(t[e]), 1) : this.clear() : o(t[e], this.toBBox) }, r }()) }, 1688: (t, e, n) => { 'use strict'; function r () { return new i() } function i () { this.reset() }n.r(e), n.d(e, { geoAlbers: () => br, geoAlbersUsa: () => Er, geoArea: () => H, geoAzimuthalEqualArea: () => Nr, geoAzimuthalEqualAreaRaw: () => Sr, geoAzimuthalEquidistant: () => Cr, geoAzimuthalEquidistantRaw: () => Pr, geoBounds: () => qt, geoCentroid: () => te, geoCircle: () => fe, geoClipExtent: () => Ie, geoConicConformal: () => Tr, geoConicConformalRaw: () => Ar, geoConicEqualArea: () => xr, geoConicEqualAreaRaw: () => mr, geoConicEquidistant: () => kr, geoConicEquidistantRaw: () => jr, geoContains: () => We, geoDistance: () => ke, geoEquirectangular: () => Fr, geoEquirectangularRaw: () => Dr, geoGnomonic: () => qr, geoGnomonicRaw: () => Gr, geoGraticule: () => Ze, geoGraticule10: () => Ke, geoIdentity: () => zr, geoInterpolate: () => Qe, geoLength: () => De, geoMercator: () => Or, geoMercatorRaw: () => Mr, geoNaturalEarth1: () => Xr, geoNaturalEarth1Raw: () => Ur, geoOrthographic: () => Vr, geoOrthographicRaw: () => Yr, geoPath: () => nr, geoProjection: () => yr, geoProjectionMutator: () => vr, geoRotation: () => ue, geoStereographic: () => Hr, geoStereographicRaw: () => Wr, geoStream: () => D, geoTransform: () => ur, geoTransverseMercator: () => Zr, geoTransverseMercatorRaw: () => Jr }), i.prototype = { constructor: i, reset: function () { this.s = this.t = 0 }, add: function (t) { s(o, t, this.t), s(this, o.s, this.s), this.s ? this.t += o.t : this.s = o.t }, valueOf: function () { return this.s } }; var o = new i(); function s (t, e, n) { const r = t.s = e + n; const i = r - e; const o = r - i; t.t = e - o + (n - i) } const a = 1e-6; const u = Math.PI; const l = u / 2; const c = u / 4; const f = 2 * u; const h = 180 / u; const p = u / 180; const g = Math.abs; const d = Math.atan; const y = Math.atan2; const v = Math.cos; const _ = Math.ceil; const m = Math.exp; const x = (Math.floor, Math.log); const b = Math.pow; const E = Math.sin; const w = Math.sign || function (t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }; const I = Math.sqrt; const S = Math.tan; function N (t) { return t > 1 ? 0 : t < -1 ? u : Math.acos(t) } function P (t) { return t > 1 ? l : t < -1 ? -l : Math.asin(t) } function C (t) { return (t = E(t / 2)) * t } function M () {} function O (t, e) { t && R.hasOwnProperty(t.type) && R[t.type](t, e) } const L = { Feature: function (t, e) { O(t.geometry, e) }, FeatureCollection: function (t, e) { for (let n = t.features, r = -1, i = n.length; ++r < i;)O(n[r].geometry, e) } }; var R = { Sphere: function (t, e) { e.sphere() }, Point: function (t, e) { t = t.coordinates, e.point(t[0], t[1], t[2]) }, MultiPoint: function (t, e) { for (let n = t.coordinates, r = -1, i = n.length; ++r < i;)t = n[r], e.point(t[0], t[1], t[2]) }, LineString: function (t, e) { A(t.coordinates, e, 0) }, MultiLineString: function (t, e) { for (let n = t.coordinates, r = -1, i = n.length; ++r < i;)A(n[r], e, 0) }, Polygon: function (t, e) { T(t.coordinates, e) }, MultiPolygon: function (t, e) { for (let n = t.coordinates, r = -1, i = n.length; ++r < i;)T(n[r], e) }, GeometryCollection: function (t, e) { for (let n = t.geometries, r = -1, i = n.length; ++r < i;)O(n[r], e) } }; function A (t, e, n) { let r; let i = -1; const o = t.length - n; for (e.lineStart(); ++i < o;)r = t[i], e.point(r[0], r[1], r[2]); e.lineEnd() } function T (t, e) { let n = -1; const r = t.length; for (e.polygonStart(); ++n < r;)A(t[n], e, 1); e.polygonEnd() } function D (t, e) { t && L.hasOwnProperty(t.type) ? L[t.type](t, e) : O(t, e) } let F; let j; let k; let G; let q; const B = r(); const z = r(); var U = { point: M, lineStart: M, lineEnd: M, polygonStart: function () { B.reset(), U.lineStart = X, U.lineEnd = Y }, polygonEnd: function () { const t = +B; z.add(t < 0 ? f + t : t), this.lineStart = this.lineEnd = this.point = M }, sphere: function () { z.add(f) } }; function X () { U.point = V } function Y () { W(F, j) } function V (t, e) { U.point = W, F = t, j = e, k = t *= p, G = v(e = (e *= p) / 2 + c), q = E(e) } function W (t, e) { const n = (t *= p) - k; const r = n >= 0 ? 1 : -1; const i = r * n; const o = v(e = (e *= p) / 2 + c); const s = E(e); const a = q * s; const u = G * o + a * v(i); const l = a * r * E(i); B.add(y(l, u)), k = t, G = o, q = s } function H (t) { return z.reset(), D(t, U), 2 * z } function J (t) { return [y(t[1], t[0]), P(t[2])] } function Z (t) { const e = t[0]; const n = t[1]; const r = v(n); return [r * v(e), r * E(e), E(n)] } function K (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] } function Q (t, e) { return [t[1] * e[2] - t[2] * e[1], t[2] * e[0] - t[0] * e[2], t[0] * e[1] - t[1] * e[0]] } function $ (t, e) { t[0] += e[0], t[1] += e[1], t[2] += e[2] } function tt (t, e) { return [t[0] * e, t[1] * e, t[2] * e] } function et (t) { const e = I(t[0] * t[0] + t[1] * t[1] + t[2] * t[2]); t[0] /= e, t[1] /= e, t[2] /= e } let nt; let rt; let it; let ot; let st; let at; let ut; let lt; let ct; let ft; let ht; let pt; let gt; let dt; let yt; let vt; let _t; let mt; let xt; let bt; let Et; let wt; let It; let St; let Nt; let Pt; const Ct = r(); var Mt = { point: Ot, lineStart: Rt, lineEnd: At, polygonStart: function () { Mt.point = Tt, Mt.lineStart = Dt, Mt.lineEnd = Ft, Ct.reset(), U.polygonStart() }, polygonEnd: function () { U.polygonEnd(), Mt.point = Ot, Mt.lineStart = Rt, Mt.lineEnd = At, B < 0 ? (nt = -(it = 180), rt = -(ot = 90)) : Ct > a ? ot = 90 : Ct < -a && (rt = -90), ft[0] = nt, ft[1] = it } }; function Ot (t, e) { ct.push(ft = [nt = t, it = t]), e < rt && (rt = e), e > ot && (ot = e) } function Lt (t, e) { const n = Z([t * p, e * p]); if (lt) { const r = Q(lt, n); let i = Q([r[1], -r[0], 0], r); et(i), i = J(i); let o; const s = t - st; const a = s > 0 ? 1 : -1; let u = i[0] * h * a; const l = g(s) > 180; l ^ (a * st < u && u < a * t) ? (o = i[1] * h) > ot && (ot = o) : l ^ (a * st < (u = (u + 360) % 360 - 180) && u < a * t) ? (o = -i[1] * h) < rt && (rt = o) : (e < rt && (rt = e), e > ot && (ot = e)), l ? t < st ? jt(nt, t) > jt(nt, it) && (it = t) : jt(t, it) > jt(nt, it) && (nt = t) : it >= nt ? (t < nt && (nt = t), t > it && (it = t)) : t > st ? jt(nt, t) > jt(nt, it) && (it = t) : jt(t, it) > jt(nt, it) && (nt = t) } else ct.push(ft = [nt = t, it = t]); e < rt && (rt = e), e > ot && (ot = e), lt = n, st = t } function Rt () { Mt.point = Lt } function At () { ft[0] = nt, ft[1] = it, Mt.point = Ot, lt = null } function Tt (t, e) { if (lt) { const n = t - st; Ct.add(g(n) > 180 ? n + (n > 0 ? 360 : -360) : n) } else at = t, ut = e; U.point(t, e), Lt(t, e) } function Dt () { U.lineStart() } function Ft () { Tt(at, ut), U.lineEnd(), g(Ct) > a && (nt = -(it = 180)), ft[0] = nt, ft[1] = it, lt = null } function jt (t, e) { return (e -= t) < 0 ? e + 360 : e } function kt (t, e) { return t[0] - e[0] } function Gt (t, e) { return t[0] <= t[1] ? t[0] <= e && e <= t[1] : e < t[0] || t[1] < e } function qt (t) { let e, n, r, i, o, s, a; if (ot = it = -(nt = rt = 1 / 0), ct = [], D(t, Mt), n = ct.length) { for (ct.sort(kt), e = 1, o = [r = ct[0]]; e < n; ++e)Gt(r, (i = ct[e])[0]) || Gt(r, i[1]) ? (jt(r[0], i[1]) > jt(r[0], r[1]) && (r[1] = i[1]), jt(i[0], r[1]) > jt(r[0], r[1]) && (r[0] = i[0])) : o.push(r = i); for (s = -1 / 0, e = 0, r = o[n = o.length - 1]; e <= n; r = i, ++e)i = o[e], (a = jt(r[1], i[0])) > s && (s = a, nt = i[0], it = r[1]) } return ct = ft = null, nt === 1 / 0 || rt === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[nt, rt], [it, ot]] } let Bt; let zt; var Ut = { sphere: M, point: Xt, lineStart: Vt, lineEnd: Jt, polygonStart: function () { Ut.lineStart = Zt, Ut.lineEnd = Kt }, polygonEnd: function () { Ut.lineStart = Vt, Ut.lineEnd = Jt } }; function Xt (t, e) { t *= p; const n = v(e *= p); Yt(n * v(t), n * E(t), E(e)) } function Yt (t, e, n) { ++ht, gt += (t - gt) / ht, dt += (e - dt) / ht, yt += (n - yt) / ht } function Vt () { Ut.point = Wt } function Wt (t, e) { t *= p; const n = v(e *= p); St = n * v(t), Nt = n * E(t), Pt = E(e), Ut.point = Ht, Yt(St, Nt, Pt) } function Ht (t, e) { t *= p; const n = v(e *= p); const r = n * v(t); const i = n * E(t); const o = E(e); var s = y(I((s = Nt * o - Pt * i) * s + (s = Pt * r - St * o) * s + (s = St * i - Nt * r) * s), St * r + Nt * i + Pt * o); pt += s, vt += s * (St + (St = r)), _t += s * (Nt + (Nt = i)), mt += s * (Pt + (Pt = o)), Yt(St, Nt, Pt) } function Jt () { Ut.point = Xt } function Zt () { Ut.point = Qt } function Kt () { $t(wt, It), Ut.point = Xt } function Qt (t, e) { wt = t, It = e, t *= p, e *= p, Ut.point = $t; const n = v(e); St = n * v(t), Nt = n * E(t), Pt = E(e), Yt(St, Nt, Pt) } function $t (t, e) { t *= p; const n = v(e *= p); const r = n * v(t); const i = n * E(t); const o = E(e); const s = Nt * o - Pt * i; const a = Pt * r - St * o; const u = St * i - Nt * r; const l = I(s * s + a * a + u * u); const c = P(l); const f = l && -c / l; xt += f * s, bt += f * a, Et += f * u, pt += c, vt += c * (St + (St = r)), _t += c * (Nt + (Nt = i)), mt += c * (Pt + (Pt = o)), Yt(St, Nt, Pt) } function te (t) { ht = pt = gt = dt = yt = vt = _t = mt = xt = bt = Et = 0, D(t, Ut); let e = xt; let n = bt; let r = Et; let i = e * e + n * n + r * r; return i < 1e-12 && (e = vt, n = _t, r = mt, pt < a && (e = gt, n = dt, r = yt), (i = e * e + n * n + r * r) < 1e-12) ? [NaN, NaN] : [y(n, e) * h, P(r / I(i)) * h] } function ee (t) { return function () { return t } } function ne (t, e) { function n (n, r) { return n = t(n, r), e(n[0], n[1]) } return t.invert && e.invert && (n.invert = function (n, r) { return (n = e.invert(n, r)) && t.invert(n[0], n[1]) }), n } function re (t, e) { return [t > u ? t - f : t < -u ? t + f : t, e] } function ie (t, e, n) { return (t %= f) ? e || n ? ne(se(t), ae(e, n)) : se(t) : e || n ? ae(e, n) : re } function oe (t) { return function (e, n) { return [(e += t) > u ? e - f : e < -u ? e + f : e, n] } } function se (t) { const e = oe(t); return e.invert = oe(-t), e } function ae (t, e) { const n = v(t); const r = E(t); const i = v(e); const o = E(e); function s (t, e) { const s = v(e); const a = v(t) * s; const u = E(t) * s; const l = E(e); const c = l * n + a * r; return [y(u * i - c * o, a * n - l * r), P(c * i + u * o)] } return s.invert = function (t, e) { const s = v(e); const a = v(t) * s; const u = E(t) * s; const l = E(e); const c = l * i - u * o; return [y(u * i + l * o, a * n + c * r), P(c * n - a * r)] }, s } function ue (t) { function e (e) { return (e = t(e[0] * p, e[1] * p))[0] *= h, e[1] *= h, e } return t = ie(t[0] * p, t[1] * p, t.length > 2 ? t[2] * p : 0), e.invert = function (e) { return (e = t.invert(e[0] * p, e[1] * p))[0] *= h, e[1] *= h, e }, e } function le (t, e, n, r, i, o) { if (n) { const s = v(e); const a = E(e); const u = r * n; i == null ? (i = e + r * f, o = e - u / 2) : (i = ce(s, i), o = ce(s, o), (r > 0 ? i < o : i > o) && (i += r * f)); for (var l, c = i; r > 0 ? c > o : c < o; c -= u)l = J([s, -a * v(c), -a * E(c)]), t.point(l[0], l[1]) } } function ce (t, e) { (e = Z(e))[0] -= t, et(e); const n = N(-e[1]); return ((-e[2] < 0 ? -n : n) + f - a) % f } function fe () { let t; let e; let n = ee([0, 0]); let r = ee(90); let i = ee(6); const o = { point: function (n, r) { t.push(n = e(n, r)), n[0] *= h, n[1] *= h } }; function s () { let s = n.apply(this, arguments); const a = r.apply(this, arguments) * p; const u = i.apply(this, arguments) * p; return t = [], e = ie(-s[0] * p, -s[1] * p, 0).invert, le(o, a, u, 1), s = { type: 'Polygon', coordinates: [t] }, t = e = null, s } return s.center = function (t) { return arguments.length ? (n = typeof t === 'function' ? t : ee([+t[0], +t[1]]), s) : n }, s.radius = function (t) { return arguments.length ? (r = typeof t === 'function' ? t : ee(+t), s) : r }, s.precision = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : ee(+t), s) : i }, s } function he () { let t; let e = []; return { point: function (e, n) { t.push([e, n]) }, lineStart: function () { e.push(t = []) }, lineEnd: M, rejoin: function () { e.length > 1 && e.push(e.pop().concat(e.shift())) }, result: function () { const n = e; return e = [], t = null, n } } } function pe (t, e) { return g(t[0] - e[0]) < a && g(t[1] - e[1]) < a } function ge (t, e, n, r) { this.x = t, this.z = e, this.o = n, this.e = r, this.v = !1, this.n = this.p = null } function de (t, e, n, r, i) { let o; let s; const a = []; const u = []; if (t.forEach(function (t) { if (!((e = t.length - 1) <= 0)) { var e; let n; let r = t[0]; const s = t[e]; if (pe(r, s)) { for (i.lineStart(), o = 0; o < e; ++o)i.point((r = t[o])[0], r[1]); i.lineEnd() } else a.push(n = new ge(r, t, null, !0)), u.push(n.o = new ge(r, null, n, !1)), a.push(n = new ge(s, t, null, !1)), u.push(n.o = new ge(s, null, n, !0)) } }), a.length) { for (u.sort(e), ye(a), ye(u), o = 0, s = u.length; o < s; ++o)u[o].e = n = !n; for (var l, c, f = a[0]; ;) { for (var h = f, p = !0; h.v;) if ((h = h.n) === f) return; l = h.z, i.lineStart(); do { if (h.v = h.o.v = !0, h.e) { if (p) for (o = 0, s = l.length; o < s; ++o)i.point((c = l[o])[0], c[1]); else r(h.x, h.n.x, 1, i); h = h.n } else { if (p) for (l = h.p.z, o = l.length - 1; o >= 0; --o)i.point((c = l[o])[0], c[1]); else r(h.x, h.p.x, -1, i); h = h.p }l = (h = h.o).z, p = !p } while (!h.v); i.lineEnd() } } } function ye (t) { if (e = t.length) { for (var e, n, r = 0, i = t[0]; ++r < e;)i.n = n = t[r], n.p = i, i = n; i.n = n = t[0], n.p = i } } function ve (t, e) { return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN }re.invert = re, (Bt = ve).length === 1 && (zt = Bt, Bt = function (t, e) { return ve(zt(t), e) }); const _e = Array.prototype; function me (t) { for (var e, n, r, i = t.length, o = -1, s = 0; ++o < i;)s += t[o].length; for (n = new Array(s); --i >= 0;) for (e = (r = t[i]).length; --e >= 0;)n[--s] = r[e]; return n } function xe (t, e, n) { t = +t, e = +e, n = (i = arguments.length) < 2 ? (e = t, t = 0, 1) : i < 3 ? 1 : +n; for (var r = -1, i = 0 | Math.max(0, Math.ceil((e - t) / n)), o = new Array(i); ++r < i;)o[r] = t + r * n; return o }_e.slice, _e.map, Math.sqrt(50), Math.sqrt(10), Math.sqrt(2); const be = 1e9; const Ee = -be; function we (t, e, n, r) { function i (i, o) { return t <= i && i <= n && e <= o && o <= r } function o (i, o, a, u) { let c = 0; let f = 0; if (i == null || (c = s(i, a)) !== (f = s(o, a)) || l(i, o) < 0 ^ a > 0) do { u.point(c === 0 || c === 3 ? t : n, c > 1 ? r : e) } while ((c = (c + a + 4) % 4) !== f); else u.point(o[0], o[1]) } function s (r, i) { return g(r[0] - t) < a ? i > 0 ? 0 : 3 : g(r[0] - n) < a ? i > 0 ? 2 : 1 : g(r[1] - e) < a ? i > 0 ? 1 : 0 : i > 0 ? 3 : 2 } function u (t, e) { return l(t.x, e.x) } function l (t, e) { const n = s(t, 1); const r = s(e, 1); return n !== r ? n - r : n === 0 ? e[1] - t[1] : n === 1 ? t[0] - e[0] : n === 2 ? t[1] - e[1] : e[0] - t[0] } return function (s) { let a; let l; let c; let f; let h; let p; let g; let d; let y; let v; let _; let m = s; const x = he(); var b = { point: E, lineStart: function () { b.point = w, l && l.push(c = []), v = !0, y = !1, g = d = NaN }, lineEnd: function () { a && (w(f, h), p && y && x.rejoin(), a.push(x.result())), b.point = E, y && m.lineEnd() }, polygonStart: function () { m = x, a = [], l = [], _ = !0 }, polygonEnd: function () { const e = (function () { for (var e = 0, n = 0, i = l.length; n < i; ++n) for (var o, s, a = l[n], u = 1, c = a.length, f = a[0], h = f[0], p = f[1]; u < c; ++u)o = h, s = p, h = (f = a[u])[0], p = f[1], s <= r ? p > r && (h - o) * (r - s) > (p - s) * (t - o) && ++e : p <= r && (h - o) * (r - s) < (p - s) * (t - o) && --e; return e }()); const n = _ && e; const i = (a = me(a)).length; (n || i) && (s.polygonStart(), n && (s.lineStart(), o(null, null, 1, s), s.lineEnd()), i && de(a, u, e, o, s), s.polygonEnd()), m = s, a = l = c = null } }; function E (t, e) { i(t, e) && m.point(t, e) } function w (o, s) { const a = i(o, s); if (l && c.push([o, s]), v)f = o, h = s, p = a, v = !1, a && (m.lineStart(), m.point(o, s)); else if (a && y)m.point(o, s); else { const u = [g = Math.max(Ee, Math.min(be, g)), d = Math.max(Ee, Math.min(be, d))]; const x = [o = Math.max(Ee, Math.min(be, o)), s = Math.max(Ee, Math.min(be, s))]; !(function (t, e, n, r, i, o) { let s; const a = t[0]; const u = t[1]; let l = 0; let c = 1; const f = e[0] - a; const h = e[1] - u; if (s = n - a, f || !(s > 0)) { if (s /= f, f < 0) { if (s < l) return; s < c && (c = s) } else if (f > 0) { if (s > c) return; s > l && (l = s) } if (s = i - a, f || !(s < 0)) { if (s /= f, f < 0) { if (s > c) return; s > l && (l = s) } else if (f > 0) { if (s < l) return; s < c && (c = s) } if (s = r - u, h || !(s > 0)) { if (s /= h, h < 0) { if (s < l) return; s < c && (c = s) } else if (h > 0) { if (s > c) return; s > l && (l = s) } if (s = o - u, h || !(s < 0)) { if (s /= h, h < 0) { if (s > c) return; s > l && (l = s) } else if (h > 0) { if (s < l) return; s < c && (c = s) } return l > 0 && (t[0] = a + l * f, t[1] = u + l * h), c < 1 && (e[0] = a + c * f, e[1] = u + c * h), !0 } } } } }(u, x, t, e, n, r)) ? a && (m.lineStart(), m.point(o, s), _ = !1) : (y || (m.lineStart(), m.point(u[0], u[1])), m.point(x[0], x[1]), a || m.lineEnd(), _ = !1) }g = o, d = s, y = a } return b } } function Ie () { let t; let e; let n; let r = 0; let i = 0; let o = 960; let s = 500; return n = { stream: function (n) { return t && e === n ? t : t = we(r, i, o, s)(e = n) }, extent: function (a) { return arguments.length ? (r = +a[0][0], i = +a[0][1], o = +a[1][0], s = +a[1][1], t = e = null, n) : [[r, i], [o, s]] } } } const Se = r(); function Ne (t, e) { const n = e[0]; const r = e[1]; const i = [E(n), -v(n), 0]; let o = 0; let s = 0; Se.reset(); for (let l = 0, h = t.length; l < h; ++l) if (g = (p = t[l]).length) for (var p, g, d = p[g - 1], _ = d[0], m = d[1] / 2 + c, x = E(m), b = v(m), w = 0; w < g; ++w, _ = S, x = C, b = M, d = I) { var I = p[w]; var S = I[0]; const N = I[1] / 2 + c; var C = E(N); var M = v(N); const O = S - _; const L = O >= 0 ? 1 : -1; const R = L * O; const A = R > u; const T = x * C; if (Se.add(y(T * L * E(R), b * M + T * v(R))), o += A ? O + L * f : O, A ^ _ >= n ^ S >= n) { const D = Q(Z(d), Z(I)); et(D); const F = Q(i, D); et(F); const j = (A ^ O >= 0 ? -1 : 1) * P(F[2]); (r > j || r === j && (D[0] || D[1])) && (s += A ^ O >= 0 ? 1 : -1) } } return (o < -a || o < a && Se < -a) ^ 1 & s } let Pe; let Ce; let Me; const Oe = r(); var Le = { sphere: M, point: M, lineStart: function () { Le.point = Ae, Le.lineEnd = Re }, lineEnd: M, polygonStart: M, polygonEnd: M }; function Re () { Le.point = Le.lineEnd = M } function Ae (t, e) { Pe = t *= p, Ce = E(e *= p), Me = v(e), Le.point = Te } function Te (t, e) { t *= p; const n = E(e *= p); const r = v(e); const i = g(t - Pe); const o = v(i); const s = r * E(i); const a = Me * n - Ce * r * o; const u = Ce * n + Me * r * o; Oe.add(y(I(s * s + a * a), u)), Pe = t, Ce = n, Me = r } function De (t) { return Oe.reset(), D(t, Le), +Oe } const Fe = [null, null]; const je = { type: 'LineString', coordinates: Fe }; function ke (t, e) { return Fe[0] = t, Fe[1] = e, De(je) } const Ge = { Feature: function (t, e) { return Be(t.geometry, e) }, FeatureCollection: function (t, e) { for (let n = t.features, r = -1, i = n.length; ++r < i;) if (Be(n[r].geometry, e)) return !0; return !1 } }; const qe = { Sphere: function () { return !0 }, Point: function (t, e) { return ze(t.coordinates, e) }, MultiPoint: function (t, e) { for (let n = t.coordinates, r = -1, i = n.length; ++r < i;) if (ze(n[r], e)) return !0; return !1 }, LineString: function (t, e) { return Ue(t.coordinates, e) }, MultiLineString: function (t, e) { for (let n = t.coordinates, r = -1, i = n.length; ++r < i;) if (Ue(n[r], e)) return !0; return !1 }, Polygon: function (t, e) { return Xe(t.coordinates, e) }, MultiPolygon: function (t, e) { for (let n = t.coordinates, r = -1, i = n.length; ++r < i;) if (Xe(n[r], e)) return !0; return !1 }, GeometryCollection: function (t, e) { for (let n = t.geometries, r = -1, i = n.length; ++r < i;) if (Be(n[r], e)) return !0; return !1 } }; function Be (t, e) { return !(!t || !qe.hasOwnProperty(t.type)) && qe[t.type](t, e) } function ze (t, e) { return ke(t, e) === 0 } function Ue (t, e) { const n = ke(t[0], t[1]); return ke(t[0], e) + ke(e, t[1]) <= n + a } function Xe (t, e) { return !!Ne(t.map(Ye), Ve(e)) } function Ye (t) { return (t = t.map(Ve)).pop(), t } function Ve (t) { return [t[0] * p, t[1] * p] } function We (t, e) { return (t && Ge.hasOwnProperty(t.type) ? Ge[t.type] : Be)(t, e) } function He (t, e, n) { const r = xe(t, e - a, n).concat(e); return function (t) { return r.map(function (e) { return [t, e] }) } } function Je (t, e, n) { const r = xe(t, e - a, n).concat(e); return function (t) { return r.map(function (e) { return [e, t] }) } } function Ze () { let t; let e; let n; let r; let i; let o; let s; let u; let l; let c; let f; let h; let p = 10; let d = p; let y = 90; let v = 360; let m = 2.5; function x () { return { type: 'MultiLineString', coordinates: b() } } function b () { return xe(_(r / y) * y, n, y).map(f).concat(xe(_(u / v) * v, s, v).map(h)).concat(xe(_(e / p) * p, t, p).filter(function (t) { return g(t % y) > a }).map(l)).concat(xe(_(o / d) * d, i, d).filter(function (t) { return g(t % v) > a }).map(c)) } return x.lines = function () { return b().map(function (t) { return { type: 'LineString', coordinates: t } }) }, x.outline = function () { return { type: 'Polygon', coordinates: [f(r).concat(h(s).slice(1), f(n).reverse().slice(1), h(u).reverse().slice(1))] } }, x.extent = function (t) { return arguments.length ? x.extentMajor(t).extentMinor(t) : x.extentMinor() }, x.extentMajor = function (t) { return arguments.length ? (r = +t[0][0], n = +t[1][0], u = +t[0][1], s = +t[1][1], r > n && (t = r, r = n, n = t), u > s && (t = u, u = s, s = t), x.precision(m)) : [[r, u], [n, s]] }, x.extentMinor = function (n) { return arguments.length ? (e = +n[0][0], t = +n[1][0], o = +n[0][1], i = +n[1][1], e > t && (n = e, e = t, t = n), o > i && (n = o, o = i, i = n), x.precision(m)) : [[e, o], [t, i]] }, x.step = function (t) { return arguments.length ? x.stepMajor(t).stepMinor(t) : x.stepMinor() }, x.stepMajor = function (t) { return arguments.length ? (y = +t[0], v = +t[1], x) : [y, v] }, x.stepMinor = function (t) { return arguments.length ? (p = +t[0], d = +t[1], x) : [p, d] }, x.precision = function (a) { return arguments.length ? (m = +a, l = He(o, i, 90), c = Je(e, t, m), f = He(u, s, 90), h = Je(r, n, m), x) : m }, x.extentMajor([[-180, -89.999999], [180, 89.999999]]).extentMinor([[-180, -80.000001], [180, 80.000001]]) } function Ke () { return Ze()() } function Qe (t, e) { const n = t[0] * p; const r = t[1] * p; const i = e[0] * p; const o = e[1] * p; const s = v(r); const a = E(r); const u = v(o); const l = E(o); const c = s * v(n); const f = s * E(n); const g = u * v(i); const d = u * E(i); const _ = 2 * P(I(C(o - r) + s * u * C(i - n))); const m = E(_); const x = _ ? function (t) { const e = E(t *= _) / m; const n = E(_ - t) / m; const r = n * c + e * g; const i = n * f + e * d; const o = n * a + e * l; return [y(i, r) * h, y(o, I(r * r + i * i)) * h] } : function () { return [n * h, r * h] }; return x.distance = _, x } function $e (t) { return t } let tn; let en; let nn; let rn; const on = r(); const sn = r(); var an = { point: M, lineStart: M, lineEnd: M, polygonStart: function () { an.lineStart = un, an.lineEnd = fn }, polygonEnd: function () { an.lineStart = an.lineEnd = an.point = M, on.add(g(sn)), sn.reset() }, result: function () { const t = on / 2; return on.reset(), t } }; function un () { an.point = ln } function ln (t, e) { an.point = cn, tn = nn = t, en = rn = e } function cn (t, e) { sn.add(rn * t - nn * e), nn = t, rn = e } function fn () { cn(tn, en) } const hn = an; let pn = 1 / 0; let gn = pn; let dn = -pn; let yn = dn; const vn = { point: function (t, e) { t < pn && (pn = t), t > dn && (dn = t), e < gn && (gn = e), e > yn && (yn = e) }, lineStart: M, lineEnd: M, polygonStart: M, polygonEnd: M, result: function () { const t = [[pn, gn], [dn, yn]]; return dn = yn = -(gn = pn = 1 / 0), t } }; const _n = vn; let mn; let xn; let bn; let En; let wn = 0; let In = 0; let Sn = 0; let Nn = 0; let Pn = 0; let Cn = 0; let Mn = 0; let On = 0; let Ln = 0; var Rn = { point: An, lineStart: Tn, lineEnd: jn, polygonStart: function () { Rn.lineStart = kn, Rn.lineEnd = Gn }, polygonEnd: function () { Rn.point = An, Rn.lineStart = Tn, Rn.lineEnd = jn }, result: function () { const t = Ln ? [Mn / Ln, On / Ln] : Cn ? [Nn / Cn, Pn / Cn] : Sn ? [wn / Sn, In / Sn] : [NaN, NaN]; return wn = In = Sn = Nn = Pn = Cn = Mn = On = Ln = 0, t } }; function An (t, e) { wn += t, In += e, ++Sn } function Tn () { Rn.point = Dn } function Dn (t, e) { Rn.point = Fn, An(bn = t, En = e) } function Fn (t, e) { const n = t - bn; const r = e - En; const i = I(n * n + r * r); Nn += i * (bn + t) / 2, Pn += i * (En + e) / 2, Cn += i, An(bn = t, En = e) } function jn () { Rn.point = An } function kn () { Rn.point = qn } function Gn () { Bn(mn, xn) } function qn (t, e) { Rn.point = Bn, An(mn = bn = t, xn = En = e) } function Bn (t, e) { const n = t - bn; const r = e - En; let i = I(n * n + r * r); Nn += i * (bn + t) / 2, Pn += i * (En + e) / 2, Cn += i, Mn += (i = En * t - bn * e) * (bn + t), On += i * (En + e), Ln += 3 * i, An(bn = t, En = e) } const zn = Rn; function Un (t) { this._context = t }Un.prototype = { _radius: 4.5, pointRadius: function (t) { return this._radius = t, this }, polygonStart: function () { this._line = 0 }, polygonEnd: function () { this._line = NaN }, lineStart: function () { this._point = 0 }, lineEnd: function () { this._line === 0 && this._context.closePath(), this._point = NaN }, point: function (t, e) { switch (this._point) { case 0:this._context.moveTo(t, e), this._point = 1; break; case 1:this._context.lineTo(t, e); break; default:this._context.moveTo(t + this._radius, e), this._context.arc(t, e, this._radius, 0, f) } }, result: M }; let Xn; let Yn; let Vn; let Wn; let Hn; const Jn = r(); var Zn = { point: M, lineStart: function () { Zn.point = Kn }, lineEnd: function () { Xn && Qn(Yn, Vn), Zn.point = M }, polygonStart: function () { Xn = !0 }, polygonEnd: function () { Xn = null }, result: function () { const t = +Jn; return Jn.reset(), t } }; function Kn (t, e) { Zn.point = Qn, Yn = Wn = t, Vn = Hn = e } function Qn (t, e) { Wn -= t, Hn -= e, Jn.add(I(Wn * Wn + Hn * Hn)), Wn = t, Hn = e } const $n = Zn; function tr () { this._string = [] } function er (t) { return 'm0,' + t + 'a' + t + ',' + t + ' 0 1,1 0,' + -2 * t + 'a' + t + ',' + t + ' 0 1,1 0,' + 2 * t + 'z' } function nr (t, e) { let n; let r; let i = 4.5; function o (t) { return t && (typeof i === 'function' && r.pointRadius(+i.apply(this, arguments)), D(t, n(r))), r.result() } return o.area = function (t) { return D(t, n(hn)), hn.result() }, o.measure = function (t) { return D(t, n($n)), $n.result() }, o.bounds = function (t) { return D(t, n(_n)), _n.result() }, o.centroid = function (t) { return D(t, n(zn)), zn.result() }, o.projection = function (e) { return arguments.length ? (n = e == null ? (t = null, $e) : (t = e).stream, o) : t }, o.context = function (t) { return arguments.length ? (r = t == null ? (e = null, new tr()) : new Un(e = t), typeof i !== 'function' && r.pointRadius(i), o) : e }, o.pointRadius = function (t) { return arguments.length ? (i = typeof t === 'function' ? t : (r.pointRadius(+t), +t), o) : i }, o.projection(t).context(e) } function rr (t, e, n, r) { return function (i, o) { let s; let a; let u; const l = e(o); const c = i.invert(r[0], r[1]); const f = he(); const h = e(f); let p = !1; var g = { point: d, lineStart: v, lineEnd: _, polygonStart: function () { g.point = m, g.lineStart = x, g.lineEnd = b, a = [], s = [] }, polygonEnd: function () { g.point = d, g.lineStart = v, g.lineEnd = _, a = me(a); const t = Ne(s, c); a.length ? (p || (o.polygonStart(), p = !0), de(a, or, t, n, o)) : t && (p || (o.polygonStart(), p = !0), o.lineStart(), n(null, null, 1, o), o.lineEnd()), p && (o.polygonEnd(), p = !1), a = s = null }, sphere: function () { o.polygonStart(), o.lineStart(), n(null, null, 1, o), o.lineEnd(), o.polygonEnd() } }; function d (e, n) { const r = i(e, n); t(e = r[0], n = r[1]) && o.point(e, n) } function y (t, e) { const n = i(t, e); l.point(n[0], n[1]) } function v () { g.point = y, l.lineStart() } function _ () { g.point = d, l.lineEnd() } function m (t, e) { u.push([t, e]); const n = i(t, e); h.point(n[0], n[1]) } function x () { h.lineStart(), u = [] } function b () { m(u[0][0], u[0][1]), h.lineEnd(); let t; let e; let n; let r; const i = h.clean(); const l = f.result(); const c = l.length; if (u.pop(), s.push(u), u = null, c) if (1 & i) { if ((e = (n = l[0]).length - 1) > 0) { for (p || (o.polygonStart(), p = !0), o.lineStart(), t = 0; t < e; ++t)o.point((r = n[t])[0], r[1]); o.lineEnd() } } else c > 1 && 2 & i && l.push(l.pop().concat(l.shift())), a.push(l.filter(ir)) } return g } } function ir (t) { return t.length > 1 } function or (t, e) { return ((t = t.x)[0] < 0 ? t[1] - l - a : l - t[1]) - ((e = e.x)[0] < 0 ? e[1] - l - a : l - e[1]) }tr.prototype = { _radius: 4.5, _circle: er(4.5), pointRadius: function (t) { return (t = +t) !== this._radius && (this._radius = t, this._circle = null), this }, polygonStart: function () { this._line = 0 }, polygonEnd: function () { this._line = NaN }, lineStart: function () { this._point = 0 }, lineEnd: function () { this._line === 0 && this._string.push('Z'), this._point = NaN }, point: function (t, e) { switch (this._point) { case 0:this._string.push('M', t, ',', e), this._point = 1; break; case 1:this._string.push('L', t, ',', e); break; default:this._circle == null && (this._circle = er(this._radius)), this._string.push('M', t, ',', e, this._circle) } }, result: function () { if (this._string.length) { const t = this._string.join(''); return this._string = [], t } return null } }; const sr = rr(function () { return !0 }, function (t) { let e; let n = NaN; let r = NaN; let i = NaN; return { lineStart: function () { t.lineStart(), e = 1 }, point: function (o, s) { const c = o > 0 ? u : -u; const f = g(o - n); g(f - u) < a ? (t.point(n, r = (r + s) / 2 > 0 ? l : -l), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(c, r), t.point(o, r), e = 0) : i !== c && f >= u && (g(n - i) < a && (n -= i * a), g(o - c) < a && (o -= c * a), r = (function (t, e, n, r) { let i; let o; const s = E(t - n); return g(s) > a ? d((E(e) * (o = v(r)) * E(n) - E(r) * (i = v(e)) * E(t)) / (i * o * s)) : (e + r) / 2 }(n, r, o, s)), t.point(i, r), t.lineEnd(), t.lineStart(), t.point(c, r), e = 0), t.point(n = o, r = s), i = c }, lineEnd: function () { t.lineEnd(), n = r = NaN }, clean: function () { return 2 - e } } }, function (t, e, n, r) { let i; if (t == null)i = n * l, r.point(-u, i), r.point(0, i), r.point(u, i), r.point(u, 0), r.point(u, -i), r.point(0, -i), r.point(-u, -i), r.point(-u, 0), r.point(-u, i); else if (g(t[0] - e[0]) > a) { const o = t[0] < e[0] ? u : -u; i = n * o / 2, r.point(-o, i), r.point(0, i), r.point(o, i) } else r.point(e[0], e[1]) }, [-u, -l]); function ar (t, e) { const n = v(t); const r = n > 0; const i = g(n) > a; function o (t, e) { return v(t) * v(e) > n } function s (t, e, r) { const i = [1, 0, 0]; const o = Q(Z(t), Z(e)); const s = K(o, o); const l = o[0]; const c = s - l * l; if (!c) return !r && t; const f = n * s / c; const h = -n * l / c; const p = Q(i, o); const d = tt(i, f); $(d, tt(o, h)); const y = p; const v = K(d, y); const _ = K(y, y); const m = v * v - _ * (K(d, d) - 1); if (!(m < 0)) { const x = I(m); let b = tt(y, (-v - x) / _); if ($(b, d), b = J(b), !r) return b; let E; let w = t[0]; let S = e[0]; let N = t[1]; let P = e[1]; S < w && (E = w, w = S, S = E); const C = S - w; const M = g(C - u) < a; if (!M && P < N && (E = N, N = P, P = E), M || C < a ? M ? N + P > 0 ^ b[1] < (g(b[0] - w) < a ? N : P) : N <= b[1] && b[1] <= P : C > u ^ (w <= b[0] && b[0] <= S)) { const O = tt(y, (-v + x) / _); return $(O, d), [b, J(O)] } } } function l (e, n) { const i = r ? t : u - t; let o = 0; return e < -i ? o |= 1 : e > i && (o |= 2), n < -i ? o |= 4 : n > i && (o |= 8), o } return rr(o, function (t) { let e, n, c, f, h; return { lineStart: function () { f = c = !1, h = 1 }, point: function (p, g) { let d; const y = [p, g]; let v = o(p, g); const _ = r ? v ? 0 : l(p, g) : v ? l(p + (p < 0 ? u : -u), g) : 0; if (!e && (f = c = v) && t.lineStart(), v !== c && (!(d = s(e, y)) || pe(e, d) || pe(y, d)) && (y[0] += a, y[1] += a, v = o(y[0], y[1])), v !== c)h = 0, v ? (t.lineStart(), d = s(y, e), t.point(d[0], d[1])) : (d = s(e, y), t.point(d[0], d[1]), t.lineEnd()), e = d; else if (i && e && r ^ v) { let m; _ & n || !(m = s(y, e, !0)) || (h = 0, r ? (t.lineStart(), t.point(m[0][0], m[0][1]), t.point(m[1][0], m[1][1]), t.lineEnd()) : (t.point(m[1][0], m[1][1]), t.lineEnd(), t.lineStart(), t.point(m[0][0], m[0][1]))) }!v || e && pe(e, y) || t.point(y[0], y[1]), e = y, c = v, n = _ }, lineEnd: function () { c && t.lineEnd(), e = null }, clean: function () { return h | (f && c) << 1 } } }, function (n, r, i, o) { le(o, t, e, i, n, r) }, r ? [0, -t] : [-u, t - u]) } function ur (t) { return { stream: lr(t) } } function lr (t) { return function (e) { const n = new cr(); for (const r in t)n[r] = t[r]; return n.stream = e, n } } function cr () {} function fr (t, e, n) { const r = e[1][0] - e[0][0]; const i = e[1][1] - e[0][1]; const o = t.clipExtent && t.clipExtent(); t.scale(150).translate([0, 0]), o != null && t.clipExtent(null), D(n, t.stream(_n)); const s = _n.result(); const a = Math.min(r / (s[1][0] - s[0][0]), i / (s[1][1] - s[0][1])); const u = +e[0][0] + (r - a * (s[1][0] + s[0][0])) / 2; const l = +e[0][1] + (i - a * (s[1][1] + s[0][1])) / 2; return o != null && t.clipExtent(o), t.scale(150 * a).translate([u, l]) } function hr (t, e, n) { return fr(t, [[0, 0], e], n) }cr.prototype = { constructor: cr, point: function (t, e) { this.stream.point(t, e) }, sphere: function () { this.stream.sphere() }, lineStart: function () { this.stream.lineStart() }, lineEnd: function () { this.stream.lineEnd() }, polygonStart: function () { this.stream.polygonStart() }, polygonEnd: function () { this.stream.polygonEnd() } }; const pr = v(30 * p); function gr (t, e) { return +e ? (function (t, e) { function n (r, i, o, s, u, l, c, f, h, p, d, v, _, m) { const x = c - r; const b = f - i; const E = x * x + b * b; if (E > 4 * e && _--) { let w = s + p; let S = u + d; let N = l + v; const C = I(w * w + S * S + N * N); const M = P(N /= C); const O = g(g(N) - 1) < a || g(o - h) < a ? (o + h) / 2 : y(S, w); const L = t(O, M); const R = L[0]; const A = L[1]; const T = R - r; const D = A - i; const F = b * T - x * D; (F * F / E > e || g((x * T + b * D) / E - 0.5) > 0.3 || s * p + u * d + l * v < pr) && (n(r, i, o, s, u, l, R, A, O, w /= C, S /= C, N, _, m), m.point(R, A), n(R, A, O, w, S, N, c, f, h, p, d, v, _, m)) } } return function (e) { let r; let i; let o; let s; let a; let u; let l; let c; let f; let h; let p; let g; var d = { point: y, lineStart: v, lineEnd: m, polygonStart: function () { e.polygonStart(), d.lineStart = x }, polygonEnd: function () { e.polygonEnd(), d.lineStart = v } }; function y (n, r) { n = t(n, r), e.point(n[0], n[1]) } function v () { c = NaN, d.point = _, e.lineStart() } function _ (r, i) { const o = Z([r, i]); const s = t(r, i); n(c, f, l, h, p, g, c = s[0], f = s[1], l = r, h = o[0], p = o[1], g = o[2], 16, e), e.point(c, f) } function m () { d.point = y, e.lineEnd() } function x () { v(), d.point = b, d.lineEnd = E } function b (t, e) { _(r = t, e), i = c, o = f, s = h, a = p, u = g, d.point = _ } function E () { n(c, f, l, h, p, g, i, o, r, s, a, u, 16, e), d.lineEnd = m, m() } return d } }(t, e)) : (function (t) { return lr({ point: function (e, n) { e = t(e, n), this.stream.point(e[0], e[1]) } }) }(t)) } const dr = lr({ point: function (t, e) { this.stream.point(t * p, e * p) } }); function yr (t) { return vr(function () { return t })() } function vr (t) { let e; let n; let r; let i; let o; let s; let a; let u; let l; let c; let f = 150; let g = 480; let d = 250; let y = 0; let v = 0; let _ = 0; let m = 0; let x = 0; let b = null; let E = sr; let w = null; let S = $e; let N = 0.5; let P = gr(O, N); function C (t) { return [(t = o(t[0] * p, t[1] * p))[0] * f + n, r - t[1] * f] } function M (t) { return (t = o.invert((t[0] - n) / f, (r - t[1]) / f)) && [t[0] * h, t[1] * h] } function O (t, i) { return [(t = e(t, i))[0] * f + n, r - t[1] * f] } function L () { o = ne(i = ie(_, m, x), e); const t = e(y, v); return n = g - t[0] * f, r = d + t[1] * f, R() } function R () { return l = c = null, C } return C.stream = function (t) { return l && c === t ? l : l = dr(E(i, P(S(c = t)))) }, C.clipAngle = function (t) { return arguments.length ? (E = +t ? ar(b = t * p, 6 * p) : (b = null, sr), R()) : b * h }, C.clipExtent = function (t) { return arguments.length ? (S = t == null ? (w = s = a = u = null, $e) : we(w = +t[0][0], s = +t[0][1], a = +t[1][0], u = +t[1][1]), R()) : w == null ? null : [[w, s], [a, u]] }, C.scale = function (t) { return arguments.length ? (f = +t, L()) : f }, C.translate = function (t) { return arguments.length ? (g = +t[0], d = +t[1], L()) : [g, d] }, C.center = function (t) { return arguments.length ? (y = t[0] % 360 * p, v = t[1] % 360 * p, L()) : [y * h, v * h] }, C.rotate = function (t) { return arguments.length ? (_ = t[0] % 360 * p, m = t[1] % 360 * p, x = t.length > 2 ? t[2] % 360 * p : 0, L()) : [_ * h, m * h, x * h] }, C.precision = function (t) { return arguments.length ? (P = gr(O, N = t * t), R()) : I(N) }, C.fitExtent = function (t, e) { return fr(C, t, e) }, C.fitSize = function (t, e) { return hr(C, t, e) }, function () { return e = t.apply(this, arguments), C.invert = e.invert && M, L() } } function _r (t) { let e = 0; let n = u / 3; const r = vr(t); const i = r(e, n); return i.parallels = function (t) { return arguments.length ? r(e = t[0] * p, n = t[1] * p) : [e * h, n * h] }, i } function mr (t, e) { const n = E(t); const r = (n + E(e)) / 2; if (g(r) < a) return (function (t) { const e = v(t); function n (t, n) { return [t * e, E(n) / e] } return n.invert = function (t, n) { return [t / e, P(n * e)] }, n }(t)); const i = 1 + n * (2 * r - n); const o = I(i) / r; function s (t, e) { const n = I(i - 2 * r * E(e)) / r; return [n * E(t *= r), o - n * v(t)] } return s.invert = function (t, e) { const n = o - e; return [y(t, g(n)) / r * w(n), P((i - (t * t + n * n) * r * r) / (2 * r))] }, s } function xr () { return _r(mr).scale(155.424).center([0, 33.6442]) } function br () { return xr().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]) } function Er () { let t; let e; let n; let r; let i; let o; const s = br(); const u = xr().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]); const l = xr().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]); const c = { point: function (t, e) { o = [t, e] } }; function f (t) { const e = t[0]; const s = t[1]; return o = null, n.point(e, s), o || (r.point(e, s), o) || (i.point(e, s), o) } function h () { return t = e = null, f } return f.invert = function (t) { const e = s.scale(); const n = s.translate(); const r = (t[0] - n[0]) / e; const i = (t[1] - n[1]) / e; return (i >= 0.12 && i < 0.234 && r >= -0.425 && r < -0.214 ? u : i >= 0.166 && i < 0.234 && r >= -0.214 && r < -0.115 ? l : s).invert(t) }, f.stream = function (n) { return t && e === n ? t : (r = [s.stream(e = n), u.stream(n), l.stream(n)], i = r.length, t = { point: function (t, e) { for (let n = -1; ++n < i;)r[n].point(t, e) }, sphere: function () { for (let t = -1; ++t < i;)r[t].sphere() }, lineStart: function () { for (let t = -1; ++t < i;)r[t].lineStart() }, lineEnd: function () { for (let t = -1; ++t < i;)r[t].lineEnd() }, polygonStart: function () { for (let t = -1; ++t < i;)r[t].polygonStart() }, polygonEnd: function () { for (let t = -1; ++t < i;)r[t].polygonEnd() } }); let r, i }, f.precision = function (t) { return arguments.length ? (s.precision(t), u.precision(t), l.precision(t), h()) : s.precision() }, f.scale = function (t) { return arguments.length ? (s.scale(t), u.scale(0.35 * t), l.scale(t), f.translate(s.translate())) : s.scale() }, f.translate = function (t) { if (!arguments.length) return s.translate(); const e = s.scale(); const o = +t[0]; const f = +t[1]; return n = s.translate(t).clipExtent([[o - 0.455 * e, f - 0.238 * e], [o + 0.455 * e, f + 0.238 * e]]).stream(c), r = u.translate([o - 0.307 * e, f + 0.201 * e]).clipExtent([[o - 0.425 * e + a, f + 0.12 * e + a], [o - 0.214 * e - a, f + 0.234 * e - a]]).stream(c), i = l.translate([o - 0.205 * e, f + 0.212 * e]).clipExtent([[o - 0.214 * e + a, f + 0.166 * e + a], [o - 0.115 * e - a, f + 0.234 * e - a]]).stream(c), h() }, f.fitExtent = function (t, e) { return fr(f, t, e) }, f.fitSize = function (t, e) { return hr(f, t, e) }, f.scale(1070) } function wr (t) { return function (e, n) { const r = v(e); const i = v(n); const o = t(r * i); return [o * i * E(e), o * E(n)] } } function Ir (t) { return function (e, n) { const r = I(e * e + n * n); const i = t(r); const o = E(i); const s = v(i); return [y(e * o, r * s), P(r && n * o / r)] } } var Sr = wr(function (t) { return I(2 / (1 + t)) }); function Nr () { return yr(Sr).scale(124.75).clipAngle(179.999) }Sr.invert = Ir(function (t) { return 2 * P(t / 2) }); var Pr = wr(function (t) { return (t = N(t)) && t / E(t) }); function Cr () { return yr(Pr).scale(79.4188).clipAngle(179.999) } function Mr (t, e) { return [t, x(S((l + e) / 2))] } function Or () { return Lr(Mr).scale(961 / f) } function Lr (t) { let e; let n; let r; const i = yr(t); const o = i.center; const s = i.scale; const a = i.translate; const l = i.clipExtent; let c = null; function f () { const o = u * s(); const a = i(ue(i.rotate()).invert([0, 0])); return l(c == null ? [[a[0] - o, a[1] - o], [a[0] + o, a[1] + o]] : t === Mr ? [[Math.max(a[0] - o, c), e], [Math.min(a[0] + o, n), r]] : [[c, Math.max(a[1] - o, e)], [n, Math.min(a[1] + o, r)]]) } return i.scale = function (t) { return arguments.length ? (s(t), f()) : s() }, i.translate = function (t) { return arguments.length ? (a(t), f()) : a() }, i.center = function (t) { return arguments.length ? (o(t), f()) : o() }, i.clipExtent = function (t) { return arguments.length ? (t == null ? c = e = n = r = null : (c = +t[0][0], e = +t[0][1], n = +t[1][0], r = +t[1][1]), f()) : c == null ? null : [[c, e], [n, r]] }, f() } function Rr (t) { return S((l + t) / 2) } function Ar (t, e) { const n = v(t); const r = t === e ? E(t) : x(n / v(e)) / x(Rr(e) / Rr(t)); const i = n * b(Rr(t), r) / r; if (!r) return Mr; function o (t, e) { i > 0 ? e < -l + a && (e = -l + a) : e > l - a && (e = l - a); const n = i / b(Rr(e), r); return [n * E(r * t), i - n * v(r * t)] } return o.invert = function (t, e) { const n = i - e; const o = w(r) * I(t * t + n * n); return [y(t, g(n)) / r * w(n), 2 * d(b(i / o, 1 / r)) - l] }, o } function Tr () { return _r(Ar).scale(109.5).parallels([30, 30]) } function Dr (t, e) { return [t, e] } function Fr () { return yr(Dr).scale(152.63) } function jr (t, e) { const n = v(t); const r = t === e ? E(t) : (n - v(e)) / (e - t); const i = n / r + t; if (g(r) < a) return Dr; function o (t, e) { const n = i - e; const o = r * t; return [n * E(o), i - n * v(o)] } return o.invert = function (t, e) { const n = i - e; return [y(t, g(n)) / r * w(n), i - w(r) * I(t * t + n * n)] }, o } function kr () { return _r(jr).scale(131.154).center([0, 13.9389]) } function Gr (t, e) { const n = v(e); const r = v(t) * n; return [n * E(t) / r, E(e) / r] } function qr () { return yr(Gr).scale(144.049).clipAngle(60) } function Br (t, e, n, r) { return t === 1 && e === 1 && n === 0 && r === 0 ? $e : lr({ point: function (i, o) { this.stream.point(i * t + n, o * e + r) } }) } function zr () { let t; let e; let n; let r; let i; let o; let s = 1; let a = 0; let u = 0; let l = 1; let c = 1; let f = $e; let h = null; let p = $e; function g () { return r = i = null, o } return o = { stream: function (t) { return r && i === t ? r : r = f(p(i = t)) }, clipExtent: function (r) { return arguments.length ? (p = r == null ? (h = t = e = n = null, $e) : we(h = +r[0][0], t = +r[0][1], e = +r[1][0], n = +r[1][1]), g()) : h == null ? null : [[h, t], [e, n]] }, scale: function (t) { return arguments.length ? (f = Br((s = +t) * l, s * c, a, u), g()) : s }, translate: function (t) { return arguments.length ? (f = Br(s * l, s * c, a = +t[0], u = +t[1]), g()) : [a, u] }, reflectX: function (t) { return arguments.length ? (f = Br(s * (l = t ? -1 : 1), s * c, a, u), g()) : l < 0 }, reflectY: function (t) { return arguments.length ? (f = Br(s * l, s * (c = t ? -1 : 1), a, u), g()) : c < 0 }, fitExtent: function (t, e) { return fr(o, t, e) }, fitSize: function (t, e) { return hr(o, t, e) } } } function Ur (t, e) { const n = e * e; const r = n * n; return [t * (0.8707 - 0.131979 * n + r * (r * (0.003971 * n - 0.001529 * r) - 0.013791)), e * (1.007226 + n * (0.015085 + r * (0.028874 * n - 0.044475 - 0.005916 * r)))] } function Xr () { return yr(Ur).scale(175.295) } function Yr (t, e) { return [v(e) * E(t), E(e)] } function Vr () { return yr(Yr).scale(249.5).clipAngle(90.000001) } function Wr (t, e) { const n = v(e); const r = 1 + v(t) * n; return [n * E(t) / r, E(e) / r] } function Hr () { return yr(Wr).scale(250).clipAngle(142) } function Jr (t, e) { return [x(S((l + e) / 2)), -t] } function Zr () { const t = Lr(Jr); const e = t.center; const n = t.rotate; return t.center = function (t) { return arguments.length ? e([-t[1], t[0]]) : [(t = e())[1], -t[0]] }, t.rotate = function (t) { return arguments.length ? n([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = n())[0], t[1], t[2] - 90] }, n([0, 0, 90]).scale(159.155) }Pr.invert = Ir(function (t) { return t }), Mr.invert = function (t, e) { return [t, 2 * d(m(e)) - l] }, Dr.invert = Dr, Gr.invert = Ir(d), Ur.invert = function (t, e) { let n; let r = e; let i = 25; do { var o = r * r; const s = o * o; r -= n = (r * (1.007226 + o * (0.015085 + s * (0.028874 * o - 0.044475 - 0.005916 * s))) - e) / (1.007226 + o * (0.045255 + s * (0.259866 * o - 0.311325 - 0.005916 * 11 * s))) } while (g(n) > a && --i > 0); return [t / (0.8707 + (o = r * r) * (o * (o * o * o * (0.003971 - 0.001529 * o) - 0.013791) - 0.131979)), r] }, Yr.invert = Ir(P), Wr.invert = Ir(function (t) { return 2 * d(t) }), Jr.invert = function (t, e) { return [-e, 2 * d(m(t)) - l] } }, 1704: (t, e, n) => { 'use strict'; function r (t) { return function () { return t } } function i (t) { return t[0] } function o (t) { return t[1] } function s () { this._ = null } function a (t) { t.U = t.C = t.L = t.R = t.P = t.N = null } function u (t, e) { const n = e; const r = e.R; const i = n.U; i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.R = r.L, n.R && (n.R.U = n), r.L = n } function l (t, e) { const n = e; const r = e.L; const i = n.U; i ? i.L === n ? i.L = r : i.R = r : t._ = r, r.U = i, n.U = r, n.L = r.R, n.L && (n.L.U = n), r.R = n } function c (t) { for (;t.L;)t = t.L; return t }n.r(e), n.d(e, { voronoi: () => B }), s.prototype = { constructor: s, insert: function (t, e) { let n, r, i; if (t) { if (e.P = t, e.N = t.N, t.N && (t.N.P = e), t.N = e, t.R) { for (t = t.R; t.L;)t = t.L; t.L = e } else t.R = e; n = t } else this._ ? (t = c(this._), e.P = null, e.N = t, t.P = t.L = e, n = t) : (e.P = e.N = null, this._ = e, n = null); for (e.L = e.R = null, e.U = n, e.C = !0, t = e; n && n.C;)n === (r = n.U).L ? (i = r.R) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.R && (u(this, n), n = (t = n).U), n.C = !1, r.C = !0, l(this, r)) : (i = r.L) && i.C ? (n.C = i.C = !1, r.C = !0, t = r) : (t === n.L && (l(this, n), n = (t = n).U), n.C = !1, r.C = !0, u(this, r)), n = t.U; this._.C = !1 }, remove: function (t) { t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), t.N = t.P = null; let e; let n; let r; let i = t.U; const o = t.L; const s = t.R; if (n = o ? s ? c(s) : o : s, i ? i.L === t ? i.L = n : i.R = n : this._ = n, o && s ? (r = n.C, n.C = t.C, n.L = o, o.U = n, n !== s ? (i = n.U, n.U = t.U, t = n.R, i.L = t, n.R = s, s.U = n) : (n.U = i, i = n, t = n.R)) : (r = t.C, t = n), t && (t.U = i), !r) if (t && t.C)t.C = !1; else { do { if (t === this._) break; if (t === i.L) { if ((e = i.R).C && (e.C = !1, i.C = !0, u(this, i), e = i.R), e.L && e.L.C || e.R && e.R.C) { e.R && e.R.C || (e.L.C = !1, e.C = !0, l(this, e), e = i.R), e.C = i.C, i.C = e.R.C = !1, u(this, i), t = this._; break } } else if ((e = i.L).C && (e.C = !1, i.C = !0, l(this, i), e = i.L), e.L && e.L.C || e.R && e.R.C) { e.L && e.L.C || (e.R.C = !1, e.C = !0, u(this, e), e = i.L), e.C = i.C, i.C = e.L.C = !1, l(this, i), t = this._; break }e.C = !0, t = i, i = i.U } while (!t.C); t && (t.C = !1) } } }; const f = s; function h (t, e, n, r) { const i = [null, null]; const o = F.push(i) - 1; return i.left = t, i.right = e, n && g(i, t, e, n), r && g(i, e, t, r), T[t.index].halfedges.push(o), T[e.index].halfedges.push(o), i } function p (t, e, n) { const r = [e, n]; return r.left = t, r } function g (t, e, n, r) { t[0] || t[1] ? t.left === n ? t[1] = r : t[0] = r : (t[0] = r, t.left = e, t.right = n) } function d (t, e, n, r, i) { let o; const s = t[0]; const a = t[1]; const u = s[0]; const l = s[1]; let c = 0; let f = 1; const h = a[0] - u; const p = a[1] - l; if (o = e - u, h || !(o > 0)) { if (o /= h, h < 0) { if (o < c) return; o < f && (f = o) } else if (h > 0) { if (o > f) return; o > c && (c = o) } if (o = r - u, h || !(o < 0)) { if (o /= h, h < 0) { if (o > f) return; o > c && (c = o) } else if (h > 0) { if (o < c) return; o < f && (f = o) } if (o = n - l, p || !(o > 0)) { if (o /= p, p < 0) { if (o < c) return; o < f && (f = o) } else if (p > 0) { if (o > f) return; o > c && (c = o) } if (o = i - l, p || !(o < 0)) { if (o /= p, p < 0) { if (o > f) return; o > c && (c = o) } else if (p > 0) { if (o < c) return; o < f && (f = o) } return !(c > 0 || f < 1) || (c > 0 && (t[0] = [u + c * h, l + c * p]), f < 1 && (t[1] = [u + f * h, l + f * p]), !0) } } } } } function y (t, e, n, r, i) { let o = t[1]; if (o) return !0; let s; let a; let u = t[0]; const l = t.left; const c = t.right; const f = l[0]; const h = l[1]; const p = c[0]; const g = c[1]; const d = (f + p) / 2; const y = (h + g) / 2; if (g === h) { if (d < e || d >= r) return; if (f > p) { if (u) { if (u[1] >= i) return } else u = [d, n]; o = [d, i] } else { if (u) { if (u[1] < n) return } else u = [d, i]; o = [d, n] } } else if (a = y - (s = (f - p) / (g - h)) * d, s < -1 || s > 1) if (f > p) { if (u) { if (u[1] >= i) return } else u = [(n - a) / s, n]; o = [(i - a) / s, i] } else { if (u) { if (u[1] < n) return } else u = [(i - a) / s, i]; o = [(n - a) / s, n] } else if (h < g) { if (u) { if (u[0] >= r) return } else u = [e, s * e + a]; o = [r, s * r + a] } else { if (u) { if (u[0] < e) return } else u = [r, s * r + a]; o = [e, s * e + a] } return t[0] = u, t[1] = o, !0 } function v (t, e) { const n = t.site; let r = e.left; let i = e.right; return n === i && (i = r, r = n), i ? Math.atan2(i[1] - r[1], i[0] - r[0]) : (n === r ? (r = e[1], i = e[0]) : (r = e[0], i = e[1]), Math.atan2(r[0] - i[0], i[1] - r[1])) } function _ (t, e) { return e[+(e.left !== t.site)] } function m (t, e) { return e[+(e.left === t.site)] } let x; const b = []; function E () { a(this), this.x = this.y = this.arc = this.site = this.cy = null } function w (t) { const e = t.P; const n = t.N; if (e && n) { const r = e.site; const i = t.site; const o = n.site; if (r !== o) { const s = i[0]; const a = i[1]; const u = r[0] - s; const l = r[1] - a; const c = o[0] - s; const f = o[1] - a; const h = 2 * (u * f - l * c); if (!(h >= -k)) { const p = u * u + l * l; const g = c * c + f * f; const d = (f * p - l * g) / h; const y = (u * g - c * p) / h; const v = b.pop() || new E(); v.arc = t, v.site = i, v.x = d + s, v.y = (v.cy = y + a) + Math.sqrt(d * d + y * y), t.circle = v; for (var _ = null, m = D._; m;) if (v.y < m.y || v.y === m.y && v.x <= m.x) { if (!m.L) { _ = m.P; break }m = m.L } else { if (!m.R) { _ = m; break }m = m.R }D.insert(_, v), _ || (x = v) } } } } function I (t) { const e = t.circle; e && (e.P || (x = e.N), D.remove(e), b.push(e), a(e), t.circle = null) } const S = []; function N () { a(this), this.edge = this.site = this.circle = null } function P (t) { const e = S.pop() || new N(); return e.site = t, e } function C (t) { I(t), A.remove(t), S.push(t), a(t) } function M (t) { const e = t.circle; const n = e.x; const r = e.cy; const i = [n, r]; let o = t.P; let s = t.N; const a = [t]; C(t); for (var u = o; u.circle && Math.abs(n - u.circle.x) < j && Math.abs(r - u.circle.cy) < j;)o = u.P, a.unshift(u), C(u), u = o; a.unshift(u), I(u); for (var l = s; l.circle && Math.abs(n - l.circle.x) < j && Math.abs(r - l.circle.cy) < j;)s = l.N, a.push(l), C(l), l = s; a.push(l), I(l); let c; const f = a.length; for (c = 1; c < f; ++c)l = a[c], u = a[c - 1], g(l.edge, u.site, l.site, i); u = a[0], (l = a[f - 1]).edge = h(u.site, l.site, null, i), w(u), w(l) } function O (t) { for (var e, n, r, i, o = t[0], s = t[1], a = A._; a;) if ((r = L(a, s) - o) > j)a = a.L; else { if (!((i = o - R(a, s)) > j)) { r > -j ? (e = a.P, n = a) : i > -j ? (e = a, n = a.N) : e = n = a; break } if (!a.R) { e = a; break }a = a.R }!(function (t) { T[t.index] = { site: t, halfedges: [] } }(t)); const u = P(t); if (A.insert(e, u), e || n) { if (e === n) return I(e), n = P(e.site), A.insert(u, n), u.edge = n.edge = h(e.site, u.site), w(e), void w(n); if (n) { I(e), I(n); const l = e.site; const c = l[0]; const f = l[1]; const p = t[0] - c; const d = t[1] - f; const y = n.site; const v = y[0] - c; const _ = y[1] - f; const m = 2 * (p * _ - d * v); const x = p * p + d * d; const b = v * v + _ * _; const E = [(_ * x - d * b) / m + c, (p * b - v * x) / m + f]; g(n.edge, l, y, E), u.edge = h(l, t, null, E), n.edge = h(t, y, null, E), w(e), w(n) } else u.edge = h(e.site, u.site) } } function L (t, e) { let n = t.site; const r = n[0]; const i = n[1]; const o = i - e; if (!o) return r; const s = t.P; if (!s) return -1 / 0; const a = (n = s.site)[0]; const u = n[1]; const l = u - e; if (!l) return a; const c = a - r; const f = 1 / o - 1 / l; const h = c / l; return f ? (-h + Math.sqrt(h * h - 2 * f * (c * c / (-2 * l) - u + l / 2 + i - o / 2))) / f + r : (r + a) / 2 } function R (t, e) { const n = t.N; if (n) return L(n, e); const r = t.site; return r[1] === e ? r[0] : 1 / 0 } let A; let T; let D; let F; var j = 1e-6; var k = 1e-12; function G (t, e) { return e[1] - t[1] || e[0] - t[0] } function q (t, e) { let n; let r; let i; let o = t.sort(G).pop(); for (F = [], T = new Array(t.length), A = new f(), D = new f(); ;) if (i = x, o && (!i || o[1] < i.y || o[1] === i.y && o[0] < i.x))o[0] === n && o[1] === r || (O(o), n = o[0], r = o[1]), o = t.pop(); else { if (!i) break; M(i.arc) } if ((function () { for (var t, e, n, r, i = 0, o = T.length; i < o; ++i) if ((t = T[i]) && (r = (e = t.halfedges).length)) { const s = new Array(r); var a = new Array(r); for (n = 0; n < r; ++n)s[n] = n, a[n] = v(t, F[e[n]]); for (s.sort(function (t, e) { return a[e] - a[t] }), n = 0; n < r; ++n)a[n] = e[s[n]]; for (n = 0; n < r; ++n)e[n] = a[n] } }()), e) { const s = +e[0][0]; const a = +e[0][1]; const u = +e[1][0]; const l = +e[1][1]; !(function (t, e, n, r) { for (var i, o = F.length; o--;)y(i = F[o], t, e, n, r) && d(i, t, e, n, r) && (Math.abs(i[0][0] - i[1][0]) > j || Math.abs(i[0][1] - i[1][1]) > j) || delete F[o] }(s, a, u, l)), (function (t, e, n, r) { let i; let o; let s; let a; let u; let l; let c; let f; let h; let g; let d; let y; const v = T.length; let x = !0; for (i = 0; i < v; ++i) if (o = T[i]) { for (s = o.site, a = (u = o.halfedges).length; a--;)F[u[a]] || u.splice(a, 1); for (a = 0, l = u.length; a < l;)d = (g = m(o, F[u[a]]))[0], y = g[1], f = (c = _(o, F[u[++a % l]]))[0], h = c[1], (Math.abs(d - f) > j || Math.abs(y - h) > j) && (u.splice(a, 0, F.push(p(s, g, Math.abs(d - t) < j && r - y > j ? [t, Math.abs(f - t) < j ? h : r] : Math.abs(y - r) < j && n - d > j ? [Math.abs(h - r) < j ? f : n, r] : Math.abs(d - n) < j && y - e > j ? [n, Math.abs(f - n) < j ? h : e] : Math.abs(y - e) < j && d - t > j ? [Math.abs(h - e) < j ? f : t, e] : null)) - 1), ++l); l && (x = !1) } if (x) { let b; let E; let w; let I = 1 / 0; for (i = 0, x = null; i < v; ++i)(o = T[i]) && (w = (b = (s = o.site)[0] - t) * b + (E = s[1] - e) * E) < I && (I = w, x = o); if (x) { const S = [t, e]; const N = [t, r]; const P = [n, r]; const C = [n, e]; x.halfedges.push(F.push(p(s = x.site, S, N)) - 1, F.push(p(s, N, P)) - 1, F.push(p(s, P, C)) - 1, F.push(p(s, C, S)) - 1) } } for (i = 0; i < v; ++i)(o = T[i]) && (o.halfedges.length || delete T[i]) }(s, a, u, l)) } this.edges = F, this.cells = T, A = D = F = T = null } function B () { let t = i; let e = o; let n = null; function s (r) { return new q(r.map(function (n, i) { const o = [Math.round(t(n, i, r) / j) * j, Math.round(e(n, i, r) / j) * j]; return o.index = i, o.data = n, o }), n) } return s.polygons = function (t) { return s(t).polygons() }, s.links = function (t) { return s(t).links() }, s.triangles = function (t) { return s(t).triangles() }, s.x = function (e) { return arguments.length ? (t = typeof e === 'function' ? e : r(+e), s) : t }, s.y = function (t) { return arguments.length ? (e = typeof t === 'function' ? t : r(+t), s) : e }, s.extent = function (t) { return arguments.length ? (n = t == null ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]], s) : n && [[n[0][0], n[0][1]], [n[1][0], n[1][1]]] }, s.size = function (t) { return arguments.length ? (n = t == null ? null : [[0, 0], [+t[0], +t[1]]], s) : n && [n[1][0] - n[0][0], n[1][1] - n[0][1]] }, s }q.prototype = { constructor: q, polygons: function () { const t = this.edges; return this.cells.map(function (e) { const n = e.halfedges.map(function (n) { return _(e, t[n]) }); return n.data = e.site.data, n }) }, triangles: function () { const t = []; const e = this.edges; return this.cells.forEach(function (n, r) { if (o = (i = n.halfedges).length) for (var i, o, s, a, u, l, c = n.site, f = -1, h = e[i[o - 1]], p = h.left === c ? h.right : h.left; ++f < o;)s = p, p = (h = e[i[f]]).left === c ? h.right : h.left, s && p && r < s.index && r < p.index && (u = s, l = p, ((a = c)[0] - l[0]) * (u[1] - a[1]) - (a[0] - u[0]) * (l[1] - a[1]) < 0) && t.push([c.data, s.data, p.data]) }), t }, links: function () { return this.edges.filter(function (t) { return t.right }).map(function (t) { return { source: t.left.data, target: t.right.data } }) }, find: function (t, e, n) { for (var r, i, o = this, s = o._found || 0, a = o.cells.length; !(i = o.cells[s]);) if (++s >= a) return null; const u = t - i.site[0]; const l = e - i.site[1]; let c = u * u + l * l; do { i = o.cells[r = s], s = null, i.halfedges.forEach(function (n) { const r = o.edges[n]; let a = r.left; if (a !== i.site && a || (a = r.right)) { const u = t - a[0]; const l = e - a[1]; const f = u * u + l * l; f < c && (c = f, s = a.index) } }) } while (s !== null); return o._found = r, n == null || c <= n * n ? i.site : null } } }, 251: (t, e, n) => { const r = n(2215); const i = n(2584); const o = n(609); const s = n(8420); const a = n(2847); const u = n(8923); const l = Date.prototype.getTime; function c (t) { return t == null } function f (t) { return !(!t || typeof t !== 'object' || typeof t.length !== 'number' || typeof t.copy !== 'function' || typeof t.slice !== 'function' || t.length > 0 && typeof t[0] !== 'number') }t.exports = function t (e, n, h) { const p = h || {}; return !!(p.strict ? o(e, n) : e === n) || (!e || !n || typeof e !== 'object' && typeof n !== 'object' ? p.strict ? o(e, n) : e == n : (function (e, n, o) { let h, p; if (typeof e !== typeof n) return !1; if (c(e) || c(n)) return !1; if (e.prototype !== n.prototype) return !1; if (i(e) !== i(n)) return !1; const g = s(e); const d = s(n); if (g !== d) return !1; if (g || d) return e.source === n.source && a(e) === a(n); if (u(e) && u(n)) return l.call(e) === l.call(n); const y = f(e); const v = f(n); if (y !== v) return !1; if (y || v) { if (e.length !== n.length) return !1; for (h = 0; h < e.length; h++) if (e[h] !== n[h]) return !1; return !0 } if (typeof e !== typeof n) return !1; try { var _ = r(e); var m = r(n) } catch (t) { return !1 } if (_.length !== m.length) return !1; for (_.sort(), m.sort(), h = _.length - 1; h >= 0; h--) if (_[h] != m[h]) return !1; for (h = _.length - 1; h >= 0; h--) if (!t(e[p = _[h]], n[p], o)) return !1; return !0 }(e, n, p))) } }, 4289: (t, e, n) => { 'use strict'; const r = n(2215); const i = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol'; const o = Object.prototype.toString; const s = Array.prototype.concat; const a = Object.defineProperty; const u = n(1044)(); const l = a && u; const c = function (t, e, n, r) { let i; (!(e in t) || typeof (i = r) === 'function' && o.call(i) === '[object Function]' && r()) && (l ? a(t, e, { configurable: !0, enumerable: !1, value: n, writable: !0 }) : t[e] = n) }; const f = function (t, e) { const n = arguments.length > 2 ? arguments[2] : {}; let o = r(e); i && (o = s.call(o, Object.getOwnPropertySymbols(e))); for (let a = 0; a < o.length; a += 1)c(t, o[a], e[o[a]], n[o[a]]) }; f.supportsDescriptors = !!l, t.exports = f }, 8317: t => { function e (t, e, n, r) { this.dataset = [], this.epsilon = 1, this.minPts = 2, this.distance = this._euclideanDistance, this.clusters = [], this.noise = [], this._visited = [], this._assigned = [], this._datasetLength = 0, this._init(t, e, n, r) }e.prototype.run = function (t, e, n, r) { this._init(t, e, n, r); for (let i = 0; i < this._datasetLength; i++) if (this._visited[i] !== 1) { this._visited[i] = 1; const o = this._regionQuery(i); if (o.length < this.minPts) this.noise.push(i); else { const s = this.clusters.length; this.clusters.push([]), this._addToCluster(i, s), this._expandCluster(s, o) } } return this.clusters }, e.prototype._init = function (t, e, n, r) { if (t) { if (!(t instanceof Array)) throw Error('Dataset must be of type array, ' + typeof t + ' given'); this.dataset = t, this.clusters = [], this.noise = [], this._datasetLength = t.length, this._visited = new Array(this._datasetLength), this._assigned = new Array(this._datasetLength) }e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r) }, e.prototype._expandCluster = function (t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (this._visited[r] !== 1) { this._visited[r] = 1; const i = this._regionQuery(r); i.length >= this.minPts && (e = this._mergeArrays(e, i)) } this._assigned[r] !== 1 && this._addToCluster(r, t) } }, e.prototype._addToCluster = function (t, e) { this.clusters[e].push(t), this._assigned[t] = 1 }, e.prototype._regionQuery = function (t) { for (var e = [], n = 0; n < this._datasetLength; n++) this.distance(this.dataset[t], this.dataset[n]) < this.epsilon && e.push(n); return e }, e.prototype._mergeArrays = function (t, e) { for (let n = e.length, r = 0; r < n; r++) { const i = e[r]; t.indexOf(i) < 0 && t.push(i) } return t }, e.prototype._euclideanDistance = function (t, e) { for (var n = 0, r = Math.min(t.length, e.length); r--;)n += (t[r] - e[r]) * (t[r] - e[r]); return Math.sqrt(n) }, t.exports && (t.exports = e) }, 3781: t => { function e (t, e, n) { this.k = 3, this.dataset = [], this.assignments = [], this.centroids = [], this.init(t, e, n) }e.prototype.init = function (t, e, n) { this.assignments = [], this.centroids = [], void 0 !== t && (this.dataset = t), void 0 !== e && (this.k = e), void 0 !== n && (this.distance = n) }, e.prototype.run = function (t, e) { this.init(t, e); for (var n = this.dataset.length, r = 0; r < this.k; r++) this.centroids[r] = this.randomCentroid(); for (let i = !0; i;) { i = this.assign(); for (let o = 0; o < this.k; o++) { for (var s = new Array(c), a = 0, u = 0; u < c; u++)s[u] = 0; for (let l = 0; l < n; l++) { var c = this.dataset[l].length; if (o === this.assignments[l]) { for (u = 0; u < c; u++)s[u] += this.dataset[l][u]; a++ } } if (a > 0) { for (u = 0; u < c; u++)s[u] /= a; this.centroids[o] = s } else this.centroids[o] = this.randomCentroid(), i = !0 } } return this.getClusters() }, e.prototype.randomCentroid = function () { let t; let e; const n = this.dataset.length - 1; do { e = Math.round(Math.random() * n), t = this.dataset[e] } while (this.centroids.indexOf(t) >= 0); return t }, e.prototype.assign = function () { for (var t, e = !1, n = this.dataset.length, r = 0; r < n; r++)(t = this.argmin(this.dataset[r], this.centroids, this.distance)) != this.assignments[r] && (this.assignments[r] = t, e = !0); return e }, e.prototype.getClusters = function () { for (var t, e = new Array(this.k), n = 0; n < this.assignments.length; n++) void 0 === e[t = this.assignments[n]] && (e[t] = []), e[t].push(n); return e }, e.prototype.argmin = function (t, e, n) { for (var r, i = Number.MAX_VALUE, o = 0, s = e.length, a = 0; a < s; a++)(r = n(t, e[a])) < i && (i = r, o = a); return o }, e.prototype.distance = function (t, e) { for (var n = 0, r = Math.min(t.length, e.length); r--;) { const i = t[r] - e[r]; n += i * i } return Math.sqrt(n) }, t.exports && (t.exports = e) }, 3763: (t, e, n) => { if (t.exports) var r = n(7985); function i (t, e, n, r) { this.epsilon = 1, this.minPts = 1, this.distance = this._euclideanDistance, this._reachability = [], this._processed = [], this._coreDistance = 0, this._orderedList = [], this._init(t, e, n, r) }i.prototype.run = function (t, e, n, i) { this._init(t, e, n, i); for (let o = 0, s = this.dataset.length; o < s; o++) if (this._processed[o] !== 1) { this._processed[o] = 1, this.clusters.push([o]); const a = this.clusters.length - 1; this._orderedList.push(o); const u = new r(null, null, 'asc'); const l = this._regionQuery(o); void 0 !== this._distanceToCore(o) && (this._updateQueue(o, l, u), this._expandCluster(a, u)) } return this.clusters }, i.prototype.getReachabilityPlot = function () { for (var t = [], e = 0, n = this._orderedList.length; e < n; e++) { const r = this._orderedList[e]; const i = this._reachability[r]; t.push([r, i]) } return t }, i.prototype._init = function (t, e, n, r) { if (t) { if (!(t instanceof Array)) throw Error('Dataset must be of type array, ' + typeof t + ' given'); this.dataset = t, this.clusters = [], this._reachability = new Array(this.dataset.length), this._processed = new Array(this.dataset.length), this._coreDistance = 0, this._orderedList = [] }e && (this.epsilon = e), n && (this.minPts = n), r && (this.distance = r) }, i.prototype._updateQueue = function (t, e, n) { const r = this; this._coreDistance = this._distanceToCore(t), e.forEach(function (e) { if (void 0 === r._processed[e]) { const i = r.distance(r.dataset[t], r.dataset[e]); const o = Math.max(r._coreDistance, i); void 0 === r._reachability[e] ? (r._reachability[e] = o, n.insert(e, o)) : o < r._reachability[e] && (r._reachability[e] = o, n.remove(e), n.insert(e, o)) } }) }, i.prototype._expandCluster = function (t, e) { for (let n = e.getElements(), r = 0, i = n.length; r < i; r++) { const o = n[r]; if (void 0 === this._processed[o]) { const s = this._regionQuery(o); this._processed[o] = 1, this.clusters[t].push(o), this._orderedList.push(o), void 0 !== this._distanceToCore(o) && (this._updateQueue(o, s, e), this._expandCluster(t, e)) } } }, i.prototype._distanceToCore = function (t) { for (let e = this.epsilon, n = 0; n < e; n++) if (this._regionQuery(t, n).length >= this.minPts) return n }, i.prototype._regionQuery = function (t, e) { e = e || this.epsilon; for (var n = [], r = 0, i = this.dataset.length; r < i; r++) this.distance(this.dataset[t], this.dataset[r]) < e && n.push(r); return n }, i.prototype._euclideanDistance = function (t, e) { for (var n = 0, r = Math.min(t.length, e.length); r--;)n += (t[r] - e[r]) * (t[r] - e[r]); return Math.sqrt(n) }, t.exports && (t.exports = i) }, 7985: t => { function e (t, e, n) { this._queue = [], this._priorities = [], this._sorting = 'desc', this._init(t, e, n) }e.prototype.insert = function (t, e) { for (var n = this._queue.length, r = n; r--;) { const i = this._priorities[r]; this._sorting === 'desc' ? e > i && (n = r) : e < i && (n = r) } this._insertAt(t, e, n) }, e.prototype.remove = function (t) { for (let e = this._queue.length; e--;) if (t === this._queue[e]) { this._queue.splice(e, 1), this._priorities.splice(e, 1); break } }, e.prototype.forEach = function (t) { this._queue.forEach(t) }, e.prototype.getElements = function () { return this._queue }, e.prototype.getElementPriority = function (t) { return this._priorities[t] }, e.prototype.getPriorities = function () { return this._priorities }, e.prototype.getElementsWithPriorities = function () { for (var t = [], e = 0, n = this._queue.length; e < n; e++)t.push([this._queue[e], this._priorities[e]]); return t }, e.prototype._init = function (t, e, n) { if (t && e) { if (this._queue = [], this._priorities = [], t.length !== e.length) throw new Error('Arrays must have the same length'); for (let r = 0; r < t.length; r++) this.insert(t[r], e[r]) }n && (this._sorting = n) }, e.prototype._insertAt = function (t, e, n) { this._queue.length === n ? (this._queue.push(t), this._priorities.push(e)) : (this._queue.splice(n, 0, t), this._priorities.splice(n, 0, e)) }, t.exports && (t.exports = e) }, 2606: (t, e, n) => { t.exports && (t.exports = { DBSCAN: n(8317), KMEANS: n(3781), OPTICS: n(3763), PriorityQueue: n(7985) }) }, 9187: t => { 'use strict'; function e (t, e, r) { r = r || 2; let o; let s; let a; let u; let f; let h; let g; const d = e && e.length; const y = d ? e[0] * r : t.length; let v = n(t, 0, y, r, !0); const _ = []; if (!v || v.next === v.prev) return _; if (d && (v = (function (t, e, r, i) { let o; let s; let a; const u = []; for (o = 0, s = e.length; o < s; o++)(a = n(t, e[o] * i, o < s - 1 ? e[o + 1] * i : t.length, i, !1)) === a.next && (a.steiner = !0), u.push(p(a)); for (u.sort(l), o = 0; o < u.length; o++)r = c(u[o], r); return r }(t, e, v, r))), t.length > 80 * r) { o = a = t[0], s = u = t[1]; for (let m = r; m < y; m += r)(f = t[m]) < o && (o = f), (h = t[m + 1]) < s && (s = h), f > a && (a = f), h > u && (u = h); g = (g = Math.max(a - o, u - s)) !== 0 ? 32767 / g : 0 } return i(v, _, r, o, s, g, 0), _ } function n (t, e, n, r, i) { let o, s; if (i === N(t, e, n, r) > 0) for (o = e; o < n; o += r)s = w(o, t[o], t[o + 1], s); else for (o = n - r; o >= e; o -= r)s = w(o, t[o], t[o + 1], s); return s && v(s, s.next) && (I(s), s = s.next), s } function r (t, e) { if (!t) return t; e || (e = t); let n; let r = t; do { if (n = !1, r.steiner || !v(r, r.next) && y(r.prev, r, r.next) !== 0)r = r.next; else { if (I(r), (r = e = r.prev) === r.next) break; n = !0 } } while (n || r !== e); return e } function i (t, e, n, l, c, f, p) { if (t) { !p && f && (function (t, e, n, r) { let i = t; do { i.z === 0 && (i.z = h(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next } while (i !== t); i.prevZ.nextZ = null, i.prevZ = null, (function (t) { let e; let n; let r; let i; let o; let s; let a; let u; let l = 1; do { for (n = t, t = null, o = null, s = 0; n;) { for (s++, r = n, a = 0, e = 0; e < l && (a++, r = r.nextZ); e++);for (u = l; a > 0 || u > 0 && r;)a !== 0 && (u === 0 || !r || n.z <= r.z) ? (i = n, n = n.nextZ, a--) : (i = r, r = r.nextZ, u--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i; n = r }o.nextZ = null, l *= 2 } while (s > 1) }(i)) }(t, l, c, f)); for (var g, d, y = t; t.prev !== t.next;) if (g = t.prev, d = t.next, f ? s(t, l, c, f) : o(t))e.push(g.i / n | 0), e.push(t.i / n | 0), e.push(d.i / n | 0), I(t), t = d.next, y = d.next; else if ((t = d) === y) { p ? p === 1 ? i(t = a(r(t), e, n), e, n, l, c, f, 2) : p === 2 && u(t, e, n, l, c, f) : i(r(t), e, n, l, c, f, 1); break } } } function o (t) { const e = t.prev; const n = t; const r = t.next; if (y(e, n, r) >= 0) return !1; for (let i = e.x, o = n.x, s = r.x, a = e.y, u = n.y, l = r.y, c = i < o ? i < s ? i : s : o < s ? o : s, f = a < u ? a < l ? a : l : u < l ? u : l, h = i > o ? i > s ? i : s : o > s ? o : s, p = a > u ? a > l ? a : l : u > l ? u : l, d = r.next; d !== e;) { if (d.x >= c && d.x <= h && d.y >= f && d.y <= p && g(i, a, o, u, s, l, d.x, d.y) && y(d.prev, d, d.next) >= 0) return !1; d = d.next } return !0 } function s (t, e, n, r) { const i = t.prev; const o = t; const s = t.next; if (y(i, o, s) >= 0) return !1; for (var a = i.x, u = o.x, l = s.x, c = i.y, f = o.y, p = s.y, d = a < u ? a < l ? a : l : u < l ? u : l, v = c < f ? c < p ? c : p : f < p ? f : p, _ = a > u ? a > l ? a : l : u > l ? u : l, m = c > f ? c > p ? c : p : f > p ? f : p, x = h(d, v, e, n, r), b = h(_, m, e, n, r), E = t.prevZ, w = t.nextZ; E && E.z >= x && w && w.z <= b;) { if (E.x >= d && E.x <= _ && E.y >= v && E.y <= m && E !== i && E !== s && g(a, c, u, f, l, p, E.x, E.y) && y(E.prev, E, E.next) >= 0) return !1; if (E = E.prevZ, w.x >= d && w.x <= _ && w.y >= v && w.y <= m && w !== i && w !== s && g(a, c, u, f, l, p, w.x, w.y) && y(w.prev, w, w.next) >= 0) return !1; w = w.nextZ } for (;E && E.z >= x;) { if (E.x >= d && E.x <= _ && E.y >= v && E.y <= m && E !== i && E !== s && g(a, c, u, f, l, p, E.x, E.y) && y(E.prev, E, E.next) >= 0) return !1; E = E.prevZ } for (;w && w.z <= b;) { if (w.x >= d && w.x <= _ && w.y >= v && w.y <= m && w !== i && w !== s && g(a, c, u, f, l, p, w.x, w.y) && y(w.prev, w, w.next) >= 0) return !1; w = w.nextZ } return !0 } function a (t, e, n) { let i = t; do { const o = i.prev; const s = i.next.next; !v(o, s) && _(o, i, i.next, s) && b(o, s) && b(s, o) && (e.push(o.i / n | 0), e.push(i.i / n | 0), e.push(s.i / n | 0), I(i), I(i.next), i = t = s), i = i.next } while (i !== t); return r(i) } function u (t, e, n, o, s, a) { let u = t; do { for (let l = u.next.next; l !== u.prev;) { if (u.i !== l.i && d(u, l)) { let c = E(u, l); return u = r(u, u.next), c = r(c, c.next), i(u, e, n, o, s, a, 0), void i(c, e, n, o, s, a, 0) }l = l.next }u = u.next } while (u !== t) } function l (t, e) { return t.x - e.x } function c (t, e) { const n = (function (t, e) { let n; let r = e; const i = t.x; const o = t.y; let s = -1 / 0; do { if (o <= r.y && o >= r.next.y && r.next.y !== r.y) { const a = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y); if (a <= i && a > s && (s = a, n = r.x < r.next.x ? r : r.next, a === i)) return n }r = r.next } while (r !== e); if (!n) return null; let u; const l = n; const c = n.x; const h = n.y; let p = 1 / 0; r = n; do { i >= r.x && r.x >= c && i !== r.x && g(o < h ? i : s, o, c, h, o < h ? s : i, o, r.x, r.y) && (u = Math.abs(o - r.y) / (i - r.x), b(r, t) && (u < p || u === p && (r.x > n.x || r.x === n.x && f(n, r))) && (n = r, p = u)), r = r.next } while (r !== l); return n }(t, e)); if (!n) return e; const i = E(n, t); return r(i, i.next), r(n, n.next) } function f (t, e) { return y(t.prev, t, e.prev) < 0 && y(e.next, t, t.next) < 0 } function h (t, e, n, r, i) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - n) * i | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = (e - r) * i | 0) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function p (t) { let e = t; let n = t; do { (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next } while (e !== t); return n } function g (t, e, n, r, i, o, s, a) { return (i - s) * (e - a) >= (t - s) * (o - a) && (t - s) * (r - a) >= (n - s) * (e - a) && (n - s) * (o - a) >= (i - s) * (r - a) } function d (t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) { let n = t; do { if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && _(n, n.next, t, e)) return !0; n = n.next } while (n !== t); return !1 }(t, e)) && (b(t, e) && b(e, t) && (function (t, e) { let n = t; let r = !1; const i = (t.x + e.x) / 2; const o = (t.y + e.y) / 2; do { n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next } while (n !== t); return r }(t, e)) && (y(t.prev, t, e.prev) || y(t, e.prev, e)) || v(t, e) && y(t.prev, t, t.next) > 0 && y(e.prev, e, e.next) > 0) } function y (t, e, n) { return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y) } function v (t, e) { return t.x === e.x && t.y === e.y } function _ (t, e, n, r) { const i = x(y(t, e, n)); const o = x(y(t, e, r)); const s = x(y(n, r, t)); const a = x(y(n, r, e)); return i !== o && s !== a || !(i !== 0 || !m(t, n, e)) || !(o !== 0 || !m(t, r, e)) || !(s !== 0 || !m(n, t, r)) || !(a !== 0 || !m(n, e, r)) } function m (t, e, n) { return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y) } function x (t) { return t > 0 ? 1 : t < 0 ? -1 : 0 } function b (t, e) { return y(t.prev, t, t.next) < 0 ? y(t, e, t.next) >= 0 && y(t, t.prev, e) >= 0 : y(t, e, t.prev) < 0 || y(t, t.next, e) < 0 } function E (t, e) { const n = new S(t.i, t.x, t.y); const r = new S(e.i, e.x, e.y); const i = t.next; const o = e.prev; return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r } function w (t, e, n, r) { const i = new S(t, e, n); return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i } function I (t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function S (t, e, n) { this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function N (t, e, n, r) { for (var i = 0, o = e, s = n - r; o < n; o += r)i += (t[s] - t[o]) * (t[o + 1] + t[s + 1]), s = o; return i }t.exports = e, t.exports.default = e, e.deviation = function (t, e, n, r) { const i = e && e.length; const o = i ? e[0] * n : t.length; let s = Math.abs(N(t, 0, o, n)); if (i) for (var a = 0, u = e.length; a < u; a++) { const l = e[a] * n; const c = a < u - 1 ? e[a + 1] * n : t.length; s -= Math.abs(N(t, l, c, n)) } let f = 0; for (a = 0; a < r.length; a += 3) { const h = r[a] * n; const p = r[a + 1] * n; const g = r[a + 2] * n; f += Math.abs((t[h] - t[g]) * (t[p + 1] - t[h + 1]) - (t[h] - t[p]) * (t[g + 1] - t[h + 1])) } return s === 0 && f === 0 ? 0 : Math.abs((f - s) / s) }, e.flatten = function (t) { for (var e = t[0][0].length, n = { vertices: [], holes: [], dimensions: e }, r = 0, i = 0; i < t.length; i++) { for (let o = 0; o < t[i].length; o++) for (let s = 0; s < e; s++)n.vertices.push(t[i][o][s]); i > 0 && (r += t[i - 1].length, n.holes.push(r)) } return n } }, 7648: t => { 'use strict'; const e = 'Function.prototype.bind called on incompatible '; const n = Array.prototype.slice; const r = Object.prototype.toString; const i = '[object Function]'; t.exports = function (t) { const o = this; if (typeof o !== 'function' || r.call(o) !== i) throw new TypeError(e + o); for (var s, a = n.call(arguments, 1), u = function () { if (this instanceof s) { const e = o.apply(this, a.concat(n.call(arguments))); return Object(e) === e ? e : this } return o.apply(t, a.concat(n.call(arguments))) }, l = Math.max(0, o.length - a.length), c = [], f = 0; f < l; f++)c.push('$' + f); if (s = Function('binder', 'return function (' + c.join(',') + '){ return binder.apply(this,arguments); }')(u), o.prototype) { const h = function () {}; h.prototype = o.prototype, s.prototype = new h(), h.prototype = null } return s } }, 8612: (t, e, n) => { 'use strict'; const r = n(7648); t.exports = Function.prototype.bind || r }, 5972: t => { 'use strict'; const e = function () { return typeof function () {}.name === 'string' }; let n = Object.getOwnPropertyDescriptor; if (n) try { n([], 'length') } catch (t) { n = null }e.functionsHaveConfigurableNames = function () { if (!e() || !n) return !1; const t = n(function () {}, 'name'); return !!t && !!t.configurable }; const r = Function.prototype.bind; e.boundFunctionsHaveNames = function () { return e() && typeof r === 'function' && function () {}.bind().name !== '' }, t.exports = e }, 9657: (t, e, n) => { const r = n(251); const i = function (t) { this.precision = t && t.precision ? t.precision : 17, this.direction = !(!t || !t.direction) && t.direction, this.pseudoNode = !(!t || !t.pseudoNode) && t.pseudoNode, this.objectComparator = t && t.objectComparator ? t.objectComparator : a }; function o (t) { return t.coordinates.map(function (e) { return { type: t.type.replace('Multi', ''), coordinates: e } }) } function s (t, e) { return t.hasOwnProperty('coordinates') ? t.coordinates.length === e.coordinates.length : t.length === e.length } function a (t, e) { return r(t, e, { strict: !0 }) }i.prototype.compare = function (t, e) { if (t.type !== e.type || !s(t, e)) return !1; switch (t.type) { case 'Point':return this.compareCoord(t.coordinates, e.coordinates); case 'LineString':return this.compareLine(t.coordinates, e.coordinates, 0, !1); case 'Polygon':return this.comparePolygon(t, e); case 'Feature':return this.compareFeature(t, e); default:if (t.type.indexOf('Multi') === 0) { const n = this; const r = o(t); const i = o(e); return r.every(function (t) { return this.some(function (e) { return n.compare(t, e) }) }, i) } } return !1 }, i.prototype.compareCoord = function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++) if (t[n].toFixed(this.precision) !== e[n].toFixed(this.precision)) return !1; return !0 }, i.prototype.compareLine = function (t, e, n, r) { if (!s(t, e)) return !1; const i = this.pseudoNode ? t : this.removePseudo(t); let o = this.pseudoNode ? e : this.removePseudo(e); if (!r || this.compareCoord(i[0], o[0]) || (o = this.fixStartIndex(o, i))) { const a = this.compareCoord(i[n], o[n]); return this.direction || a ? this.comparePath(i, o) : !!this.compareCoord(i[n], o[o.length - (1 + n)]) && this.comparePath(i.slice().reverse(), o) } }, i.prototype.fixStartIndex = function (t, e) { for (var n, r = -1, i = 0; i < t.length; i++) if (this.compareCoord(t[i], e[0])) { r = i; break } return r >= 0 && (n = [].concat(t.slice(r, t.length), t.slice(1, r + 1))), n }, i.prototype.comparePath = function (t, e) { const n = this; return t.every(function (t, e) { return n.compareCoord(t, this[e]) }, e) }, i.prototype.comparePolygon = function (t, e) { if (this.compareLine(t.coordinates[0], e.coordinates[0], 1, !0)) { const n = t.coordinates.slice(1, t.coordinates.length); const r = e.coordinates.slice(1, e.coordinates.length); const i = this; return n.every(function (t) { return this.some(function (e) { return i.compareLine(t, e, 1, !0) }) }, r) } return !1 }, i.prototype.compareFeature = function (t, e) { return !(t.id !== e.id || !this.objectComparator(t.properties, e.properties) || !this.compareBBox(t, e)) && this.compare(t.geometry, e.geometry) }, i.prototype.compareBBox = function (t, e) { return !!(!t.bbox && !e.bbox || t.bbox && e.bbox && this.compareCoord(t.bbox, e.bbox)) }, i.prototype.removePseudo = function (t) { return t }, t.exports = i }, 1787: (t, e, n) => { const r = n(4056); const i = n(4102); const o = n(1540); const s = n(9705).default; const a = o.featureEach; const u = (o.coordEach, i.polygon, i.featureCollection); function l (t) { const e = new r(t); return e.insert = function (t) { if (t.type !== 'Feature') throw new Error('invalid feature'); return t.bbox = t.bbox ? t.bbox : s(t), r.prototype.insert.call(this, t) }, e.load = function (t) { const e = []; return Array.isArray(t) ? t.forEach(function (t) { if (t.type !== 'Feature') throw new Error('invalid features'); t.bbox = t.bbox ? t.bbox : s(t), e.push(t) }) : a(t, function (t) { if (t.type !== 'Feature') throw new Error('invalid features'); t.bbox = t.bbox ? t.bbox : s(t), e.push(t) }), r.prototype.load.call(this, e) }, e.remove = function (t, e) { if (t.type !== 'Feature') throw new Error('invalid feature'); return t.bbox = t.bbox ? t.bbox : s(t), r.prototype.remove.call(this, t, e) }, e.clear = function () { return r.prototype.clear.call(this) }, e.search = function (t) { const e = r.prototype.search.call(this, this.toBBox(t)); return u(e) }, e.collides = function (t) { return r.prototype.collides.call(this, this.toBBox(t)) }, e.all = function () { const t = r.prototype.all.call(this); return u(t) }, e.toJSON = function () { return r.prototype.toJSON.call(this) }, e.fromJSON = function (t) { return r.prototype.fromJSON.call(this, t) }, e.toBBox = function (t) { let e; if (t.bbox)e = t.bbox; else if (Array.isArray(t) && t.length === 4)e = t; else if (Array.isArray(t) && t.length === 6)e = [t[0], t[1], t[3], t[4]]; else if (t.type === 'Feature')e = s(t); else { if (t.type !== 'FeatureCollection') throw new Error('invalid geojson'); e = s(t) } return { minX: e[0], minY: e[1], maxX: e[2], maxY: e[3] } }, e }t.exports = l, t.exports.default = l }, 4056: function (t) { t.exports = (function () { 'use strict'; function t (t, r, i, o, s) { !(function t (n, r, i, o, s) { for (;o > i;) { if (o - i > 600) { const a = o - i + 1; const u = r - i + 1; const l = Math.log(a); const c = 0.5 * Math.exp(2 * l / 3); const f = 0.5 * Math.sqrt(l * c * (a - c) / a) * (u - a / 2 < 0 ? -1 : 1); t(n, r, Math.max(i, Math.floor(r - u * c / a + f)), Math.min(o, Math.floor(r + (a - u) * c / a + f)), s) } const h = n[r]; let p = i; let g = o; for (e(n, i, r), s(n[o], h) > 0 && e(n, i, o); p < g;) { for (e(n, p, g), p++, g--; s(n[p], h) < 0;)p++; for (;s(n[g], h) > 0;)g-- }s(n[i], h) === 0 ? e(n, i, g) : e(n, ++g, o), g <= r && (i = g + 1), r <= g && (o = g - 1) } }(t, r, i || 0, o || t.length - 1, s || n)) } function e (t, e, n) { const r = t[e]; t[e] = t[n], t[n] = r } function n (t, e) { return t < e ? -1 : t > e ? 1 : 0 } const r = function (t) { void 0 === t && (t = 9), this._maxEntries = Math.max(4, t), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear() }; function i (t, e, n) { if (!n) return e.indexOf(t); for (let r = 0; r < e.length; r++) if (n(t, e[r])) return r; return -1 } function o (t, e) { s(t, 0, t.children.length, e, t) } function s (t, e, n, r, i) { i || (i = g(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0; for (let o = e; o < n; o++) { const s = t.children[o]; a(i, t.leaf ? r(s) : s) } return i } function a (t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function u (t, e) { return t.minX - e.minX } function l (t, e) { return t.minY - e.minY } function c (t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function f (t) { return t.maxX - t.minX + (t.maxY - t.minY) } function h (t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function p (t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function g (t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function d (e, n, r, i, o) { for (let s = [n, r]; s.length;) if (!((r = s.pop()) - (n = s.pop()) <= i)) { const a = n + Math.ceil((r - n) / i / 2) * i; t(e, a, n, r, o), s.push(n, a, a, r) } } return r.prototype.all = function () { return this._all(this.data, []) }, r.prototype.search = function (t) { let e = this.data; const n = []; if (!p(t, e)) return n; for (let r = this.toBBox, i = []; e;) { for (let o = 0; o < e.children.length; o++) { const s = e.children[o]; const a = e.leaf ? r(s) : s; p(t, a) && (e.leaf ? n.push(s) : h(t, a) ? this._all(s, n) : i.push(s)) }e = i.pop() } return n }, r.prototype.collides = function (t) { let e = this.data; if (!p(t, e)) return !1; for (let n = []; e;) { for (let r = 0; r < e.children.length; r++) { const i = e.children[r]; const o = e.leaf ? this.toBBox(i) : i; if (p(t, o)) { if (e.leaf || h(t, o)) return !0; n.push(i) } }e = n.pop() } return !1 }, r.prototype.load = function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0; e < t.length; e++) this.insert(t[e]); return this } let n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { const r = this.data; this.data = n, n = r } this._insert(n, this.data.height - n.height - 1, !0) } else this.data = n; return this }, r.prototype.insert = function (t) { return t && this._insert(t, this.data.height - 1), this }, r.prototype.clear = function () { return this.data = g([]), this }, r.prototype.remove = function (t, e) { if (!t) return this; for (var n, r, o, s = this.data, a = this.toBBox(t), u = [], l = []; s || u.length;) { if (s || (s = u.pop(), r = u[u.length - 1], n = l.pop(), o = !0), s.leaf) { const c = i(t, s.children, e); if (c !== -1) return s.children.splice(c, 1), u.push(s), this._condense(u), this }o || s.leaf || !h(s, a) ? r ? (n++, s = r.children[n], o = !1) : s = null : (u.push(s), l.push(n), n = 0, r = s, s = s.children[0]) } return this }, r.prototype.toBBox = function (t) { return t }, r.prototype.compareMinX = function (t, e) { return t.minX - e.minX }, r.prototype.compareMinY = function (t, e) { return t.minY - e.minY }, r.prototype.toJSON = function () { return this.data }, r.prototype.fromJSON = function (t) { return this.data = t, this }, r.prototype._all = function (t, e) { for (let n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, r.prototype._build = function (t, e, n, r) { let i; const s = n - e + 1; let a = this._maxEntries; if (s <= a) return o(i = g(t.slice(e, n + 1)), this.toBBox), i; r || (r = Math.ceil(Math.log(s) / Math.log(a)), a = Math.ceil(s / Math.pow(a, r - 1))), (i = g([])).leaf = !1, i.height = r; const u = Math.ceil(s / a); const l = u * Math.ceil(Math.sqrt(a)); d(t, e, n, l, this.compareMinX); for (let c = e; c <= n; c += l) { const f = Math.min(c + l - 1, n); d(t, c, f, u, this.compareMinY); for (let h = c; h <= f; h += u) { const p = Math.min(h + u - 1, f); i.children.push(this._build(t, h, p, r - 1)) } } return o(i, this.toBBox), i }, r.prototype._chooseSubtree = function (t, e, n, r) { for (;r.push(e), !e.leaf && r.length - 1 !== n;) { for (var i = 1 / 0, o = 1 / 0, s = void 0, a = 0; a < e.children.length; a++) { const u = e.children[a]; const l = c(u); const f = (h = t, p = u, (Math.max(p.maxX, h.maxX) - Math.min(p.minX, h.minX)) * (Math.max(p.maxY, h.maxY) - Math.min(p.minY, h.minY)) - l); f < o ? (o = f, i = l < i ? l : i, s = u) : f === o && l < i && (i = l, s = u) }e = s || e.children[0] } let h, p; return e }, r.prototype._insert = function (t, e, n) { const r = n ? t : this.toBBox(t); const i = []; const o = this._chooseSubtree(r, this.data, e, i); for (o.children.push(t), a(o, r); e >= 0 && i[e].children.length > this._maxEntries;) this._split(i, e), e--; this._adjustParentBBoxes(r, i, e) }, r.prototype._split = function (t, e) { const n = t[e]; const r = n.children.length; const i = this._minEntries; this._chooseSplitAxis(n, i, r); const s = this._chooseSplitIndex(n, i, r); const a = g(n.children.splice(s, n.children.length - s)); a.height = n.height, a.leaf = n.leaf, o(n, this.toBBox), o(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) }, r.prototype._splitRoot = function (t, e) { this.data = g([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox) }, r.prototype._chooseSplitIndex = function (t, e, n) { for (var r, i, o, a, u, l, f, h = 1 / 0, p = 1 / 0, g = e; g <= n - e; g++) { const d = s(t, 0, g, this.toBBox); const y = s(t, g, n, this.toBBox); const v = (i = d, o = y, void 0, void 0, void 0, void 0, a = Math.max(i.minX, o.minX), u = Math.max(i.minY, o.minY), l = Math.min(i.maxX, o.maxX), f = Math.min(i.maxY, o.maxY), Math.max(0, l - a) * Math.max(0, f - u)); const _ = c(d) + c(y); v < h ? (h = v, r = g, p = _ < p ? _ : p) : v === h && _ < p && (p = _, r = g) } return r || n - e }, r.prototype._chooseSplitAxis = function (t, e, n) { const r = t.leaf ? this.compareMinX : u; const i = t.leaf ? this.compareMinY : l; this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r) }, r.prototype._allDistMargin = function (t, e, n, r) { t.children.sort(r); for (var i = this.toBBox, o = s(t, 0, e, i), u = s(t, n - e, n, i), l = f(o) + f(u), c = e; c < n - e; c++) { const h = t.children[c]; a(o, t.leaf ? i(h) : h), l += f(o) } for (let p = n - e - 1; p >= e; p--) { const g = t.children[p]; a(u, t.leaf ? i(g) : g), l += f(u) } return l }, r.prototype._adjustParentBBoxes = function (t, e, n) { for (let r = n; r >= 0; r--)a(e[r], t) }, r.prototype._condense = function (t) { for (let e = t.length - 1, n = void 0; e >= 0; e--)t[e].children.length === 0 ? e > 0 ? (n = t[e - 1].children).splice(n.indexOf(t[e]), 1) : this.clear() : o(t[e], this.toBBox) }, r }()) }, 210: (t, e, n) => { 'use strict'; let r; const i = SyntaxError; const o = Function; const s = TypeError; const a = function (t) { try { return o('"use strict"; return (' + t + ').constructor;')() } catch (t) {} }; let u = Object.getOwnPropertyDescriptor; if (u) try { u({}, '') } catch (t) { u = null } const l = function () { throw new s() }; const c = u ? (function () { try { return l } catch (t) { try { return u(arguments, 'callee').get } catch (t) { return l } } }()) : l; const f = n(1405)(); const h = Object.getPrototypeOf || function (t) { return t.__proto__ }; const p = {}; const g = typeof Uint8Array === 'undefined' ? r : h(Uint8Array); const d = { '%AggregateError%': typeof AggregateError === 'undefined' ? r : AggregateError, '%Array%': Array, '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? r : ArrayBuffer, '%ArrayIteratorPrototype%': f ? h([][Symbol.iterator]()) : r, '%AsyncFromSyncIteratorPrototype%': r, '%AsyncFunction%': p, '%AsyncGenerator%': p, '%AsyncGeneratorFunction%': p, '%AsyncIteratorPrototype%': p, '%Atomics%': typeof Atomics === 'undefined' ? r : Atomics, '%BigInt%': typeof BigInt === 'undefined' ? r : BigInt, '%Boolean%': Boolean, '%DataView%': typeof DataView === 'undefined' ? r : DataView, '%Date%': Date, '%decodeURI%': decodeURI, '%decodeURIComponent%': decodeURIComponent, '%encodeURI%': encodeURI, '%encodeURIComponent%': encodeURIComponent, '%Error%': Error, '%eval%': eval, '%EvalError%': EvalError, '%Float32Array%': typeof Float32Array === 'undefined' ? r : Float32Array, '%Float64Array%': typeof Float64Array === 'undefined' ? r : Float64Array, '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? r : FinalizationRegistry, '%Function%': o, '%GeneratorFunction%': p, '%Int8Array%': typeof Int8Array === 'undefined' ? r : Int8Array, '%Int16Array%': typeof Int16Array === 'undefined' ? r : Int16Array, '%Int32Array%': typeof Int32Array === 'undefined' ? r : Int32Array, '%isFinite%': isFinite, '%isNaN%': isNaN, '%IteratorPrototype%': f ? h(h([][Symbol.iterator]())) : r, '%JSON%': typeof JSON === 'object' ? JSON : r, '%Map%': typeof Map === 'undefined' ? r : Map, '%MapIteratorPrototype%': typeof Map !== 'undefined' && f ? h((new Map())[Symbol.iterator]()) : r, '%Math%': Math, '%Number%': Number, '%Object%': Object, '%parseFloat%': parseFloat, '%parseInt%': parseInt, '%Promise%': typeof Promise === 'undefined' ? r : Promise, '%Proxy%': typeof Proxy === 'undefined' ? r : Proxy, '%RangeError%': RangeError, '%ReferenceError%': ReferenceError, '%Reflect%': typeof Reflect === 'undefined' ? r : Reflect, '%RegExp%': RegExp, '%Set%': typeof Set === 'undefined' ? r : Set, '%SetIteratorPrototype%': typeof Set !== 'undefined' && f ? h((new Set())[Symbol.iterator]()) : r, '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? r : SharedArrayBuffer, '%String%': String, '%StringIteratorPrototype%': f ? h(''[Symbol.iterator]()) : r, '%Symbol%': f ? Symbol : r, '%SyntaxError%': i, '%ThrowTypeError%': c, '%TypedArray%': g, '%TypeError%': s, '%Uint8Array%': typeof Uint8Array === 'undefined' ? r : Uint8Array, '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? r : Uint8ClampedArray, '%Uint16Array%': typeof Uint16Array === 'undefined' ? r : Uint16Array, '%Uint32Array%': typeof Uint32Array === 'undefined' ? r : Uint32Array, '%URIError%': URIError, '%WeakMap%': typeof WeakMap === 'undefined' ? r : WeakMap, '%WeakRef%': typeof WeakRef === 'undefined' ? r : WeakRef, '%WeakSet%': typeof WeakSet === 'undefined' ? r : WeakSet }; const y = function t (e) { let n; if (e === '%AsyncFunction%')n = a('async function () {}'); else if (e === '%GeneratorFunction%')n = a('function* () {}'); else if (e === '%AsyncGeneratorFunction%')n = a('async function* () {}'); else if (e === '%AsyncGenerator%') { const r = t('%AsyncGeneratorFunction%'); r && (n = r.prototype) } else if (e === '%AsyncIteratorPrototype%') { const i = t('%AsyncGenerator%'); i && (n = h(i.prototype)) } return d[e] = n, n }; const v = { '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'], '%ArrayPrototype%': ['Array', 'prototype'], '%ArrayProto_entries%': ['Array', 'prototype', 'entries'], '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'], '%ArrayProto_keys%': ['Array', 'prototype', 'keys'], '%ArrayProto_values%': ['Array', 'prototype', 'values'], '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'], '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'], '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'], '%BooleanPrototype%': ['Boolean', 'prototype'], '%DataViewPrototype%': ['DataView', 'prototype'], '%DatePrototype%': ['Date', 'prototype'], '%ErrorPrototype%': ['Error', 'prototype'], '%EvalErrorPrototype%': ['EvalError', 'prototype'], '%Float32ArrayPrototype%': ['Float32Array', 'prototype'], '%Float64ArrayPrototype%': ['Float64Array', 'prototype'], '%FunctionPrototype%': ['Function', 'prototype'], '%Generator%': ['GeneratorFunction', 'prototype'], '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'], '%Int8ArrayPrototype%': ['Int8Array', 'prototype'], '%Int16ArrayPrototype%': ['Int16Array', 'prototype'], '%Int32ArrayPrototype%': ['Int32Array', 'prototype'], '%JSONParse%': ['JSON', 'parse'], '%JSONStringify%': ['JSON', 'stringify'], '%MapPrototype%': ['Map', 'prototype'], '%NumberPrototype%': ['Number', 'prototype'], '%ObjectPrototype%': ['Object', 'prototype'], '%ObjProto_toString%': ['Object', 'prototype', 'toString'], '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'], '%PromisePrototype%': ['Promise', 'prototype'], '%PromiseProto_then%': ['Promise', 'prototype', 'then'], '%Promise_all%': ['Promise', 'all'], '%Promise_reject%': ['Promise', 'reject'], '%Promise_resolve%': ['Promise', 'resolve'], '%RangeErrorPrototype%': ['RangeError', 'prototype'], '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'], '%RegExpPrototype%': ['RegExp', 'prototype'], '%SetPrototype%': ['Set', 'prototype'], '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'], '%StringPrototype%': ['String', 'prototype'], '%SymbolPrototype%': ['Symbol', 'prototype'], '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'], '%TypedArrayPrototype%': ['TypedArray', 'prototype'], '%TypeErrorPrototype%': ['TypeError', 'prototype'], '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'], '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'], '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'], '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'], '%URIErrorPrototype%': ['URIError', 'prototype'], '%WeakMapPrototype%': ['WeakMap', 'prototype'], '%WeakSetPrototype%': ['WeakSet', 'prototype'] }; const _ = n(8612); const m = n(7642); const x = _.call(Function.call, Array.prototype.concat); const b = _.call(Function.apply, Array.prototype.splice); const E = _.call(Function.call, String.prototype.replace); const w = _.call(Function.call, String.prototype.slice); const I = _.call(Function.call, RegExp.prototype.exec); const S = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g; const N = /\\(\\)?/g; const P = function (t) { const e = w(t, 0, 1); const n = w(t, -1); if (e === '%' && n !== '%') throw new i('invalid intrinsic syntax, expected closing `%`'); if (n === '%' && e !== '%') throw new i('invalid intrinsic syntax, expected opening `%`'); const r = []; return E(t, S, function (t, e, n, i) { r[r.length] = n ? E(i, N, '$1') : e || t }), r }; const C = function (t, e) { let n; let r = t; if (m(v, r) && (r = '%' + (n = v[r])[0] + '%'), m(d, r)) { let o = d[r]; if (o === p && (o = y(r)), void 0 === o && !e) throw new s('intrinsic ' + t + ' exists, but is not available. Please file an issue!'); return { alias: n, name: r, value: o } } throw new i('intrinsic ' + t + ' does not exist!') }; t.exports = function (t, e) { if (typeof t !== 'string' || t.length === 0) throw new s('intrinsic name must be a non-empty string'); if (arguments.length > 1 && typeof e !== 'boolean') throw new s('"allowMissing" argument must be a boolean'); if (I(/^%?[^%]*%?$/, t) === null) throw new i('`%` may not be present anywhere but at the beginning and end of the intrinsic name'); const n = P(t); let r = n.length > 0 ? n[0] : ''; const o = C('%' + r + '%', e); let a = o.name; let l = o.value; let c = !1; const f = o.alias; f && (r = f[0], b(n, x([0, 1], f))); for (let h = 1, p = !0; h < n.length; h += 1) { const g = n[h]; const y = w(g, 0, 1); const v = w(g, -1); if ((y === '"' || y === "'" || y === '`' || v === '"' || v === "'" || v === '`') && y !== v) throw new i('property names with quotes must have matching quotes'); if (g !== 'constructor' && p || (c = !0), m(d, a = '%' + (r += '.' + g) + '%'))l = d[a]; else if (l != null) { if (!(g in l)) { if (!e) throw new s('base intrinsic for ' + t + ' exists, but the property is not available.'); return } if (u && h + 1 >= n.length) { const _ = u(l, g); l = (p = !!_) && 'get' in _ && !('originalValue' in _.get) ? _.get : l[g] } else p = m(l, g), l = l[g]; p && !c && (d[a] = l) } } return l } }, 1044: (t, e, n) => { 'use strict'; const r = n(210)('%Object.defineProperty%', !0); const i = function () { if (r) try { return r({}, 'a', { value: 1 }), !0 } catch (t) { return !1 } return !1 }; i.hasArrayLengthDefineBug = function () { if (!i()) return null; try { return r([], 'length', { value: 1 }).length !== 1 } catch (t) { return !0 } }, t.exports = i }, 1405: (t, e, n) => { 'use strict'; const r = typeof Symbol !== 'undefined' && Symbol; const i = n(5419); t.exports = function () { return typeof r === 'function' && typeof Symbol === 'function' && typeof r('foo') === 'symbol' && typeof Symbol('bar') === 'symbol' && i() } }, 5419: t => { 'use strict'; t.exports = function () { if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') return !1; if (typeof Symbol.iterator === 'symbol') return !0; const t = {}; let e = Symbol('test'); const n = Object(e); if (typeof e === 'string') return !1; if (Object.prototype.toString.call(e) !== '[object Symbol]') return !1; if (Object.prototype.toString.call(n) !== '[object Symbol]') return !1; for (e in t[e] = 42, t) return !1; if (typeof Object.keys === 'function' && Object.keys(t).length !== 0) return !1; if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(t).length !== 0) return !1; const r = Object.getOwnPropertySymbols(t); if (r.length !== 1 || r[0] !== e) return !1; if (!Object.prototype.propertyIsEnumerable.call(t, e)) return !1; if (typeof Object.getOwnPropertyDescriptor === 'function') { const i = Object.getOwnPropertyDescriptor(t, e); if (i.value !== 42 || !0 !== i.enumerable) return !1 } return !0 } }, 6410: (t, e, n) => { 'use strict'; const r = n(5419); t.exports = function () { return r() && !!Symbol.toStringTag } }, 7642: (t, e, n) => { 'use strict'; const r = n(8612); t.exports = r.call(Function.call, Object.prototype.hasOwnProperty) }, 2584: (t, e, n) => { 'use strict'; const r = n(6410)(); const i = n(1924)('Object.prototype.toString'); const o = function (t) { return !(r && t && typeof t === 'object' && Symbol.toStringTag in t) && i(t) === '[object Arguments]' }; const s = function (t) { return !!o(t) || t !== null && typeof t === 'object' && typeof t.length === 'number' && t.length >= 0 && i(t) !== '[object Array]' && i(t.callee) === '[object Function]' }; const a = (function () { return o(arguments) }()); o.isLegacyArguments = s, t.exports = a ? o : s }, 8923: (t, e, n) => { 'use strict'; const r = Date.prototype.getDay; const i = Object.prototype.toString; const o = n(6410)(); t.exports = function (t) { return typeof t === 'object' && t !== null && (o ? (function (t) { try { return r.call(t), !0 } catch (t) { return !1 } }(t)) : i.call(t) === '[object Date]') } }, 8420: (t, e, n) => { 'use strict'; let r; let i; let o; let s; const a = n(1924); const u = n(6410)(); if (u) { r = a('Object.prototype.hasOwnProperty'), i = a('RegExp.prototype.exec'), o = {}; const l = function () { throw o }; s = { toString: l, valueOf: l }, typeof Symbol.toPrimitive === 'symbol' && (s[Symbol.toPrimitive] = l) } const c = a('Object.prototype.toString'); const f = Object.getOwnPropertyDescriptor; t.exports = u ? function (t) { if (!t || typeof t !== 'object') return !1; const e = f(t, 'lastIndex'); if (!e || !r(e, 'value')) return !1; try { i(t, s) } catch (t) { return t === o } } : function (t) { return !(!t || typeof t !== 'object' && typeof t !== 'function') && c(t) === '[object RegExp]' } }, 7418: t => { 'use strict'; const e = Object.getOwnPropertySymbols; const n = Object.prototype.hasOwnProperty; const r = Object.prototype.propertyIsEnumerable; function i (t) { if (t == null) throw new TypeError('Object.assign cannot be called with null or undefined'); return Object(t) }t.exports = (function () { try { if (!Object.assign) return !1; const t = new String('abc'); if (t[5] = 'de', Object.getOwnPropertyNames(t)[0] === '5') return !1; for (var e = {}, n = 0; n < 10; n++)e['_' + String.fromCharCode(n)] = n; if (Object.getOwnPropertyNames(e).map(function (t) { return e[t] }).join('') !== '0123456789') return !1; const r = {}; return 'abcdefghijklmnopqrst'.split('').forEach(function (t) { r[t] = t }), Object.keys(Object.assign({}, r)).join('') === 'abcdefghijklmnopqrst' } catch (t) { return !1 } }()) ? Object.assign : function (t, o) { for (var s, a, u = i(t), l = 1; l < arguments.length; l++) { for (const c in s = Object(arguments[l]))n.call(s, c) && (u[c] = s[c]); if (e) { a = e(s); for (let f = 0; f < a.length; f++)r.call(s, a[f]) && (u[a[f]] = s[a[f]]) } } return u } }, 4244: t => { 'use strict'; const e = function (t) { return t != t }; t.exports = function (t, n) { return t === 0 && n === 0 ? 1 / t == 1 / n : t === n || !(!e(t) || !e(n)) } }, 609: (t, e, n) => { 'use strict'; const r = n(4289); const i = n(5559); const o = n(4244); const s = n(5624); const a = n(2281); const u = i(s(), Object); r(u, { getPolyfill: s, implementation: o, shim: a }), t.exports = u }, 5624: (t, e, n) => { 'use strict'; const r = n(4244); t.exports = function () { return typeof Object.is === 'function' ? Object.is : r } }, 2281: (t, e, n) => { 'use strict'; const r = n(5624); const i = n(4289); t.exports = function () { const t = r(); return i(Object, { is: t }, { is: function () { return Object.is !== t } }), t } }, 8987: (t, e, n) => { 'use strict'; let r; if (!Object.keys) { const i = Object.prototype.hasOwnProperty; const o = Object.prototype.toString; const s = n(1414); const a = Object.prototype.propertyIsEnumerable; const u = !a.call({ toString: null }, 'toString'); const l = a.call(function () {}, 'prototype'); const c = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor']; const f = function (t) { const e = t.constructor; return e && e.prototype === t }; const h = { $applicationCache: !0, $console: !0, $external: !0, $frame: !0, $frameElement: !0, $frames: !0, $innerHeight: !0, $innerWidth: !0, $onmozfullscreenchange: !0, $onmozfullscreenerror: !0, $outerHeight: !0, $outerWidth: !0, $pageXOffset: !0, $pageYOffset: !0, $parent: !0, $scrollLeft: !0, $scrollTop: !0, $scrollX: !0, $scrollY: !0, $self: !0, $webkitIndexedDB: !0, $webkitStorageInfo: !0, $window: !0 }; const p = (function () { if (typeof window === 'undefined') return !1; for (const t in window) try { if (!h['$' + t] && i.call(window, t) && window[t] !== null && typeof window[t] === 'object') try { f(window[t]) } catch (t) { return !0 } } catch (t) { return !0 } return !1 }()); r = function (t) { const e = t !== null && typeof t === 'object'; const n = o.call(t) === '[object Function]'; const r = s(t); const a = e && o.call(t) === '[object String]'; const h = []; if (!e && !n && !r) throw new TypeError('Object.keys called on a non-object'); const g = l && n; if (a && t.length > 0 && !i.call(t, 0)) for (let d = 0; d < t.length; ++d)h.push(String(d)); if (r && t.length > 0) for (let y = 0; y < t.length; ++y)h.push(String(y)); else for (const v in t)g && v === 'prototype' || !i.call(t, v) || h.push(String(v)); if (u) for (let _ = (function (t) { if (typeof window === 'undefined' || !p) return f(t); try { return f(t) } catch (t) { return !1 } }(t)), m = 0; m < c.length; ++m)_ && c[m] === 'constructor' || !i.call(t, c[m]) || h.push(c[m]); return h } }t.exports = r }, 2215: (t, e, n) => { 'use strict'; const r = Array.prototype.slice; const i = n(1414); const o = Object.keys; const s = o ? function (t) { return o(t) } : n(8987); const a = Object.keys; s.shim = function () { if (Object.keys) { const t = (function () { const t = Object.keys(arguments); return t && t.length === arguments.length }(1, 2)); t || (Object.keys = function (t) { return i(t) ? a(r.call(t)) : a(t) }) } else Object.keys = s; return Object.keys || s }, t.exports = s }, 1414: t => { 'use strict'; const e = Object.prototype.toString; t.exports = function (t) { const n = e.call(t); let r = n === '[object Arguments]'; return r || (r = n !== '[object Array]' && t !== null && typeof t === 'object' && typeof t.length === 'number' && t.length >= 0 && e.call(t.callee) === '[object Function]'), r } }, 1895: t => { t.exports = function (t, e, n, r) { const i = t[0]; const o = t[1]; let s = !1; void 0 === n && (n = 0), void 0 === r && (r = e.length); for (let a = (r - n) / 2, u = 0, l = a - 1; u < a; l = u++) { const c = e[n + 2 * u + 0]; const f = e[n + 2 * u + 1]; const h = e[n + 2 * l + 0]; const p = e[n + 2 * l + 1]; f > o != p > o && i < (h - c) * (o - f) / (p - f) + c && (s = !s) } return s } }, 6960: (t, e, n) => { const r = n(1895); const i = n(8139); t.exports = function (t, e, n, o) { return e.length > 0 && Array.isArray(e[0]) ? i(t, e, n, o) : r(t, e, n, o) }, t.exports.nested = i, t.exports.flat = r }, 8139: t => { t.exports = function (t, e, n, r) { const i = t[0]; const o = t[1]; let s = !1; void 0 === n && (n = 0), void 0 === r && (r = e.length); for (let a = r - n, u = 0, l = a - 1; u < a; l = u++) { const c = e[u + n][0]; const f = e[u + n][1]; const h = e[l + n][0]; const p = e[l + n][1]; f > o != p > o && i < (h - c) * (o - f) / (p - f) + c && (s = !s) } return s } }, 2676: function (t) { t.exports = (function () { 'use strict'; function t (t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function') } function e (t, e) { for (let n = 0; n < e.length; n++) { const r = e[n]; r.enumerable = r.enumerable || !1, r.configurable = !0, 'value' in r && (r.writable = !0), Object.defineProperty(t, r.key, r) } } function n (t, n, r) { return n && e(t.prototype, n), r && e(t, r), t } const r = function (t, e) { this.next = null, this.key = t, this.data = e, this.left = null, this.right = null }; function i (t, e) { return t > e ? 1 : t < e ? -1 : 0 } function o (t, e, n) { for (var i = new r(null, null), o = i, s = i; ;) { const a = n(t, e.key); if (a < 0) { if (e.left === null) break; if (n(t, e.left.key) < 0) { var u = e.left; if (e.left = u.right, u.right = e, (e = u).left === null) break }s.left = e, s = e, e = e.left } else { if (!(a > 0)) break; if (e.right === null) break; if (n(t, e.right.key) > 0 && (u = e.right, e.right = u.left, u.left = e, (e = u).right === null)) break; o.right = e, o = e, e = e.right } } return o.right = e.left, s.left = e.right, e.left = i.right, e.right = i.left, e } function s (t, e, n, i) { const s = new r(t, e); if (n === null) return s.left = s.right = null, s; const a = i(t, (n = o(t, n, i)).key); return a < 0 ? (s.left = n.left, s.right = n, n.left = null) : a >= 0 && (s.right = n.right, s.left = n, n.right = null), s } function a (t, e, n) { let r = null; let i = null; if (e) { const s = n((e = o(t, e, n)).key, t); s === 0 ? (r = e.left, i = e.right) : s < 0 ? (i = e.right, e.right = null, r = e) : (r = e.left, e.left = null, i = e) } return { left: r, right: i } } function u (t, e, n, r, i) { if (t) { r(e + (n ? '└── ' : '├── ') + i(t) + '\n'); const o = e + (n ? '    ' : '│   '); t.left && u(t.left, o, !1, r, i), t.right && u(t.right, o, !0, r, i) } } const l = (function () { function t (t) { void 0 === t && (t = i), this._root = null, this._size = 0, this._comparator = t } return t.prototype.insert = function (t, e) { return this._size++, this._root = s(t, e, this._root, this._comparator) }, t.prototype.add = function (t, e) { const n = new r(t, e); this._root === null && (n.left = n.right = null, this._size++, this._root = n); const i = this._comparator; const s = o(t, this._root, i); const a = i(t, s.key); return a === 0 ? this._root = s : (a < 0 ? (n.left = s.left, n.right = s, s.left = null) : a > 0 && (n.right = s.right, n.left = s, s.right = null), this._size++, this._root = n), this._root }, t.prototype.remove = function (t) { this._root = this._remove(t, this._root, this._comparator) }, t.prototype._remove = function (t, e, n) { let r; return e === null ? null : n(t, (e = o(t, e, n)).key) === 0 ? (e.left === null ? r = e.right : (r = o(t, e.left, n)).right = e.right, this._size--, r) : e }, t.prototype.pop = function () { let t = this._root; if (t) { for (;t.left;)t = t.left; return this._root = o(t.key, this._root, this._comparator), this._root = this._remove(t.key, this._root, this._comparator), { key: t.key, data: t.data } } return null }, t.prototype.findStatic = function (t) { for (let e = this._root, n = this._comparator; e;) { const r = n(t, e.key); if (r === 0) return e; e = r < 0 ? e.left : e.right } return null }, t.prototype.find = function (t) { return this._root && (this._root = o(t, this._root, this._comparator), this._comparator(t, this._root.key) !== 0) ? null : this._root }, t.prototype.contains = function (t) { for (let e = this._root, n = this._comparator; e;) { const r = n(t, e.key); if (r === 0) return !0; e = r < 0 ? e.left : e.right } return !1 }, t.prototype.forEach = function (t, e) { for (let n = this._root, r = [], i = !1; !i;)n !== null ? (r.push(n), n = n.left) : r.length !== 0 ? (n = r.pop(), t.call(e, n), n = n.right) : i = !0; return this }, t.prototype.range = function (t, e, n, r) { for (let i = [], o = this._comparator, s = this._root; i.length !== 0 || s;) if (s)i.push(s), s = s.left; else { if (o((s = i.pop()).key, e) > 0) break; if (o(s.key, t) >= 0 && n.call(r, s)) return this; s = s.right } return this }, t.prototype.keys = function () { const t = []; return this.forEach(function (e) { const n = e.key; return t.push(n) }), t }, t.prototype.values = function () { const t = []; return this.forEach(function (e) { const n = e.data; return t.push(n) }), t }, t.prototype.min = function () { return this._root ? this.minNode(this._root).key : null }, t.prototype.max = function () { return this._root ? this.maxNode(this._root).key : null }, t.prototype.minNode = function (t) { if (void 0 === t && (t = this._root), t) for (;t.left;)t = t.left; return t }, t.prototype.maxNode = function (t) { if (void 0 === t && (t = this._root), t) for (;t.right;)t = t.right; return t }, t.prototype.at = function (t) { for (let e = this._root, n = !1, r = 0, i = []; !n;) if (e)i.push(e), e = e.left; else if (i.length > 0) { if (e = i.pop(), r === t) return e; r++, e = e.right } else n = !0; return null }, t.prototype.next = function (t) { let e = this._root; let n = null; if (t.right) { for (n = t.right; n.left;)n = n.left; return n } for (let r = this._comparator; e;) { const i = r(t.key, e.key); if (i === 0) break; i < 0 ? (n = e, e = e.left) : e = e.right } return n }, t.prototype.prev = function (t) { let e = this._root; let n = null; if (t.left !== null) { for (n = t.left; n.right;)n = n.right; return n } for (let r = this._comparator; e;) { const i = r(t.key, e.key); if (i === 0) break; i < 0 ? e = e.left : (n = e, e = e.right) } return n }, t.prototype.clear = function () { return this._root = null, this._size = 0, this }, t.prototype.toList = function () { return (function (t) { for (var e = t, n = [], i = !1, o = new r(null, null), s = o; !i;)e ? (n.push(e), e = e.left) : n.length > 0 ? e = (e = s = s.next = n.pop()).right : i = !0; return s.next = null, o.next }(this._root)) }, t.prototype.load = function (t, e, n) { void 0 === e && (e = []), void 0 === n && (n = !1); let i = t.length; const o = this._comparator; if (n && h(t, e, 0, i - 1, o), this._root === null) this._root = c(t, e, 0, i), this._size = i; else { const s = (function (t, e, n) { for (var i = new r(null, null), o = i, s = t, a = e; s !== null && a !== null;)n(s.key, a.key) < 0 ? (o.next = s, s = s.next) : (o.next = a, a = a.next), o = o.next; return s !== null ? o.next = s : a !== null && (o.next = a), i.next }(this.toList(), (function (t, e) { for (var n = new r(null, null), i = n, o = 0; o < t.length; o++)i = i.next = new r(t[o], e[o]); return i.next = null, n.next }(t, e)), o)); i = this._size + i, this._root = f({ head: s }, 0, i) } return this }, t.prototype.isEmpty = function () { return this._root === null }, Object.defineProperty(t.prototype, 'size', { get: function () { return this._size }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, 'root', { get: function () { return this._root }, enumerable: !0, configurable: !0 }), t.prototype.toString = function (t) { void 0 === t && (t = function (t) { return String(t.key) }); const e = []; return u(this._root, '', !0, function (t) { return e.push(t) }, t), e.join('') }, t.prototype.update = function (t, e, n) { const r = this._comparator; const i = a(t, this._root, r); let u = i.left; let l = i.right; r(t, e) < 0 ? l = s(e, n, l, r) : u = s(e, n, u, r), this._root = (function (t, e, n) { return e === null ? t : (t === null || ((e = o(t.key, e, n)).left = t), e) }(u, l, r)) }, t.prototype.split = function (t) { return a(t, this._root, this._comparator) }, t }()); function c (t, e, n, i) { const o = i - n; if (o > 0) { const s = n + Math.floor(o / 2); const a = t[s]; const u = e[s]; const l = new r(a, u); return l.left = c(t, e, n, s), l.right = c(t, e, s + 1, i), l } return null } function f (t, e, n) { const r = n - e; if (r > 0) { const i = e + Math.floor(r / 2); const o = f(t, e, i); const s = t.head; return s.left = o, t.head = t.head.next, s.right = f(t, i + 1, n), s } return null } function h (t, e, n, r, i) { if (!(n >= r)) { for (var o = t[n + r >> 1], s = n - 1, a = r + 1; ;) { do { s++ } while (i(t[s], o) < 0); do { a-- } while (i(t[a], o) > 0); if (s >= a) break; let u = t[s]; t[s] = t[a], t[a] = u, u = e[s], e[s] = e[a], e[a] = u }h(t, e, n, a, i), h(t, e, a + 1, r, i) } } const p = function (t, e) { return t.ll.x <= e.x && e.x <= t.ur.x && t.ll.y <= e.y && e.y <= t.ur.y }; const g = function (t, e) { if (e.ur.x < t.ll.x || t.ur.x < e.ll.x || e.ur.y < t.ll.y || t.ur.y < e.ll.y) return null; const n = t.ll.x < e.ll.x ? e.ll.x : t.ll.x; const r = t.ur.x < e.ur.x ? t.ur.x : e.ur.x; return { ll: { x: n, y: t.ll.y < e.ll.y ? e.ll.y : t.ll.y }, ur: { x: r, y: t.ur.y < e.ur.y ? t.ur.y : e.ur.y } } }; let d = Number.EPSILON; void 0 === d && (d = Math.pow(2, -52)); const y = d * d; const v = function (t, e) { if (-d < t && t < d && -d < e && e < d) return 0; const n = t - e; return n * n < y * t * e ? 0 : t < e ? -1 : 1 }; const _ = (function () { function e () { t(this, e), this.reset() } return n(e, [{ key: 'reset', value: function () { this.xRounder = new m(), this.yRounder = new m() } }, { key: 'round', value: function (t, e) { return { x: this.xRounder.round(t), y: this.yRounder.round(e) } } }]), e }()); var m = (function () { function e () { t(this, e), this.tree = new l(), this.round(0) } return n(e, [{ key: 'round', value: function (t) { const e = this.tree.add(t); const n = this.tree.prev(e); if (n !== null && v(e.key, n.key) === 0) return this.tree.remove(t), n.key; const r = this.tree.next(e); return r !== null && v(e.key, r.key) === 0 ? (this.tree.remove(t), r.key) : t } }]), e }()); const x = new _(); const b = function (t, e) { return t.x * e.y - t.y * e.x }; const E = function (t, e) { return t.x * e.x + t.y * e.y }; const w = function (t, e, n) { const r = { x: e.x - t.x, y: e.y - t.y }; const i = { x: n.x - t.x, y: n.y - t.y }; const o = b(r, i); return v(o, 0) }; const I = function (t) { return Math.sqrt(E(t, t)) }; const S = function (t, e, n) { const r = { x: e.x - t.x, y: e.y - t.y }; const i = { x: n.x - t.x, y: n.y - t.y }; return E(i, r) / I(i) / I(r) }; const N = function (t, e, n) { return e.y === 0 ? null : { x: t.x + e.x / e.y * (n - t.y), y: n } }; const P = function (t, e, n) { return e.x === 0 ? null : { x: n, y: t.y + e.y / e.x * (n - t.x) } }; const C = (function () { function e (n, r) { t(this, e), void 0 === n.events ? n.events = [this] : n.events.push(this), this.point = n, this.isLeft = r } return n(e, null, [{ key: 'compare', value: function (t, n) { const r = e.comparePoints(t.point, n.point); return r !== 0 ? r : (t.point !== n.point && t.link(n), t.isLeft !== n.isLeft ? t.isLeft ? 1 : -1 : O.compare(t.segment, n.segment)) } }, { key: 'comparePoints', value: function (t, e) { return t.x < e.x ? -1 : t.x > e.x ? 1 : t.y < e.y ? -1 : t.y > e.y ? 1 : 0 } }]), n(e, [{ key: 'link', value: function (t) { if (t.point === this.point) throw new Error('Tried to link already linked events'); for (let e = t.point.events, n = 0, r = e.length; n < r; n++) { const i = e[n]; this.point.events.push(i), i.point = this.point } this.checkForConsuming() } }, { key: 'checkForConsuming', value: function () { for (let t = this.point.events.length, e = 0; e < t; e++) { const n = this.point.events[e]; if (void 0 === n.segment.consumedBy) for (let r = e + 1; r < t; r++) { const i = this.point.events[r]; void 0 === i.consumedBy && n.otherSE.point.events === i.otherSE.point.events && n.segment.consume(i.segment) } } } }, { key: 'getAvailableLinkedEvents', value: function () { for (var t = [], e = 0, n = this.point.events.length; e < n; e++) { const r = this.point.events[e]; r !== this && !r.segment.ringOut && r.segment.isInResult() && t.push(r) } return t } }, { key: 'getLeftmostComparator', value: function (t) { const e = this; const n = new Map(); const r = function (r) { let i; let o; let s; let a; let u; const l = r.otherSE; n.set(r, { sine: (i = e.point, o = t.point, s = l.point, a = { x: o.x - i.x, y: o.y - i.y }, u = { x: s.x - i.x, y: s.y - i.y }, b(u, a) / I(u) / I(a)), cosine: S(e.point, t.point, l.point) }) }; return function (t, e) { n.has(t) || r(t), n.has(e) || r(e); const i = n.get(t); const o = i.sine; const s = i.cosine; const a = n.get(e); const u = a.sine; const l = a.cosine; return o >= 0 && u >= 0 ? s < l ? 1 : s > l ? -1 : 0 : o < 0 && u < 0 ? s < l ? -1 : s > l ? 1 : 0 : u < o ? -1 : u > o ? 1 : 0 } } }]), e }()); let M = 0; var O = (function () { function e (n, r, i, o) { t(this, e), this.id = ++M, this.leftSE = n, n.segment = this, n.otherSE = r, this.rightSE = r, r.segment = this, r.otherSE = n, this.rings = i, this.windings = o } return n(e, null, [{ key: 'compare', value: function (t, e) { const n = t.leftSE.point.x; const r = e.leftSE.point.x; const i = t.rightSE.point.x; const o = e.rightSE.point.x; if (o < n) return 1; if (i < r) return -1; const s = t.leftSE.point.y; const a = e.leftSE.point.y; const u = t.rightSE.point.y; const l = e.rightSE.point.y; if (n < r) { if (a < s && a < u) return 1; if (a > s && a > u) return -1; const c = t.comparePoint(e.leftSE.point); if (c < 0) return 1; if (c > 0) return -1; const f = e.comparePoint(t.rightSE.point); return f !== 0 ? f : -1 } if (n > r) { if (s < a && s < l) return -1; if (s > a && s > l) return 1; const h = e.comparePoint(t.leftSE.point); if (h !== 0) return h; const p = t.comparePoint(e.rightSE.point); return p < 0 ? 1 : p > 0 ? -1 : 1 } if (s < a) return -1; if (s > a) return 1; if (i < o) { const g = e.comparePoint(t.rightSE.point); if (g !== 0) return g } if (i > o) { const d = t.comparePoint(e.rightSE.point); if (d < 0) return 1; if (d > 0) return -1 } if (i !== o) { const y = u - s; const v = i - n; const _ = l - a; const m = o - r; if (y > v && _ < m) return 1; if (y < v && _ > m) return -1 } return i > o ? 1 : i < o || u < l ? -1 : u > l ? 1 : t.id < e.id ? -1 : t.id > e.id ? 1 : 0 } }]), n(e, [{ key: 'replaceRightSE', value: function (t) { this.rightSE = t, this.rightSE.segment = this, this.rightSE.otherSE = this.leftSE, this.leftSE.otherSE = this.rightSE } }, { key: 'bbox', value: function () { const t = this.leftSE.point.y; const e = this.rightSE.point.y; return { ll: { x: this.leftSE.point.x, y: t < e ? t : e }, ur: { x: this.rightSE.point.x, y: t > e ? t : e } } } }, { key: 'vector', value: function () { return { x: this.rightSE.point.x - this.leftSE.point.x, y: this.rightSE.point.y - this.leftSE.point.y } } }, { key: 'isAnEndpoint', value: function (t) { return t.x === this.leftSE.point.x && t.y === this.leftSE.point.y || t.x === this.rightSE.point.x && t.y === this.rightSE.point.y } }, { key: 'comparePoint', value: function (t) { if (this.isAnEndpoint(t)) return 0; const e = this.leftSE.point; const n = this.rightSE.point; const r = this.vector(); if (e.x === n.x) return t.x === e.x ? 0 : t.x < e.x ? 1 : -1; const i = (t.y - e.y) / r.y; const o = e.x + i * r.x; if (t.x === o) return 0; const s = (t.x - e.x) / r.x; const a = e.y + s * r.y; return t.y === a ? 0 : t.y < a ? -1 : 1 } }, { key: 'getIntersection', value: function (t) { const e = this.bbox(); const n = t.bbox(); const r = g(e, n); if (r === null) return null; const i = this.leftSE.point; const o = this.rightSE.point; const s = t.leftSE.point; const a = t.rightSE.point; const u = p(e, s) && this.comparePoint(s) === 0; const l = p(n, i) && t.comparePoint(i) === 0; const c = p(e, a) && this.comparePoint(a) === 0; const f = p(n, o) && t.comparePoint(o) === 0; if (l && u) return f && !c ? o : !f && c ? a : null; if (l) return c && i.x === a.x && i.y === a.y ? null : i; if (u) return f && o.x === s.x && o.y === s.y ? null : s; if (f && c) return null; if (f) return o; if (c) return a; const h = (function (t, e, n, r) { if (e.x === 0) return P(n, r, t.x); if (r.x === 0) return P(t, e, n.x); if (e.y === 0) return N(n, r, t.y); if (r.y === 0) return N(t, e, n.y); const i = b(e, r); if (i == 0) return null; const o = { x: n.x - t.x, y: n.y - t.y }; const s = b(o, e) / i; const a = b(o, r) / i; return { x: (t.x + a * e.x + (n.x + s * r.x)) / 2, y: (t.y + a * e.y + (n.y + s * r.y)) / 2 } }(i, this.vector(), s, t.vector())); return h === null ? null : p(r, h) ? x.round(h.x, h.y) : null } }, { key: 'split', value: function (t) { const n = []; const r = void 0 !== t.events; const i = new C(t, !0); const o = new C(t, !1); const s = this.rightSE; this.replaceRightSE(o), n.push(o), n.push(i); const a = new e(i, s, this.rings.slice(), this.windings.slice()); return C.comparePoints(a.leftSE.point, a.rightSE.point) > 0 && a.swapEvents(), C.comparePoints(this.leftSE.point, this.rightSE.point) > 0 && this.swapEvents(), r && (i.checkForConsuming(), o.checkForConsuming()), n } }, { key: 'swapEvents', value: function () { const t = this.rightSE; this.rightSE = this.leftSE, this.leftSE = t, this.leftSE.isLeft = !0, this.rightSE.isLeft = !1; for (let e = 0, n = this.windings.length; e < n; e++) this.windings[e] *= -1 } }, { key: 'consume', value: function (t) { for (var n = this, r = t; n.consumedBy;)n = n.consumedBy; for (;r.consumedBy;)r = r.consumedBy; const i = e.compare(n, r); if (i !== 0) { if (i > 0) { const o = n; n = r, r = o } if (n.prev === r) { const s = n; n = r, r = s } for (let a = 0, u = r.rings.length; a < u; a++) { const l = r.rings[a]; const c = r.windings[a]; const f = n.rings.indexOf(l); f === -1 ? (n.rings.push(l), n.windings.push(c)) : n.windings[f] += c }r.rings = null, r.windings = null, r.consumedBy = n, r.leftSE.consumedBy = n.leftSE, r.rightSE.consumedBy = n.rightSE } } }, { key: 'prevInResult', value: function () { return void 0 !== this._prevInResult || (this.prev ? this.prev.isInResult() ? this._prevInResult = this.prev : this._prevInResult = this.prev.prevInResult() : this._prevInResult = null), this._prevInResult } }, { key: 'beforeState', value: function () { if (void 0 !== this._beforeState) return this._beforeState; if (this.prev) { const t = this.prev.consumedBy || this.prev; this._beforeState = t.afterState() } else this._beforeState = { rings: [], windings: [], multiPolys: [] }; return this._beforeState } }, { key: 'afterState', value: function () { if (void 0 !== this._afterState) return this._afterState; const t = this.beforeState(); this._afterState = { rings: t.rings.slice(0), windings: t.windings.slice(0), multiPolys: [] }; for (var e = this._afterState.rings, n = this._afterState.windings, r = this._afterState.multiPolys, i = 0, o = this.rings.length; i < o; i++) { const s = this.rings[i]; const a = this.windings[i]; const u = e.indexOf(s); u === -1 ? (e.push(s), n.push(a)) : n[u] += a } for (var l = [], c = [], f = 0, h = e.length; f < h; f++) if (n[f] !== 0) { const p = e[f]; const g = p.poly; if (c.indexOf(g) === -1) if (p.isExterior)l.push(g); else { c.indexOf(g) === -1 && c.push(g); const d = l.indexOf(p.poly); d !== -1 && l.splice(d, 1) } } for (let y = 0, v = l.length; y < v; y++) { const _ = l[y].multiPoly; r.indexOf(_) === -1 && r.push(_) } return this._afterState } }, { key: 'isInResult', value: function () { if (this.consumedBy) return !1; if (void 0 !== this._isInResult) return this._isInResult; const t = this.beforeState().multiPolys; const e = this.afterState().multiPolys; switch (q.type) { case 'union':var n = t.length === 0; var r = e.length === 0; this._isInResult = n !== r; break; case 'intersection':var i, o; t.length < e.length ? (i = t.length, o = e.length) : (i = e.length, o = t.length), this._isInResult = o === q.numMultiPolys && i < o; break; case 'xor':var s = Math.abs(t.length - e.length); this._isInResult = s % 2 == 1; break; case 'difference':var a = function (t) { return t.length === 1 && t[0].isSubject }; this._isInResult = a(t) !== a(e); break; default:throw new Error('Unrecognized operation type found '.concat(q.type)) } return this._isInResult } }], [{ key: 'fromRing', value: function (t, n, r) { let i; let o; let s; const a = C.comparePoints(t, n); if (a < 0)i = t, o = n, s = 1; else { if (!(a > 0)) throw new Error('Tried to create degenerate segment at ['.concat(t.x, ', ').concat(t.y, ']')); i = n, o = t, s = -1 } return new e(new C(i, !0), new C(o, !1), [r], [s]) } }]), e }()); const L = (function () { function e (n, r, i) { if (t(this, e), !Array.isArray(n) || n.length === 0) throw new Error('Input geometry is not a valid Polygon or MultiPolygon'); if (this.poly = r, this.isExterior = i, this.segments = [], typeof n[0][0] !== 'number' || typeof n[0][1] !== 'number') throw new Error('Input geometry is not a valid Polygon or MultiPolygon'); const o = x.round(n[0][0], n[0][1]); this.bbox = { ll: { x: o.x, y: o.y }, ur: { x: o.x, y: o.y } }; for (var s = o, a = 1, u = n.length; a < u; a++) { if (typeof n[a][0] !== 'number' || typeof n[a][1] !== 'number') throw new Error('Input geometry is not a valid Polygon or MultiPolygon'); const l = x.round(n[a][0], n[a][1]); l.x === s.x && l.y === s.y || (this.segments.push(O.fromRing(s, l, this)), l.x < this.bbox.ll.x && (this.bbox.ll.x = l.x), l.y < this.bbox.ll.y && (this.bbox.ll.y = l.y), l.x > this.bbox.ur.x && (this.bbox.ur.x = l.x), l.y > this.bbox.ur.y && (this.bbox.ur.y = l.y), s = l) }o.x === s.x && o.y === s.y || this.segments.push(O.fromRing(s, o, this)) } return n(e, [{ key: 'getSweepEvents', value: function () { for (var t = [], e = 0, n = this.segments.length; e < n; e++) { const r = this.segments[e]; t.push(r.leftSE), t.push(r.rightSE) } return t } }]), e }()); const R = (function () { function e (n, r) { if (t(this, e), !Array.isArray(n)) throw new Error('Input geometry is not a valid Polygon or MultiPolygon'); this.exteriorRing = new L(n[0], this, !0), this.bbox = { ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y }, ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y } }, this.interiorRings = []; for (let i = 1, o = n.length; i < o; i++) { const s = new L(n[i], this, !1); s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.interiorRings.push(s) } this.multiPoly = r } return n(e, [{ key: 'getSweepEvents', value: function () { for (var t = this.exteriorRing.getSweepEvents(), e = 0, n = this.interiorRings.length; e < n; e++) for (let r = this.interiorRings[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)t.push(r[i]); return t } }]), e }()); const A = (function () { function e (n, r) { if (t(this, e), !Array.isArray(n)) throw new Error('Input geometry is not a valid Polygon or MultiPolygon'); try { typeof n[0][0][0] === 'number' && (n = [n]) } catch (t) {} this.polys = [], this.bbox = { ll: { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY }, ur: { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY } }; for (let i = 0, o = n.length; i < o; i++) { const s = new R(n[i], this); s.bbox.ll.x < this.bbox.ll.x && (this.bbox.ll.x = s.bbox.ll.x), s.bbox.ll.y < this.bbox.ll.y && (this.bbox.ll.y = s.bbox.ll.y), s.bbox.ur.x > this.bbox.ur.x && (this.bbox.ur.x = s.bbox.ur.x), s.bbox.ur.y > this.bbox.ur.y && (this.bbox.ur.y = s.bbox.ur.y), this.polys.push(s) } this.isSubject = r } return n(e, [{ key: 'getSweepEvents', value: function () { for (var t = [], e = 0, n = this.polys.length; e < n; e++) for (let r = this.polys[e].getSweepEvents(), i = 0, o = r.length; i < o; i++)t.push(r[i]); return t } }]), e }()); const T = (function () { function e (n) { t(this, e), this.events = n; for (let r = 0, i = n.length; r < i; r++)n[r].segment.ringOut = this; this.poly = null } return n(e, null, [{ key: 'factory', value: function (t) { for (var n = [], r = 0, i = t.length; r < i; r++) { const o = t[r]; if (o.isInResult() && !o.ringOut) { for (var s = null, a = o.leftSE, u = o.rightSE, l = [a], c = a.point, f = []; s = a, a = u, l.push(a), a.point !== c;) for (;;) { const h = a.getAvailableLinkedEvents(); if (h.length === 0) { const p = l[0].point; const g = l[l.length - 1].point; throw new Error('Unable to complete output ring starting at ['.concat(p.x, ',') + ' '.concat(p.y, ']. Last matching segment found ends at') + ' ['.concat(g.x, ', ').concat(g.y, '].')) } if (h.length === 1) { u = h[0].otherSE; break } for (var d = null, y = 0, v = f.length; y < v; y++) if (f[y].point === a.point) { d = y; break } if (d === null) { f.push({ index: l.length, point: a.point }); const _ = a.getLeftmostComparator(s); u = h.sort(_)[0].otherSE; break } const m = f.splice(d)[0]; const x = l.splice(m.index); x.unshift(x[0].otherSE), n.push(new e(x.reverse())) }n.push(new e(l)) } } return n } }]), n(e, [{ key: 'getGeom', value: function () { for (var t = this.events[0].point, e = [t], n = 1, r = this.events.length - 1; n < r; n++) { const i = this.events[n].point; const o = this.events[n + 1].point; w(i, t, o) !== 0 && (e.push(i), t = i) } if (e.length === 1) return null; const s = e[0]; const a = e[1]; w(s, t, a) === 0 && e.shift(), e.push(e[0]); for (var u = this.isExteriorRing() ? 1 : -1, l = this.isExteriorRing() ? 0 : e.length - 1, c = this.isExteriorRing() ? e.length : -1, f = [], h = l; h != c; h += u)f.push([e[h].x, e[h].y]); return f } }, { key: 'isExteriorRing', value: function () { if (void 0 === this._isExteriorRing) { const t = this.enclosingRing(); this._isExteriorRing = !t || !t.isExteriorRing() } return this._isExteriorRing } }, { key: 'enclosingRing', value: function () { return void 0 === this._enclosingRing && (this._enclosingRing = this._calcEnclosingRing()), this._enclosingRing } }, { key: '_calcEnclosingRing', value: function () { for (var t = this.events[0], e = 1, n = this.events.length; e < n; e++) { const r = this.events[e]; C.compare(t, r) > 0 && (t = r) } for (let i = t.segment.prevInResult(), o = i ? i.prevInResult() : null; ;) { if (!i) return null; if (!o) return i.ringOut; if (o.ringOut !== i.ringOut) return o.ringOut.enclosingRing() !== i.ringOut ? i.ringOut : i.ringOut.enclosingRing(); i = o.prevInResult(), o = i ? i.prevInResult() : null } } }]), e }()); const D = (function () { function e (n) { t(this, e), this.exteriorRing = n, n.poly = this, this.interiorRings = [] } return n(e, [{ key: 'addInterior', value: function (t) { this.interiorRings.push(t), t.poly = this } }, { key: 'getGeom', value: function () { const t = [this.exteriorRing.getGeom()]; if (t[0] === null) return null; for (let e = 0, n = this.interiorRings.length; e < n; e++) { const r = this.interiorRings[e].getGeom(); r !== null && t.push(r) } return t } }]), e }()); const F = (function () { function e (n) { t(this, e), this.rings = n, this.polys = this._composePolys(n) } return n(e, [{ key: 'getGeom', value: function () { for (var t = [], e = 0, n = this.polys.length; e < n; e++) { const r = this.polys[e].getGeom(); r !== null && t.push(r) } return t } }, { key: '_composePolys', value: function (t) { for (var e = [], n = 0, r = t.length; n < r; n++) { const i = t[n]; if (!i.poly) if (i.isExteriorRing())e.push(new D(i)); else { const o = i.enclosingRing(); o.poly || e.push(new D(o)), o.poly.addInterior(i) } } return e } }]), e }()); const j = (function () { function e (n) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : O.compare; t(this, e), this.queue = n, this.tree = new l(r), this.segments = [] } return n(e, [{ key: 'process', value: function (t) { const e = t.segment; const n = []; if (t.consumedBy) return t.isLeft ? this.queue.remove(t.otherSE) : this.tree.remove(e), n; const r = t.isLeft ? this.tree.insert(e) : this.tree.find(e); if (!r) throw new Error('Unable to find segment #'.concat(e.id, ' ') + '['.concat(e.leftSE.point.x, ', ').concat(e.leftSE.point.y, '] -> ') + '['.concat(e.rightSE.point.x, ', ').concat(e.rightSE.point.y, '] ') + 'in SweepLine tree. Please submit a bug report.'); for (var i = r, o = r, s = void 0, a = void 0; void 0 === s;)(i = this.tree.prev(i)) === null ? s = null : void 0 === i.key.consumedBy && (s = i.key); for (;void 0 === a;)(o = this.tree.next(o)) === null ? a = null : void 0 === o.key.consumedBy && (a = o.key); if (t.isLeft) { let u = null; if (s) { const l = s.getIntersection(e); if (l !== null && (e.isAnEndpoint(l) || (u = l), !s.isAnEndpoint(l))) for (let c = this._splitSafely(s, l), f = 0, h = c.length; f < h; f++)n.push(c[f]) } let p = null; if (a) { const g = a.getIntersection(e); if (g !== null && (e.isAnEndpoint(g) || (p = g), !a.isAnEndpoint(g))) for (let d = this._splitSafely(a, g), y = 0, v = d.length; y < v; y++)n.push(d[y]) } if (u !== null || p !== null) { let _; _ = u === null ? p : p === null || C.comparePoints(u, p) <= 0 ? u : p, this.queue.remove(e.rightSE), n.push(e.rightSE); for (let m = e.split(_), x = 0, b = m.length; x < b; x++)n.push(m[x]) }n.length > 0 ? (this.tree.remove(e), n.push(t)) : (this.segments.push(e), e.prev = s) } else { if (s && a) { const E = s.getIntersection(a); if (E !== null) { if (!s.isAnEndpoint(E)) for (let w = this._splitSafely(s, E), I = 0, S = w.length; I < S; I++)n.push(w[I]); if (!a.isAnEndpoint(E)) for (let N = this._splitSafely(a, E), P = 0, M = N.length; P < M; P++)n.push(N[P]) } } this.tree.remove(e) } return n } }, { key: '_splitSafely', value: function (t, e) { this.tree.remove(t); const n = t.rightSE; this.queue.remove(n); const r = t.split(e); return r.push(n), void 0 === t.consumedBy && this.tree.insert(t), r } }]), e }()); const k = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6; const G = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6; var q = new (function () { function e () { t(this, e) } return n(e, [{ key: 'run', value: function (t, e, n) { q.type = t, x.reset(); for (var r = [new A(e, !0)], i = 0, o = n.length; i < o; i++)r.push(new A(n[i], !1)); if (q.numMultiPolys = r.length, q.type === 'difference') for (let s = r[0], a = 1; a < r.length;)g(r[a].bbox, s.bbox) !== null ? a++ : r.splice(a, 1); if (q.type === 'intersection') for (let u = 0, c = r.length; u < c; u++) for (let f = r[u], h = u + 1, p = r.length; h < p; h++) if (g(f.bbox, r[h].bbox) === null) return []; for (var d = new l(C.compare), y = 0, v = r.length; y < v; y++) for (let _ = r[y].getSweepEvents(), m = 0, b = _.length; m < b; m++) if (d.insert(_[m]), d.size > k) throw new Error('Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.'); for (var E = new j(d), w = d.size, I = d.pop(); I;) { const S = I.key; if (d.size === w) { const N = S.segment; throw new Error('Unable to pop() '.concat(S.isLeft ? 'left' : 'right', ' SweepEvent ') + '['.concat(S.point.x, ', ').concat(S.point.y, '] from segment #').concat(N.id, ' ') + '['.concat(N.leftSE.point.x, ', ').concat(N.leftSE.point.y, '] -> ') + '['.concat(N.rightSE.point.x, ', ').concat(N.rightSE.point.y, '] from queue. ') + 'Please file a bug report.') } if (d.size > k) throw new Error('Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.'); if (E.segments.length > G) throw new Error('Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.'); for (let P = E.process(S), M = 0, O = P.length; M < O; M++) { const L = P[M]; void 0 === L.consumedBy && d.insert(L) }w = d.size, I = d.pop() }x.reset(); const R = T.factory(E.segments); return new F(R).getGeom() } }]), e }())(); return { union: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return q.run('union', t, n) }, intersection: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return q.run('intersection', t, n) }, xor: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return q.run('xor', t, n) }, difference: function (t) { for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)n[r - 1] = arguments[r]; return q.run('difference', t, n) } } }()) }, 8166: function (t) { t.exports = (function () { 'use strict'; function t (n, r, i, o, s) { for (;o > i;) { if (o - i > 600) { const a = o - i + 1; const u = r - i + 1; const l = Math.log(a); const c = 0.5 * Math.exp(2 * l / 3); const f = 0.5 * Math.sqrt(l * c * (a - c) / a) * (u - a / 2 < 0 ? -1 : 1); t(n, r, Math.max(i, Math.floor(r - u * c / a + f)), Math.min(o, Math.floor(r + (a - u) * c / a + f)), s) } const h = n[r]; let p = i; let g = o; for (e(n, i, r), s(n[o], h) > 0 && e(n, i, o); p < g;) { for (e(n, p, g), p++, g--; s(n[p], h) < 0;)p++; for (;s(n[g], h) > 0;)g-- }s(n[i], h) === 0 ? e(n, i, g) : e(n, ++g, o), g <= r && (i = g + 1), r <= g && (o = g - 1) } } function e (t, e, n) { const r = t[e]; t[e] = t[n], t[n] = r } function n (t, e) { return t < e ? -1 : t > e ? 1 : 0 } return function (e, r, i, o, s) { t(e, r, i || 0, o || e.length - 1, s || n) } }()) }, 5510: (t, e, n) => { 'use strict'; t.exports = i, t.exports.default = i; const r = n(8166); function i (t, e) { if (!(this instanceof i)) return new i(t, e); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), e && this._initFormat(e), this.clear() } function o (t, e, n) { if (!n) return e.indexOf(t); for (let r = 0; r < e.length; r++) if (n(t, e[r])) return r; return -1 } function s (t, e) { a(t, 0, t.children.length, e, t) } function a (t, e, n, r, i) { i || (i = d(null)), i.minX = 1 / 0, i.minY = 1 / 0, i.maxX = -1 / 0, i.maxY = -1 / 0; for (var o, s = e; s < n; s++)o = t.children[s], u(i, t.leaf ? r(o) : o); return i } function u (t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t } function l (t, e) { return t.minX - e.minX } function c (t, e) { return t.minY - e.minY } function f (t) { return (t.maxX - t.minX) * (t.maxY - t.minY) } function h (t) { return t.maxX - t.minX + (t.maxY - t.minY) } function p (t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY } function g (t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY } function d (t) { return { children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 } } function y (t, e, n, i, o) { for (var s, a = [e, n]; a.length;)(n = a.pop()) - (e = a.pop()) <= i || (s = e + Math.ceil((n - e) / i / 2) * i, r(t, s, e, n, o), a.push(e, s, s, n)) }i.prototype = { all: function () { return this._all(this.data, []) }, search: function (t) { let e = this.data; const n = []; const r = this.toBBox; if (!g(t, e)) return n; for (var i, o, s, a, u = []; e;) { for (i = 0, o = e.children.length; i < o; i++)s = e.children[i], g(t, a = e.leaf ? r(s) : s) && (e.leaf ? n.push(s) : p(t, a) ? this._all(s, n) : u.push(s)); e = u.pop() } return n }, collides: function (t) { let e = this.data; const n = this.toBBox; if (!g(t, e)) return !1; for (var r, i, o, s, a = []; e;) { for (r = 0, i = e.children.length; r < i; r++) if (o = e.children[r], g(t, s = e.leaf ? n(o) : o)) { if (e.leaf || p(t, s)) return !0; a.push(o) }e = a.pop() } return !1 }, load: function (t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, n = t.length; e < n; e++) this.insert(t[e]); return this } let r = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === r.height) this._splitRoot(this.data, r); else { if (this.data.height < r.height) { const i = this.data; this.data = r, r = i } this._insert(r, this.data.height - r.height - 1, !0) } else this.data = r; return this }, insert: function (t) { return t && this._insert(t, this.data.height - 1), this }, clear: function () { return this.data = d([]), this }, remove: function (t, e) { if (!t) return this; for (var n, r, i, s, a = this.data, u = this.toBBox(t), l = [], c = []; a || l.length;) { if (a || (a = l.pop(), r = l[l.length - 1], n = c.pop(), s = !0), a.leaf && (i = o(t, a.children, e)) !== -1) return a.children.splice(i, 1), l.push(a), this._condense(l), this; s || a.leaf || !p(a, u) ? r ? (n++, a = r.children[n], s = !1) : a = null : (l.push(a), c.push(n), n = 0, r = a, a = a.children[0]) } return this }, toBBox: function (t) { return t }, compareMinX: l, compareMinY: c, toJSON: function () { return this.data }, fromJSON: function (t) { return this.data = t, this }, _all: function (t, e) { for (let n = []; t;)t.leaf ? e.push.apply(e, t.children) : n.push.apply(n, t.children), t = n.pop(); return e }, _build: function (t, e, n, r) { let i; const o = n - e + 1; let a = this._maxEntries; if (o <= a) return s(i = d(t.slice(e, n + 1)), this.toBBox), i; r || (r = Math.ceil(Math.log(o) / Math.log(a)), a = Math.ceil(o / Math.pow(a, r - 1))), (i = d([])).leaf = !1, i.height = r; let u; let l; let c; let f; const h = Math.ceil(o / a); const p = h * Math.ceil(Math.sqrt(a)); for (y(t, e, n, p, this.compareMinX), u = e; u <= n; u += p) for (y(t, u, c = Math.min(u + p - 1, n), h, this.compareMinY), l = u; l <= c; l += h)f = Math.min(l + h - 1, c), i.children.push(this._build(t, l, f, r - 1)); return s(i, this.toBBox), i }, _chooseSubtree: function (t, e, n, r) { for (var i, o, s, a, u, l, c, h, p, g; r.push(e), !e.leaf && r.length - 1 !== n;) { for (c = h = 1 / 0, i = 0, o = e.children.length; i < o; i++)u = f(s = e.children[i]), p = t, g = s, (l = (Math.max(g.maxX, p.maxX) - Math.min(g.minX, p.minX)) * (Math.max(g.maxY, p.maxY) - Math.min(g.minY, p.minY)) - u) < h ? (h = l, c = u < c ? u : c, a = s) : l === h && u < c && (c = u, a = s); e = a || e.children[0] } return e }, _insert: function (t, e, n) { const r = this.toBBox; const i = n ? t : r(t); const o = []; const s = this._chooseSubtree(i, this.data, e, o); for (s.children.push(t), u(s, i); e >= 0 && o[e].children.length > this._maxEntries;) this._split(o, e), e--; this._adjustParentBBoxes(i, o, e) }, _split: function (t, e) { const n = t[e]; const r = n.children.length; const i = this._minEntries; this._chooseSplitAxis(n, i, r); const o = this._chooseSplitIndex(n, i, r); const a = d(n.children.splice(o, n.children.length - o)); a.height = n.height, a.leaf = n.leaf, s(n, this.toBBox), s(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(n, a) }, _splitRoot: function (t, e) { this.data = d([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, s(this.data, this.toBBox) }, _chooseSplitIndex: function (t, e, n) { let r, i, o, s, u, l, c, h, p, g, d, y, v, _; for (l = c = 1 / 0, r = e; r <= n - e; r++)p = i = a(t, 0, r, this.toBBox), g = o = a(t, r, n, this.toBBox), void 0, void 0, void 0, void 0, d = Math.max(p.minX, g.minX), y = Math.max(p.minY, g.minY), v = Math.min(p.maxX, g.maxX), _ = Math.min(p.maxY, g.maxY), s = Math.max(0, v - d) * Math.max(0, _ - y), u = f(i) + f(o), s < l ? (l = s, h = r, c = u < c ? u : c) : s === l && u < c && (c = u, h = r); return h }, _chooseSplitAxis: function (t, e, n) { const r = t.leaf ? this.compareMinX : l; const i = t.leaf ? this.compareMinY : c; this._allDistMargin(t, e, n, r) < this._allDistMargin(t, e, n, i) && t.children.sort(r) }, _allDistMargin: function (t, e, n, r) { t.children.sort(r); let i; let o; const s = this.toBBox; const l = a(t, 0, e, s); const c = a(t, n - e, n, s); let f = h(l) + h(c); for (i = e; i < n - e; i++)o = t.children[i], u(l, t.leaf ? s(o) : o), f += h(l); for (i = n - e - 1; i >= e; i--)o = t.children[i], u(c, t.leaf ? s(o) : o), f += h(c); return f }, _adjustParentBBoxes: function (t, e, n) { for (let r = n; r >= 0; r--)u(e[r], t) }, _condense: function (t) { for (var e, n = t.length - 1; n >= 0; n--)t[n].children.length === 0 ? n > 0 ? (e = t[n - 1].children).splice(e.indexOf(t[n]), 1) : this.clear() : s(t[n], this.toBBox) }, _initFormat: function (t) { const e = ['return a', ' - b', ';']; this.compareMinX = new Function('a', 'b', e.join(t[0])), this.compareMinY = new Function('a', 'b', e.join(t[1])), this.toBBox = new Function('a', 'return {minX: a' + t[0] + ', minY: a' + t[1] + ', maxX: a' + t[2] + ', maxY: a' + t[3] + '};') } } }, 3697: (t, e, n) => { 'use strict'; const r = n(5972).functionsHaveConfigurableNames(); const i = Object; const o = TypeError; t.exports = function () { if (this != null && this !== i(this)) throw new o('RegExp.prototype.flags getter called on non-object'); let t = ''; return this.hasIndices && (t += 'd'), this.global && (t += 'g'), this.ignoreCase && (t += 'i'), this.multiline && (t += 'm'), this.dotAll && (t += 's'), this.unicode && (t += 'u'), this.sticky && (t += 'y'), t }, r && Object.defineProperty && Object.defineProperty(t.exports, 'name', { value: 'get flags' }) }, 2847: (t, e, n) => { 'use strict'; const r = n(4289); const i = n(5559); const o = n(3697); const s = n(1721); const a = n(2753); const u = i(s()); r(u, { getPolyfill: s, implementation: o, shim: a }), t.exports = u }, 1721: (t, e, n) => { 'use strict'; const r = n(3697); const i = n(4289).supportsDescriptors; const o = Object.getOwnPropertyDescriptor; t.exports = function () { if (i && /a/gim.flags === 'gim') { const t = o(RegExp.prototype, 'flags'); if (t && typeof t.get === 'function' && typeof RegExp.prototype.dotAll === 'boolean' && typeof RegExp.prototype.hasIndices === 'boolean') { let e = ''; const n = {}; if (Object.defineProperty(n, 'hasIndices', { get: function () { e += 'd' } }), Object.defineProperty(n, 'sticky', { get: function () { e += 'y' } }), e === 'dy') return t.get } } return r } }, 2753: (t, e, n) => { 'use strict'; const r = n(4289).supportsDescriptors; const i = n(1721); const o = Object.getOwnPropertyDescriptor; const s = Object.defineProperty; const a = TypeError; const u = Object.getPrototypeOf; const l = /a/; t.exports = function () { if (!r || !u) throw new a('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors'); const t = i(); const e = u(l); const n = o(e, 'flags'); return n && n.get === t || s(e, 'flags', { configurable: !0, enumerable: !1, get: t }), t } }, 8639: function (t, e) { !(function (t) { 'use strict'; const e = 134217729; function n (t, e, n, r, i) { let o; let s; let a; let u; let l = e[0]; let c = r[0]; let f = 0; let h = 0; c > l == c > -l ? (o = l, l = e[++f]) : (o = c, c = r[++h]); let p = 0; if (f < t && h < n) for (c > l == c > -l ? (a = o - ((s = l + o) - l), l = e[++f]) : (a = o - ((s = c + o) - c), c = r[++h]), o = s, a !== 0 && (i[p++] = a); f < t && h < n;)c > l == c > -l ? (a = o - ((s = o + l) - (u = s - o)) + (l - u), l = e[++f]) : (a = o - ((s = o + c) - (u = s - o)) + (c - u), c = r[++h]), o = s, a !== 0 && (i[p++] = a); for (;f < t;)a = o - ((s = o + l) - (u = s - o)) + (l - u), l = e[++f], o = s, a !== 0 && (i[p++] = a); for (;h < n;)a = o - ((s = o + c) - (u = s - o)) + (c - u), c = r[++h], o = s, a !== 0 && (i[p++] = a); return o === 0 && p !== 0 || (i[p++] = o), p } function r (t) { return new Float64Array(t) } const i = r(4); const o = r(8); const s = r(12); const a = r(16); const u = r(4); t.orient2d = function (t, r, l, c, f, h) { const p = (r - h) * (l - f); const g = (t - f) * (c - h); const d = p - g; if (p === 0 || g === 0 || p > 0 != g > 0) return d; const y = Math.abs(p + g); return Math.abs(d) >= 33306690738754716e-32 * y ? d : -(function (t, r, l, c, f, h, p) { let g, d, y, v, _, m, x, b, E, w, I, S, N, P, C, M, O, L; const R = t - f; const A = l - f; const T = r - h; const D = c - h; _ = (C = (b = R - (x = (m = e * R) - (m - R))) * (w = D - (E = (m = e * D) - (m - D))) - ((P = R * D) - x * E - b * E - x * w)) - (I = C - (O = (b = T - (x = (m = e * T) - (m - T))) * (w = A - (E = (m = e * A) - (m - A))) - ((M = T * A) - x * E - b * E - x * w))), i[0] = C - (I + _) + (_ - O), _ = (N = P - ((S = P + I) - (_ = S - P)) + (I - _)) - (I = N - M), i[1] = N - (I + _) + (_ - M), _ = (L = S + I) - S, i[2] = S - (L - _) + (I - _), i[3] = L; let F = (function (t, e) { let n = e[0]; for (let t = 1; t < 4; t++)n += e[t]; return n }(0, i)); let j = 22204460492503146e-32 * p; if (F >= j || -F >= j) return F; if (g = t - (R + (_ = t - R)) + (_ - f), y = l - (A + (_ = l - A)) + (_ - f), d = r - (T + (_ = r - T)) + (_ - h), v = c - (D + (_ = c - D)) + (_ - h), g === 0 && d === 0 && y === 0 && v === 0) return F; if (j = 11093356479670487e-47 * p + 33306690738754706e-32 * Math.abs(F), (F += R * v + D * g - (T * y + A * d)) >= j || -F >= j) return F; _ = (C = (b = g - (x = (m = e * g) - (m - g))) * (w = D - (E = (m = e * D) - (m - D))) - ((P = g * D) - x * E - b * E - x * w)) - (I = C - (O = (b = d - (x = (m = e * d) - (m - d))) * (w = A - (E = (m = e * A) - (m - A))) - ((M = d * A) - x * E - b * E - x * w))), u[0] = C - (I + _) + (_ - O), _ = (N = P - ((S = P + I) - (_ = S - P)) + (I - _)) - (I = N - M), u[1] = N - (I + _) + (_ - M), _ = (L = S + I) - S, u[2] = S - (L - _) + (I - _), u[3] = L; const k = n(4, i, 4, u, o); _ = (C = (b = R - (x = (m = e * R) - (m - R))) * (w = v - (E = (m = e * v) - (m - v))) - ((P = R * v) - x * E - b * E - x * w)) - (I = C - (O = (b = T - (x = (m = e * T) - (m - T))) * (w = y - (E = (m = e * y) - (m - y))) - ((M = T * y) - x * E - b * E - x * w))), u[0] = C - (I + _) + (_ - O), _ = (N = P - ((S = P + I) - (_ = S - P)) + (I - _)) - (I = N - M), u[1] = N - (I + _) + (_ - M), _ = (L = S + I) - S, u[2] = S - (L - _) + (I - _), u[3] = L; const G = n(k, o, 4, u, s); _ = (C = (b = g - (x = (m = e * g) - (m - g))) * (w = v - (E = (m = e * v) - (m - v))) - ((P = g * v) - x * E - b * E - x * w)) - (I = C - (O = (b = d - (x = (m = e * d) - (m - d))) * (w = y - (E = (m = e * y) - (m - y))) - ((M = d * y) - x * E - b * E - x * w))), u[0] = C - (I + _) + (_ - O), _ = (N = P - ((S = P + I) - (_ = S - P)) + (I - _)) - (I = N - M), u[1] = N - (I + _) + (_ - M), _ = (L = S + I) - S, u[2] = S - (L - _) + (I - _), u[3] = L; const q = n(G, s, 4, u, a); return a[q - 1] }(t, r, l, c, f, h, y)) }, t.orient2dfast = function (t, e, n, r, i, o) { return (e - o) * (n - i) - (t - i) * (r - o) }, Object.defineProperty(t, '__esModule', { value: !0 }) }(e)) }, 5697: t => { 'use strict'; t.exports = { eudist: function (t, e, n) { for (var r = t.length, i = 0, o = 0; o < r; o++) { const s = (t[o] || 0) - (e[o] || 0); i += s * s } return n ? Math.sqrt(i) : i }, mandist: function (t, e, n) { for (var r = t.length, i = 0, o = 0; o < r; o++)i += Math.abs((t[o] || 0) - (e[o] || 0)); return n ? Math.sqrt(i) : i }, dist: function (t, e, n) { const r = Math.abs(t - e); return n ? r : r * r } } }, 7035: (t, e, n) => { 'use strict'; const r = n(5697); const i = r.eudist; const o = r.dist; t.exports = { kmrand: function (t, e) { for (var n = {}, r = [], i = e << 2, o = t.length, s = t[0].length > 0; r.length < e && i-- > 0;) { const a = t[Math.floor(Math.random() * o)]; const u = s ? a.join('_') : '' + a; n[u] || (n[u] = !0, r.push(a)) } if (r.length < e) throw new Error('Error initializating clusters'); return r }, kmpp: function (t, e) { const n = t[0].length ? i : o; const r = []; const s = t.length; const a = t[0].length > 0; const u = t[Math.floor(Math.random() * s)]; for (a && u.join('_'), r.push(u); r.length < e;) { for (var l = [], c = r.length, f = 0, h = [], p = 0; p < s; p++) { for (var g = 1 / 0, d = 0; d < c; d++) { const y = n(t[p], r[d]); y <= g && (g = y) }l[p] = g } for (let v = 0; v < s; v++)f += l[v]; for (let _ = 0; _ < s; _++)h[_] = { i: _, v: t[_], pr: l[_] / f, cs: 0 }; h.sort(function (t, e) { return t.pr - e.pr }), h[0].cs = h[0].pr; for (let m = 1; m < s; m++)h[m].cs = h[m - 1].cs + h[m].pr; for (var x = Math.random(), b = 0; b < s - 1 && h[b++].cs < x;);r.push(h[b - 1].v) } return r } } }, 1160: (t, e, n) => { 'use strict'; const r = n(5697); const i = n(7035); const o = r.eudist; const s = (r.mandist, r.dist, i.kmrand); const a = i.kmpp; function u (t, e, n) { n = n || []; for (let r = 0; r < t; r++)n[r] = e; return n }t.exports = function (t, e, n, r) { let i = []; let l = []; const c = []; let f = []; let h = !1; let p = r || 1e4; const g = t.length; const d = t[0].length; const y = d > 0; const v = []; if (n)i = n == 'kmrand' ? s(t, e) : n == 'kmpp' ? a(t, e) : n; else for (let _ = {}; i.length < e;) { const m = Math.floor(Math.random() * g); _[m] || (_[m] = !0, i.push(t[m])) } do { u(e, 0, v); for (let x = 0; x < g; x++) { for (var b = 1 / 0, E = 0, w = 0; w < e; w++)(f = y ? o(t[x], i[w]) : Math.abs(t[x] - i[w])) <= b && (b = f, E = w); c[x] = E, v[E]++ } for (var I = [], S = (l = [], 0); S < e; S++)I[S] = y ? u(d, 0, I[S]) : 0, l[S] = i[S]; if (y) { for (let N = 0; N < e; N++)i[N] = []; for (let P = 0; P < g; P++) for (let C = I[c[P]], M = t[P], O = 0; O < d; O++)C[O] += M[O]; h = !0; for (let L = 0; L < e; L++) { for (var R = i[L], A = I[L], T = l[L], D = v[L], F = 0; F < d; F++)R[F] = A[F] / D || 0; if (h) for (let j = 0; j < d; j++) if (T[j] != R[j]) { h = !1; break } } } else { for (let k = 0; k < g; k++)I[c[k]] += t[k]; for (let G = 0; G < e; G++)i[G] = I[G] / v[G] || 0; h = !0; for (let q = 0; q < e; q++) if (l[q] != i[q]) { h = !1; break } }h = h || --p <= 0 } while (!h); return { it: 1e4 - p, k: e, idxs: c, centroids: i } } }, 3842: (t, e, n) => { 'use strict'; n.r(e), n.d(e, { default: () => r }); class r {constructor (t = [], e = i) { if (this.data = t, this.length = this.data.length, this.compare = e, this.length > 0) for (let t = (this.length >> 1) - 1; t >= 0; t--) this._down(t) }push (t) { this.data.push(t), this.length++, this._up(this.length - 1) }pop () { if (this.length === 0) return; const t = this.data[0]; const e = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = e, this._down(0)), t }peek () { return this.data[0] }_up (t) { const { data: e, compare: n } = this; const r = e[t]; for (;t > 0;) { const i = t - 1 >> 1; const o = e[i]; if (n(r, o) >= 0) break; e[t] = o, t = i }e[t] = r }_down (t) { const { data: e, compare: n } = this; const r = this.length >> 1; const i = e[t]; for (;t < r;) { let r = 1 + (t << 1); let o = e[r]; const s = r + 1; if (s < this.length && n(e[s], o) < 0 && (r = s, o = e[s]), n(o, i) >= 0) break; e[t] = o, t = r }e[t] = i }} function i (t, e) { return t < e ? -1 : t > e ? 1 : 0 } }, 8146: (t, e, n) => { 'use strict'; function r (t) { return t } function i (t) { if (t == null) return r; let e; let n; const i = t.scale[0]; const o = t.scale[1]; const s = t.translate[0]; const a = t.translate[1]; return function (t, r) { r || (e = n = 0); let u = 2; const l = t.length; const c = new Array(l); for (c[0] = (e += t[0]) * i + s, c[1] = (n += t[1]) * o + a; u < l;)c[u] = t[u], ++u; return c } } function o (t) { let e; const n = i(t.transform); let r = 1 / 0; let o = r; let s = -r; let a = -r; function u (t) { (t = n(t))[0] < r && (r = t[0]), t[0] > s && (s = t[0]), t[1] < o && (o = t[1]), t[1] > a && (a = t[1]) } function l (t) { switch (t.type) { case 'GeometryCollection':t.geometries.forEach(l); break; case 'Point':u(t.coordinates); break; case 'MultiPoint':t.coordinates.forEach(u) } } for (e in t.arcs.forEach(function (t) { for (var e, i = -1, u = t.length; ++i < u;)(e = n(t[i], i))[0] < r && (r = e[0]), e[0] > s && (s = e[0]), e[1] < o && (o = e[1]), e[1] > a && (a = e[1]) }), t.objects)l(t.objects[e]); return [r, o, s, a] } function s (t, e) { return typeof e === 'string' && (e = t.objects[e]), e.type === 'GeometryCollection' ? { type: 'FeatureCollection', features: e.geometries.map(function (e) { return a(t, e) }) } : a(t, e) } function a (t, e) { const n = e.id; const r = e.bbox; const i = e.properties == null ? {} : e.properties; const o = u(t, e); return n == null && r == null ? { type: 'Feature', properties: i, geometry: o } : r == null ? { type: 'Feature', id: n, properties: i, geometry: o } : { type: 'Feature', id: n, bbox: r, properties: i, geometry: o } } function u (t, e) { const n = i(t.transform); const r = t.arcs; function o (t, e) { e.length && e.pop(); for (var i = r[t < 0 ? ~t : t], o = 0, s = i.length; o < s; ++o)e.push(n(i[o], o)); t < 0 && (function (t, e) { for (var n, r = t.length, i = r - e; i < --r;)n = t[i], t[i++] = t[r], t[r] = n }(e, s)) } function s (t) { return n(t) } function a (t) { for (var e = [], n = 0, r = t.length; n < r; ++n)o(t[n], e); return e.length < 2 && e.push(e[0]), e } function u (t) { for (var e = a(t); e.length < 4;)e.push(e[0]); return e } function l (t) { return t.map(u) } return (function t (e) { let n; const r = e.type; switch (r) { case 'GeometryCollection':return { type: r, geometries: e.geometries.map(t) }; case 'Point':n = s(e.coordinates); break; case 'MultiPoint':n = e.coordinates.map(s); break; case 'LineString':n = a(e.arcs); break; case 'MultiLineString':n = e.arcs.map(a); break; case 'Polygon':n = l(e.arcs); break; case 'MultiPolygon':n = e.arcs.map(l); break; default:return null } return { type: r, coordinates: n } }(e)) } function l (t, e) { const n = {}; const r = {}; const i = {}; const o = []; let s = -1; function a (t, e) { for (const r in t) { const i = t[r]; delete e[i.start], delete i.start, delete i.end, i.forEach(function (t) { n[t < 0 ? ~t : t] = 1 }), o.push(i) } } return e.forEach(function (n, r) { let i; const o = t.arcs[n < 0 ? ~n : n]; o.length < 3 && !o[1][0] && !o[1][1] && (i = e[++s], e[s] = n, e[r] = i) }), e.forEach(function (e) { let n; let o; const s = (function (e) { let n; const r = t.arcs[e < 0 ? ~e : e]; const i = r[0]; return t.transform ? (n = [0, 0], r.forEach(function (t) { n[0] += t[0], n[1] += t[1] })) : n = r[r.length - 1], e < 0 ? [n, i] : [i, n] }(e)); const a = s[0]; const u = s[1]; if (n = i[a]) if (delete i[n.end], n.push(e), n.end = u, o = r[u]) { delete r[o.start]; const l = o === n ? n : n.concat(o); r[l.start = n.start] = i[l.end = o.end] = l } else r[n.start] = i[n.end] = n; else if (n = r[u]) if (delete r[n.start], n.unshift(e), n.start = a, o = i[a]) { delete i[o.end]; const c = o === n ? n : o.concat(n); r[c.start = o.start] = i[c.end = n.end] = c } else r[n.start] = i[n.end] = n; else r[(n = [e]).start = a] = i[n.end = u] = n }), a(i, r), a(r, i), e.forEach(function (t) { n[t < 0 ? ~t : t] || o.push([t]) }), o } function c (t) { return u(t, f.apply(this, arguments)) } function f (t, e, n) { let r, i, o; if (arguments.length > 1)r = h(0, e, n); else for (i = 0, r = new Array(o = t.arcs.length); i < o; ++i)r[i] = i; return { type: 'MultiLineString', arcs: l(t, r) } } function h (t, e, n) { let r; const i = []; const o = []; function s (t) { const e = t < 0 ? ~t : t; (o[e] || (o[e] = [])).push({ i: t, g: r }) } function a (t) { t.forEach(s) } function u (t) { t.forEach(a) } return (function t (e) { switch (r = e, e.type) { case 'GeometryCollection':e.geometries.forEach(t); break; case 'LineString':a(e.arcs); break; case 'MultiLineString':case 'Polygon':u(e.arcs); break; case 'MultiPolygon':!(function (t) { t.forEach(u) }(e.arcs)) } }(e)), o.forEach(n == null ? function (t) { i.push(t[0].i) } : function (t) { n(t[0].g, t[t.length - 1].g) && i.push(t[0].i) }), i } function p (t) { return u(t, g.apply(this, arguments)) } function g (t, e) { const n = {}; const r = []; const i = []; function o (t) { t.forEach(function (e) { e.forEach(function (e) { (n[e = e < 0 ? ~e : e] || (n[e] = [])).push(t) }) }), r.push(t) } function s (e) { return (function (t) { for (var e, n = -1, r = t.length, i = t[r - 1], o = 0; ++n < r;)e = i, i = t[n], o += e[0] * i[1] - e[1] * i[0]; return Math.abs(o) }(u(t, { type: 'Polygon', arcs: [e] }).coordinates[0])) } return e.forEach(function t (e) { switch (e.type) { case 'GeometryCollection':e.geometries.forEach(t); break; case 'Polygon':o(e.arcs); break; case 'MultiPolygon':e.arcs.forEach(o) } }), r.forEach(function (t) { if (!t._) { const e = []; const r = [t]; for (t._ = 1, i.push(e); t = r.pop();)e.push(t), t.forEach(function (t) { t.forEach(function (t) { n[t < 0 ? ~t : t].forEach(function (t) { t._ || (t._ = 1, r.push(t)) }) }) }) } }), r.forEach(function (t) { delete t._ }), { type: 'MultiPolygon', arcs: i.map(function (e) { let r; let i = []; if (e.forEach(function (t) { t.forEach(function (t) { t.forEach(function (t) { n[t < 0 ? ~t : t].length < 2 && i.push(t) }) }) }), (r = (i = l(t, i)).length) > 1) for (var o, a, u = 1, c = s(i[0]); u < r; ++u)(o = s(i[u])) > c && (a = i[0], i[0] = i[u], i[u] = a, c = o); return i }).filter(function (t) { return t.length > 0 }) } } function d (t, e) { for (var n = 0, r = t.length; n < r;) { const i = n + r >>> 1; t[i] < e ? n = i + 1 : r = i } return n } function y (t) { const e = {}; const n = t.map(function () { return [] }); function r (t, n) { t.forEach(function (t) { t < 0 && (t = ~t); const r = e[t]; r ? r.push(n) : e[t] = [n] }) } function i (t, e) { t.forEach(function (t) { r(t, e) }) } const o = { LineString: r, MultiLineString: i, Polygon: i, MultiPolygon: function (t, e) { t.forEach(function (t) { i(t, e) }) } }; for (let s in t.forEach(function t (e, n) { e.type === 'GeometryCollection' ? e.geometries.forEach(function (e) { t(e, n) }) : e.type in o && o[e.type](e.arcs, n) }), e) for (let a = e[s], u = a.length, l = 0; l < u; ++l) for (let c = l + 1; c < u; ++c) { var f; const h = a[l]; const p = a[c]; (f = n[h])[s = d(f, p)] !== p && f.splice(s, 0, p), (f = n[p])[s = d(f, h)] !== h && f.splice(s, 0, h) } return n } function v (t) { if (t == null) return r; let e; let n; const i = t.scale[0]; const o = t.scale[1]; const s = t.translate[0]; const a = t.translate[1]; return function (t, r) { r || (e = n = 0); let u = 2; const l = t.length; const c = new Array(l); const f = Math.round((t[0] - s) / i); const h = Math.round((t[1] - a) / o); for (c[0] = f - e, e = f, c[1] = h - n, n = h; u < l;)c[u] = t[u], ++u; return c } } function _ (t, e) { if (t.transform) throw new Error('already quantized'); if (e && e.scale)u = t.bbox; else { if (!((n = Math.floor(e)) >= 2)) throw new Error('n must be ≥2'); let n; const r = (u = t.bbox || o(t))[0]; const i = u[1]; const s = u[2]; const a = u[3]; e = { scale: [s - r ? (s - r) / (n - 1) : 1, a - i ? (a - i) / (n - 1) : 1], translate: [r, i] } } let u; let l; const c = v(e); const f = t.objects; const h = {}; function p (t) { return c(t) } function g (t) { let e; switch (t.type) { case 'GeometryCollection':e = { type: 'GeometryCollection', geometries: t.geometries.map(g) }; break; case 'Point':e = { type: 'Point', coordinates: p(t.coordinates) }; break; case 'MultiPoint':e = { type: 'MultiPoint', coordinates: t.coordinates.map(p) }; break; default:return t } return t.id != null && (e.id = t.id), t.bbox != null && (e.bbox = t.bbox), t.properties != null && (e.properties = t.properties), e } for (l in f)h[l] = g(f[l]); return { type: 'Topology', bbox: u, transform: e, objects: h, arcs: t.arcs.map(function (t) { let e; let n = 0; let r = 1; const i = t.length; const o = new Array(i); for (o[0] = c(t[0], 0); ++n < i;)((e = c(t[n], n))[0] || e[1]) && (o[r++] = e); return r === 1 && (o[r++] = [0, 0]), o.length = r, o }) } }n.r(e), n.d(e, { bbox: () => o, feature: () => s, merge: () => p, mergeArcs: () => g, mesh: () => c, meshArcs: () => f, neighbors: () => y, quantize: () => _, transform: () => i, untransform: () => v }) }, 4255: (t, e, n) => { 'use strict'; n.r(e), n.d(e, { topology: () => g }); const r = Object.prototype.hasOwnProperty; function i (t, e, n, r, i, o) { arguments.length === 3 && (r = o = Array, i = null); for (var s = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), a = new o(t), u = t - 1, l = 0; l < t; ++l)s[l] = i; function c (r, o) { for (var l = e(r) & u, c = s[l], f = 0; c != i;) { if (n(c, r)) return a[l] = o; if (++f >= t) throw new Error('full hashmap'); c = s[l = l + 1 & u] } return s[l] = r, a[l] = o, o } function f (r, o) { for (var l = e(r) & u, c = s[l], f = 0; c != i;) { if (n(c, r)) return a[l]; if (++f >= t) throw new Error('full hashmap'); c = s[l = l + 1 & u] } return s[l] = r, a[l] = o, o } function h (r, o) { for (let l = e(r) & u, c = s[l], f = 0; c != i;) { if (n(c, r)) return a[l]; if (++f >= t) break; c = s[l = l + 1 & u] } return o } function p () { for (var t = [], e = 0, n = s.length; e < n; ++e) { const r = s[e]; r != i && t.push(r) } return t } return { set: c, maybeSet: f, get: h, keys: p } } function o (t, e) { return t[0] === e[0] && t[1] === e[1] } const s = new ArrayBuffer(16); const a = new Float64Array(s); const u = new Uint32Array(s); function l (t) { a[0] = t[0], a[1] = t[1]; const e = u[0] ^ u[1]; return 2147483647 & (e << 5 ^ e >> 7 ^ u[2] ^ u[3]) } function c (t, e, n) { for (var r, i = e + (n-- - e >> 1); e < i; ++e, --n)r = t[e], t[e] = t[n], t[n] = r } function f (t) { const e = { type: 'GeometryCollection', geometries: t.features.map(h) }; return t.bbox != null && (e.bbox = t.bbox), e } function h (t) { let e; const n = p(t.geometry); for (e in t.id != null && (n.id = t.id), t.bbox != null && (n.bbox = t.bbox), t.properties) { n.properties = t.properties; break } return n } function p (t) { if (t == null) return { type: null }; const e = t.type === 'GeometryCollection' ? { type: 'GeometryCollection', geometries: t.geometries.map(p) } : t.type === 'Point' || t.type === 'MultiPoint' ? { type: t.type, coordinates: t.coordinates } : { type: t.type, arcs: t.coordinates }; return t.bbox != null && (e.bbox = t.bbox), e } function g (t, e) { const n = (function (t) { let e = 1 / 0; let n = 1 / 0; let i = -1 / 0; let o = -1 / 0; function s (t) { t != null && r.call(a, t.type) && a[t.type](t) } var a = { GeometryCollection: function (t) { t.geometries.forEach(s) }, Point: function (t) { u(t.coordinates) }, MultiPoint: function (t) { t.coordinates.forEach(u) }, LineString: function (t) { l(t.arcs) }, MultiLineString: function (t) { t.arcs.forEach(l) }, Polygon: function (t) { t.arcs.forEach(l) }, MultiPolygon: function (t) { t.arcs.forEach(c) } }; function u (t) { const r = t[0]; const s = t[1]; r < e && (e = r), r > i && (i = r), s < n && (n = s), s > o && (o = s) } function l (t) { t.forEach(u) } function c (t) { t.forEach(l) } for (const f in t)s(t[f]); return i >= e && o >= n ? [e, n, i, o] : void 0 }(t = (function (t) { let e; let n; const r = {}; for (e in t)r[e] = (n = t[e]) == null ? { type: null } : (n.type === 'FeatureCollection' ? f : n.type === 'Feature' ? h : p)(n); return r }(t)))); const s = e > 0 && n && (function (t, e, n) { const i = e[0]; const o = e[1]; const s = e[2]; const a = e[3]; const u = s - i ? (n - 1) / (s - i) : 1; const l = a - o ? (n - 1) / (a - o) : 1; function c (t) { return [Math.round((t[0] - i) * u), Math.round((t[1] - o) * l)] } function f (t, e) { for (var n, r, s, a, c, f = -1, h = 0, p = t.length, g = new Array(p); ++f < p;)n = t[f], a = Math.round((n[0] - i) * u), c = Math.round((n[1] - o) * l), a === r && c === s || (g[h++] = [r = a, s = c]); for (g.length = h; h < e;)h = g.push([g[0][0], g[0][1]]); return g } function h (t) { return f(t, 2) } function p (t) { return f(t, 4) } function g (t) { return t.map(p) } function d (t) { t != null && r.call(y, t.type) && y[t.type](t) } var y = { GeometryCollection: function (t) { t.geometries.forEach(d) }, Point: function (t) { t.coordinates = c(t.coordinates) }, MultiPoint: function (t) { t.coordinates = t.coordinates.map(c) }, LineString: function (t) { t.arcs = h(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(h) }, Polygon: function (t) { t.arcs = g(t.arcs) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(g) } }; for (const v in t)d(t[v]); return { scale: [1 / u, 1 / l], translate: [i, o] } }(t, n, e)); const a = (function (t) { let e; let n; let r; let s; const a = t.coordinates; const u = t.lines; const c = t.rings; let f = u.length + c.length; for (delete t.lines, delete t.rings, r = 0, s = u.length; r < s; ++r) for (e = u[r]; e = e.next;)++f; for (r = 0, s = c.length; r < s; ++r) for (n = c[r]; n = n.next;)++f; const h = i(2 * f * 1.4, l, o); const p = t.arcs = []; for (r = 0, s = u.length; r < s; ++r) { e = u[r]; do { g(e) } while (e = e.next) } for (r = 0, s = c.length; r < s; ++r) if ((n = c[r]).next) do { g(n) } while (n = n.next); else d(n); function g (t) { let e, n, r, i, o, s, u, l; if (r = h.get(e = a[t[0]])) for (u = 0, l = r.length; u < l; ++u) if (y(i = r[u], t)) return t[0] = i[0], void (t[1] = i[1]); if (o = h.get(n = a[t[1]])) for (u = 0, l = o.length; u < l; ++u) if (v(s = o[u], t)) return t[1] = s[0], void (t[0] = s[1]); r ? r.push(t) : h.set(e, [t]), o ? o.push(t) : h.set(n, [t]), p.push(t) } function d (t) { let e, n, r, i, o; if (n = h.get(a[t[0]])) for (i = 0, o = n.length; i < o; ++i) { if (_(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]); if (m(r, t)) return t[0] = r[1], void (t[1] = r[0]) } if (n = h.get(e = a[t[0] + x(t)])) for (i = 0, o = n.length; i < o; ++i) { if (_(r = n[i], t)) return t[0] = r[0], void (t[1] = r[1]); if (m(r, t)) return t[0] = r[1], void (t[1] = r[0]) }n ? n.push(t) : h.set(e, [t]), p.push(t) } function y (t, e) { let n = t[0]; let r = e[0]; const i = t[1]; if (n - i != r - e[1]) return !1; for (;n <= i; ++n, ++r) if (!o(a[n], a[r])) return !1; return !0 } function v (t, e) { let n = t[0]; const r = e[0]; const i = t[1]; let s = e[1]; if (n - i != r - s) return !1; for (;n <= i; ++n, --s) if (!o(a[n], a[s])) return !1; return !0 } function _ (t, e) { const n = t[0]; const r = e[0]; const i = t[1] - n; if (i !== e[1] - r) return !1; for (let s = x(t), u = x(e), l = 0; l < i; ++l) if (!o(a[n + (l + s) % i], a[r + (l + u) % i])) return !1; return !0 } function m (t, e) { const n = t[0]; const r = e[0]; const i = t[1]; const s = e[1]; const u = i - n; if (u !== s - r) return !1; for (let l = x(t), c = u - x(e), f = 0; f < u; ++f) if (!o(a[n + (f + l) % u], a[s - (f + c) % u])) return !1; return !0 } function x (t) { for (var e = t[0], n = t[1], r = e, i = r, o = a[r]; ++r < n;) { const s = a[r]; (s[0] < o[0] || s[0] === o[0] && s[1] < o[1]) && (i = r, o = s) } return i - e } return t }(function (t) { let e; let n; let r; let s; let a; let u; let f; const h = (function (t) { let e; let n; let r; let s; const a = t.coordinates; const u = t.lines; const c = t.rings; const f = function () { for (var t = i(1.4 * a.length, I, S, Int32Array, -1, Int32Array), e = new Int32Array(a.length), n = 0, r = a.length; n < r; ++n)e[n] = t.maybeSet(n, n); return e }(); let h = new Int32Array(a.length); let p = new Int32Array(a.length); let g = new Int32Array(a.length); const d = new Int8Array(a.length); let y = 0; for (e = 0, n = a.length; e < n; ++e)h[e] = p[e] = g[e] = -1; for (e = 0, n = u.length; e < n; ++e) { const v = u[e]; let _ = v[0]; const m = v[1]; for (r = f[_], s = f[++_], ++y, d[r] = 1; ++_ <= m;)w(e, r, r = s, s = f[_]); ++y, d[s] = 1 } for (e = 0, n = a.length; e < n; ++e)h[e] = -1; for (e = 0, n = c.length; e < n; ++e) { const x = c[e]; let b = x[0] + 1; const E = x[1]; for (w(e, f[E - 1], r = f[b - 1], s = f[b]); ++b <= E;)w(e, r, r = s, s = f[b]) } function w (t, e, n, r) { if (h[n] !== t) { h[n] = t; const i = p[n]; if (i >= 0) { const o = g[n]; i === e && o === r || i === r && o === e || (++y, d[n] = 1) } else p[n] = e, g[n] = r } } function I (t) { return l(a[t]) } function S (t, e) { return o(a[t], a[e]) }h = p = g = null; let N; const P = (function (t, e, n, r, i) { 3 === arguments.length && (r = Array, i = null); for (var o = new r(t = 1 << Math.max(4, Math.ceil(Math.log(t) / Math.LN2))), s = t - 1, a = 0; a < t; ++a)o[a] = i; function u (r) { for (var a = e(r) & s, u = o[a], l = 0; u != i;) { if (n(u, r)) return !0; if (++l >= t) throw new Error('full hashset'); u = o[a = a + 1 & s] } return o[a] = r, !0 } function l (r) { for (let a = e(r) & s, u = o[a], l = 0; u != i;) { if (n(u, r)) return !0; if (++l >= t) break; u = o[a = a + 1 & s] } return !1 } function c () { for (var t = [], e = 0, n = o.length; e < n; ++e) { var r = o[e]; r != i && t.push(r) } return t } return { add: u, has: l, values: c } }(1.4 * y, l, o)); for (e = 0, n = a.length; e < n; ++e)d[N = f[e]] && P.add(a[N]); return P }(t)); const p = t.coordinates; const g = t.lines; const d = t.rings; for (n = 0, r = g.length; n < r; ++n) for (let y = g[n], v = y[0], _ = y[1]; ++v < _;)h.has(p[v]) && (e = { 0: v, 1: y[1] }, y[1] = v, y = y.next = e); for (n = 0, r = d.length; n < r; ++n) for (let m = d[n], x = m[0], b = x, E = m[1], w = h.has(p[x]); ++b < E;)h.has(p[b]) && (w ? (e = { 0: b, 1: m[1] }, m[1] = b, m = m.next = e) : (f = E - b, c(s = p, a = x, u = E), c(s, a, a + f), c(s, a + f, u), p[E] = p[x], w = !0, b = x)); return t }(function (t) { let e = -1; const n = []; const i = []; const o = []; function s (t) { t && r.call(a, t.type) && a[t.type](t) } var a = { GeometryCollection: function (t) { t.geometries.forEach(s) }, LineString: function (t) { t.arcs = u(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(u) }, Polygon: function (t) { t.arcs = t.arcs.map(l) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(c) } }; function u (t) { for (var r = 0, i = t.length; r < i; ++r)o[++e] = t[r]; const s = { 0: e - i + 1, 1: e }; return n.push(s), s } function l (t) { for (var n = 0, r = t.length; n < r; ++n)o[++e] = t[n]; const s = { 0: e - r + 1, 1: e }; return i.push(s), s } function c (t) { return t.map(l) } for (const f in t)s(t[f]); return { type: 'Topology', coordinates: o, lines: n, rings: i, objects: t } }(t)))); let u = a.coordinates; const g = i(1.4 * a.arcs.length, d, y); function v (t) { t && r.call(_, t.type) && _[t.type](t) }t = a.objects, a.bbox = n, a.arcs = a.arcs.map(function (t, e) { return g.set(t, e), u.slice(t[0], t[1] + 1) }), delete a.coordinates, u = null; var _ = { GeometryCollection: function (t) { t.geometries.forEach(v) }, LineString: function (t) { t.arcs = m(t.arcs) }, MultiLineString: function (t) { t.arcs = t.arcs.map(m) }, Polygon: function (t) { t.arcs = t.arcs.map(m) }, MultiPolygon: function (t) { t.arcs = t.arcs.map(x) } }; function m (t) { const e = []; do { const n = g.get(t); e.push(t[0] < t[1] ? n : ~n) } while (t = t.next); return e } function x (t) { return t.map(m) } for (const b in t)v(t[b]); return s && (a.transform = s, a.arcs = (function (t) { for (let e = -1, n = t.length; ++e < n;) { for (var r, i, o = t[e], s = 0, a = 1, u = o.length, l = o[0], c = l[0], f = l[1]; ++s < u;)r = (l = o[s])[0], i = l[1], r === c && i === f || (o[a++] = [r - c, i - f], c = r, f = i); a === 1 && (o[a++] = [0, 0]), o.length = a } return t }(a.arcs))), a } function d (t) { let e; let n = t[0]; let r = t[1]; return r < n && (e = n, n = r, r = e), n + 31 * r } function y (t, e) { let n; let r = t[0]; let i = t[1]; let o = e[0]; let s = e[1]; return i < r && (n = r, r = i, i = n), s < o && (n = o, o = s, s = n), r === o && i === s } }, 5187: function (t, e, n) { 'use strict'; const r = this && this.__spreadArray || function (t, e, n) { if (n || arguments.length === 2) for (var r, i = 0, o = e.length; i < o; i++)!r && i in e || (r || (r = Array.prototype.slice.call(e, 0, i)), r[i] = e[i]); return t.concat(r || Array.prototype.slice.call(e)) }; e.__esModule = !0; const i = n(8347); const o = function (t, e) { this.val = t, this.priority = e }; const s = (function () { function t () { this.values = [] } return t.prototype.enqueue = function (t, e) { const n = new o(t, e); this.values.push(n), this.bubbleUp() }, t.prototype.bubbleUp = function () { for (let t = this.values.length - 1, e = this.values[t]; t > 0;) { const n = Math.floor((t - 1) / 2); const r = this.values[n]; if (e.priority >= r.priority) break; this.values[n] = e, this.values[t] = r, t = n } }, t.prototype.dequeue = function () { const t = this.values[0]; const e = this.values.pop(); return this.values.length > 0 && (this.values[0] = e, this.sinkDown()), t }, t.prototype.sinkDown = function () { for (let t = 0, e = this.values.length, n = this.values[0]; ;) { const r = 2 * t + 1; const i = 2 * t + 2; let o = void 0; let s = void 0; let a = null; if (r < e && (o = this.values[r]).priority < n.priority && (a = r), i < e && (s = this.values[i], (a === null && s.priority < n.priority || a !== null && s.priority < o.priority) && (a = i)), a === null) break; this.values[t] = this.values[a], this.values[a] = n, t = a } }, t }()); const a = (function () { function t () { this.adjacencyList = {} } return t.prototype.addVertex = function (t) { const e = t.id; this.adjacencyList[e] || (this.adjacencyList[e] = []) }, t.prototype.addEdge = function (t, e, n) { let r, i; (r = this.adjacencyList[t]) === null || void 0 === r || r.push({ node: e, weight: n }), (i = this.adjacencyList[e]) === null || void 0 === i || i.push({ node: t, weight: n }) }, t.prototype.Dijkstra = function (t, e) { let n; const r = new s(); const i = {}; const o = {}; const a = []; for (const u in this.adjacencyList)u === t ? (i[u] = 0, r.enqueue(u, 0)) : (i[u] = 1 / 0, r.enqueue(u, 1 / 0)), o[u] = null; for (;r.values.length;) { if ((n = r.dequeue().val) === e) { for (;o[n];)a.push(n), n = o[n]; break } if (n || i[n] !== 1 / 0) for (const l in this.adjacencyList[n]) { const c = this.adjacencyList[n][l]; const f = i[n] + c.weight; const h = c.node; f < i[h] && (i[h] = f, o[h] = n, r.enqueue(h, f)) } } return a.concat(n).reverse() }, t }()); const u = function (t, e) { const n = []; t.map(function (t) { return n.push(e[t]) }); let o; const s = (function (t) { const e = []; return t.map(function (t, n) { const r = t.direction; const i = t.distance; const o = t.floor; const s = e[e.length - 1]; s ? s.direction === r ? s.distance = s.distance + i : s.direction === 'Elevator' ? (e.push({ direction: r, distance: i }), s.endFloor = o) : e.push({ direction: r, distance: i }) : e.push({ direction: r, distance: i }) }), e }(function (t) { const e = []; return t.map(function (n, r) { let o; let s; let a; const u = n.id; const l = { id: u, type: n.type, coords: n.coords, adjacentLinks: n.adjacentLinks }; const c = t[r + 1] ? t[r + 1] : void 0; if (!c) return !1; if (c.type === 'Elevator')e.push({ direction: 'Elevator', distance: 0, floor: u.split('_')[0] }); else { const f = (o = l.coords, s = c.coords, a = i.bearing(o, s), ['North', 'NorthEast', 'East', 'SouthEast', 'South', 'SouthWest', 'West', 'NorthWest'][Math.round(((a %= 360) < 0 ? a + 360 : a) / 45) % 8]); const h = (function (t, e) { return i.distance(t, e, { units: 'meters' }) }(l.coords, c.coords)); e.push({ direction: f, distance: h, floor: u.split('_')[0] }) } }), e }(n))); const a = (o = s.map(function (t) { return t.distance }), o.reduce(function (t, e) { return t + e }, 0)).toFixed(2); const u = (function (t, e, n, i) { const o = i[0].id; const s = i[i.length - 1].id; let a = !1; const u = []; const l = ['Start at '.concat(o)]; i.map(function (t) { const e = t.id; return u.push(e.split('_')[0]) }), n.map(function (t, e) { let r; let i; let o; const s = t.direction; const u = t.distance; const c = t.endFloor; const f = n[e + 1]; if (s === 'Elevator')a = !0, l.push('Use the elevator to floor '.concat(c)); else { l.push('Follow the path for '.concat(u.toFixed(1), ' meters')); const h = (r = s, i = f == null ? void 0 : f.direction, r === 'East' && i === 'North' && (o = 'left'), r === 'East' && i === 'West' && (o = 'Straight'), r === 'East' && i === 'South' && (o = 'right'), r === 'East' && i === 'NorthEast' && (o = 'slight left'), r === 'East' && i === 'SouthEast' && (o = 'slight right'), r === 'North' && i === 'East' && (o = 'right'), r === 'North' && i === 'West' && (o = 'left'), r === 'North' && i === 'South' && (o = 'Straight'), r === 'South' && i === 'North' && (o = 'Straight'), r === 'South' && i === 'West' && (o = 'right'), r === 'South' && i === 'East' && (o = 'left'), r === 'South' && i === 'SouthWest' && (o = 'slight right'), r === 'South' && i === 'SouthEast' && (o = 'slight left'), r === 'West' && i === 'North' && (o = 'right'), r === 'West' && i === 'East' && (o = 'Straight'), r === 'West' && i === 'South' && (o = 'left'), r === 'West' && i === 'SouthWest' && (o = 'slight left'), r === 'West' && i === 'NorthWest' && (o = 'slight right'), r === 'North' && i === 'NorthEast' && (o = 'slight right'), r === 'North' && i === 'NorthWest' && (o = 'slight left'), r === 'SouthEast' && i === 'South' && (o = 'slight right'), r === 'SouthEast' && i === 'East' && (o = 'slight left'), r === 'SouthEast' && i === 'SouthWest' && (o = 'right'), r === 'SouthEast' && i === 'South' && (o = 'slight right'), r === 'SouthEast' && i === 'NorthEast' && (o = 'right'), r === 'NorthEast' && i === 'SouthEast' && (o = 'left'), r === 'NorthEast' && i === 'NorthWest' && (o = 'left'), r === 'NorthEast' && i === 'North' && (o = 'slight left'), r === 'NorthEast' && i === 'East' && (o = 'slight right'), r === 'NorthWest' && i === 'North' && (o = 'slight right'), r === 'NorthWest' && i === 'West' && (o = 'slight left'), r === 'NorthWest' && i === 'NorthEast' && (o = 'right'), r === 'NorthWest' && i === 'SouthWest' && (o = 'left'), r === 'SouthWest' && i === 'South' && (o = 'slight left'), r === 'SouthWest' && i === 'West' && (o = 'slight right'), r === 'SouthWest' && i === 'SouthEast' && (o = 'left'), o); h && l.push('Turn '.concat(h)) } }), l.push('You arrived at '.concat(s)); const c = r([], new Set(u), !0); const f = { finalTextInstructions: l, distancesSum: t, timeToTravel: e, floorChangeWithStairsOrElevator: a ? 'elevator' : 'stairs' }; return c.length > 0 && (f.floors = c), f }(a, 1 / a, s, n)); return u }; t.exports = { getShortestPath: function (t, e, n) { const r = new a(); const i = t; const o = function (t) { r.addVertex({ id: i[t].id }), Object.entries(i[t].adjacentLinks).map(function (e) { r.addEdge(i[t].id, e[0], e[1].distance) }) }; for (const s in i)o(s); const l = r.Dijkstra(e, n); const c = []; const f = u(l, t); return l.map(function (t, e) { c.push(i[t].coords) }), [c, l, f, void 0] } } }, 1382: (t, e, n) => { 'use strict'; e.__esModule = !0; const r = n(8347); const i = function (t, e, n) { const r = e.doorOptions; const i = e.pathOptions; const o = e.preferElevator; const s = JSON.parse(JSON.stringify(t)); const a = r && Object.entries(r); const u = i && Object.entries(i); return !o && Object.entries(s).map(function (t) { const e = t[0]; t[1].type === 'Elevator' && delete s[e] }), r && Object.entries(s).map(function (t) { const e = t[0]; const r = t[1].doorOptions; r && r && a.map(function (t) { if (!1 === n[t[0]]) return !1; t[1].length === 2 ? (t[1][1] === 'max' && +r[t[0]] > +t[1][0] && delete s[e], t[1][1] === 'min' && +r[t[0]] < +t[1][0] && delete s[e]) : r[t[0]] !== t[1] && delete s[e] }) }), i && Object.entries(s).map(function (t) { const e = t[0]; const r = t[1]; Object.entries(r.adjacentNodes).map(function (t) { const r = t[0]; const i = t[1].attributes; u.map(function (t) { return !!i[t[0]] && !1 !== n[t[0]] && void 0 !== i[t[0]] && (t[1].length === 2 && (t[1][1] === 'max' && +i[t[0]] > +t[1][0] && delete s[e].adjacentNodes[r], t[1][1] === 'min' && +i[t[0]] < +t[1][0] && delete s[e].adjacentNodes[r]), !1 === t[1] && !0 === i[t[0]] && delete s[e].adjacentNodes[r], void (!0 === t[1] && !1 === i[t[0]] && delete s[e].adjacentNodes[r])) }) }) }), s }; t.exports = { saveGraph: function (t, e, n) { const o = (function (t, e, n) { const o = []; let s = t; if (Object.keys(e).length > 0 && (s = i(t, e, n)), Object.entries(s).length < 2) return !1; const a = function (t) { const e = {}; const n = s[t]; n.adjacentNodes && Object.entries(n.adjacentNodes).map(function (t) { const i = s[t[0]]; if (!i) return !1; const o = r.point(n.currentCoordinates); const a = r.point(i.currentCoordinates); const u = r.distance(o, a, { units: 'meters' }); e[t[0]] = { distance: u, width: t[1].attributes ? t[1].attributes.width : 0, slope: t[1].attributes ? t[1].attributes.slope : 0, wheelChair: !!t[1].attributes && t[1].attributes.wheelChair } }), o.push({ id: n.id, type: n.type, coords: n.currentCoordinates, adjacentLinks: e }) }; for (const u in s)a(u); return o }(t, e, n)); const s = {}; return !(!o || o.length < 2) && (o.map(function (t) { s[t.id] = t }), s) }, removeEdges: i } }, 3607: function (t, e, n) { var r = this && this.__assign || function () { return r = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++) for (const i in e = arguments[n])Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); return t }, r.apply(this, arguments) }; const i = n(1382).saveGraph; const o = n(5187).getShortestPath; const s = { doorOptions: {}, pathOptions: {}, preferElevator: !1 }; const a = {}; t.exports = (function () { function t (t, e) { const n = (function (t) { if (!t || Object.keys(t).length === 0) return !1; const e = Object.entries(t)[0]; const n = e[0]; const r = e[1]; return !(typeof t !== 'object' || !n.includes('_') || !r.hasOwnProperty('currentCoordinates')) }(t)); if (!n) throw new TypeError('Please provide valid nodes.'); const r = e.routingOptions; const i = void 0 === r ? s : r; const o = e.filter; const u = void 0 === o ? a : o; if (typeof i !== 'object' || typeof u !== 'object') throw new TypeError('routingObjects and/or filter has to be of type object.'); this.options = i, this.filter = u, this.nodes = t } return t.prototype.getNodes = function () { return this.nodes }, t.prototype.setNodes = function (t) { this.nodes = t }, t.prototype.getOptions = function () { return this.options }, t.prototype.setOptions = function (t) { this.options = t }, t.prototype.getRoutableOptions = function () { const t = {}; let e = {}; return Object.entries(this.nodes).map(function (n) { n[0]; const i = n[1]; if (i.doorOptions) for (const o in i.doorOptions)t.hasOwnProperty(o) || (t[o] = typeof i.doorOptions[o] === 'boolean' ? 'boolean' : 'string'); if (i.adjacentNodes) { const s = Object.values(i.adjacentNodes)[0]; const a = Object.values(s)[0]; Object.entries(a).map(function (t) { let n; const i = t[0]; const o = t[1]; i && !e.hasOwnProperty(i) && (e = r(r({}, e), ((n = {})[i] = typeof o === 'boolean' ? 'boolean' : 'string', n))) }) } }), { doorOptions: t, pathOptions: e, preferElevator: !1 } }, t.prototype.getFilter = function () { return this.filter }, t.prototype.setFilter = function (t) { this.filter = t }, t.prototype.isNodeValid = function (t, e) { return !!t[e] }, t.prototype.constructErrorMessage = function (t) { return [void 0, void 0, void 0, t] }, t.prototype.getRoute = function (t, e) { let n, r; if (!this.nodes) return !1; if (!t || !e) return this.constructErrorMessage('Please enter a start and destination'); const s = i(this.nodes, this.options, this.filter); if (!this.isNodeValid(s, t)) return this.constructErrorMessage('Node '.concat(t, ' is not present in the graph.')); if (!this.isNodeValid(s, e)) return this.constructErrorMessage('Node '.concat(e, ' is not present in the graph.')); const a = o(s, ''.concat(t), ''.concat(e)); return a[2].hasOwnProperty('floors') && a[2].hasOwnProperty('floorChangeWithStairsOrElevator') && a[2] && ((r = (n = a[2]) === null || void 0 === n ? void 0 : n.floors) === null || void 0 === r ? void 0 : r.length) === 1 && delete a[2].floorChangeWithStairsOrElevator, a[1].length === 1 ? this.constructErrorMessage('No path found.') : a }, t }()) }, 675: function (t, e) { !(function (t) { 'use strict'; function e () {} function n (t) { this.message = t || '' } function r (t) { this.message = t || '' } function i (t) { this.message = t || '' } function o () {} function s (t) { return t === null ? Tt : t.color } function a (t) { return t === null ? null : t.parent } function u (t, e) { t !== null && (t.color = e) } function l (t) { return t === null ? null : t.left } function c (t) { return t === null ? null : t.right } function f () { this.root_ = null, this.size_ = 0 } function h () {} function p () { this.array_ = [], arguments[0] instanceof xt && this.addAll(arguments[0]) } function g () {} function d (t) { this.message = t || '' } function y () { this.array_ = [] }'fill' in Array.prototype || Object.defineProperty(Array.prototype, 'fill', { configurable: !0, value: function (t) { if (this == null) throw new TypeError(this + ' is not an object'); const e = Object(this); const n = Math.max(Math.min(e.length, 9007199254740991), 0) || 0; let r = 1 in arguments && parseInt(Number(arguments[1]), 10) || 0; r = r < 0 ? Math.max(n + r, 0) : Math.min(r, n); let i = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n; for (i = i < 0 ? Math.max(n + arguments[2], 0) : Math.min(i, n); r < i;)e[r] = t, ++r; return e }, writable: !0 }), Number.isFinite = Number.isFinite || function (t) { return typeof t === 'number' && isFinite(t) }, Number.isInteger = Number.isInteger || function (t) { return typeof t === 'number' && isFinite(t) && Math.floor(t) === t }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function (t) { return t != t }, Math.trunc = Math.trunc || function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t) }; const v = function () {}; v.prototype.interfaces_ = function () { return [] }, v.prototype.getClass = function () { return v }, v.prototype.equalsWithTolerance = function (t, e, n) { return Math.abs(t - e) <= n }; const _ = (function (t) { function e (e) { t.call(this, e), this.name = 'IllegalArgumentException', this.message = e, this.stack = (new t()).stack } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e }(Error)); const m = function () {}; const x = { MAX_VALUE: { configurable: !0 } }; m.isNaN = function (t) { return Number.isNaN(t) }, m.doubleToLongBits = function (t) { return t }, m.longBitsToDouble = function (t) { return t }, m.isInfinite = function (t) { return !Number.isFinite(t) }, x.MAX_VALUE.get = function () { return Number.MAX_VALUE }, Object.defineProperties(m, x); const b = function () {}; const E = function () {}; const w = function () {}; const I = function t () { if (this.x = null, this.y = null, this.z = null, arguments.length === 0) this.x = 0, this.y = 0, this.z = t.NULL_ORDINATE; else if (arguments.length === 1) { const e = arguments[0]; this.x = e.x, this.y = e.y, this.z = e.z } else arguments.length === 2 ? (this.x = arguments[0], this.y = arguments[1], this.z = t.NULL_ORDINATE) : arguments.length === 3 && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]) }; const S = { DimensionalComparator: { configurable: !0 }, serialVersionUID: { configurable: !0 }, NULL_ORDINATE: { configurable: !0 }, X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 } }; I.prototype.setOrdinate = function (t, e) { switch (t) { case I.X:this.x = e; break; case I.Y:this.y = e; break; case I.Z:this.z = e; break; default:throw new _('Invalid ordinate index: ' + t) } }, I.prototype.equals2D = function () { if (arguments.length === 1) { const t = arguments[0]; return this.x === t.x && this.y === t.y } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return !!v.equalsWithTolerance(this.x, e.x, n) && !!v.equalsWithTolerance(this.y, e.y, n) } }, I.prototype.getOrdinate = function (t) { switch (t) { case I.X:return this.x; case I.Y:return this.y; case I.Z:return this.z } throw new _('Invalid ordinate index: ' + t) }, I.prototype.equals3D = function (t) { return this.x === t.x && this.y === t.y && (this.z === t.z || m.isNaN(this.z)) && m.isNaN(t.z) }, I.prototype.equals = function (t) { return t instanceof I && this.equals2D(t) }, I.prototype.equalInZ = function (t, e) { return v.equalsWithTolerance(this.z, t.z, e) }, I.prototype.compareTo = function (t) { const e = t; return this.x < e.x ? -1 : this.x > e.x ? 1 : this.y < e.y ? -1 : this.y > e.y ? 1 : 0 }, I.prototype.clone = function () {}, I.prototype.copy = function () { return new I(this) }, I.prototype.toString = function () { return '(' + this.x + ', ' + this.y + ', ' + this.z + ')' }, I.prototype.distance3D = function (t) { const e = this.x - t.x; const n = this.y - t.y; const r = this.z - t.z; return Math.sqrt(e * e + n * n + r * r) }, I.prototype.distance = function (t) { const e = this.x - t.x; const n = this.y - t.y; return Math.sqrt(e * e + n * n) }, I.prototype.hashCode = function () { let t = 17; return 37 * (t = 37 * t + I.hashCode(this.x)) + I.hashCode(this.y) }, I.prototype.setCoordinate = function (t) { this.x = t.x, this.y = t.y, this.z = t.z }, I.prototype.interfaces_ = function () { return [b, E, e] }, I.prototype.getClass = function () { return I }, I.hashCode = function () { if (arguments.length === 1) { const t = arguments[0]; const e = m.doubleToLongBits(t); return Math.trunc((e ^ e) >>> 32) } }, S.DimensionalComparator.get = function () { return N }, S.serialVersionUID.get = function () { return 0x5cbf2c235c7e5800 }, S.NULL_ORDINATE.get = function () { return m.NaN }, S.X.get = function () { return 0 }, S.Y.get = function () { return 1 }, S.Z.get = function () { return 2 }, Object.defineProperties(I, S); var N = function (t) { if (this._dimensionsToTest = 2, arguments.length === 0);else if (arguments.length === 1) { const e = arguments[0]; if (e !== 2 && e !== 3) throw new _('only 2 or 3 dimensions may be specified'); this._dimensionsToTest = e } }; N.prototype.compare = function (t, e) { const n = t; const r = e; const i = N.compare(n.x, r.x); if (i !== 0) return i; const o = N.compare(n.y, r.y); return o !== 0 ? o : this._dimensionsToTest <= 2 ? 0 : N.compare(n.z, r.z) }, N.prototype.interfaces_ = function () { return [w] }, N.prototype.getClass = function () { return N }, N.compare = function (t, e) { return t < e ? -1 : t > e ? 1 : m.isNaN(t) ? m.isNaN(e) ? 0 : -1 : m.isNaN(e) ? 1 : 0 }; const P = function () {}; P.prototype.create = function () {}, P.prototype.interfaces_ = function () { return [] }, P.prototype.getClass = function () { return P }; const C = function () {}; const M = { INTERIOR: { configurable: !0 }, BOUNDARY: { configurable: !0 }, EXTERIOR: { configurable: !0 }, NONE: { configurable: !0 } }; C.prototype.interfaces_ = function () { return [] }, C.prototype.getClass = function () { return C }, C.toLocationSymbol = function (t) { switch (t) { case C.EXTERIOR:return 'e'; case C.BOUNDARY:return 'b'; case C.INTERIOR:return 'i'; case C.NONE:return '-' } throw new _('Unknown location value: ' + t) }, M.INTERIOR.get = function () { return 0 }, M.BOUNDARY.get = function () { return 1 }, M.EXTERIOR.get = function () { return 2 }, M.NONE.get = function () { return -1 }, Object.defineProperties(C, M); const O = function (t, e) { return t.interfaces_ && t.interfaces_().indexOf(e) > -1 }; const L = function () {}; const R = { LOG_10: { configurable: !0 } }; L.prototype.interfaces_ = function () { return [] }, L.prototype.getClass = function () { return L }, L.log10 = function (t) { const e = Math.log(t); return m.isInfinite(e) || m.isNaN(e) ? e : e / L.LOG_10 }, L.min = function (t, e, n, r) { let i = t; return e < i && (i = e), n < i && (i = n), r < i && (i = r), i }, L.clamp = function () { if (typeof arguments[2] === 'number' && typeof arguments[0] === 'number' && typeof arguments[1] === 'number') { const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; return t < e ? e : t > n ? n : t } if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; return r < i ? i : r > o ? o : r } }, L.wrap = function (t, e) { return t < 0 ? e - -t % e : t % e }, L.max = function () { if (arguments.length === 3) { const t = arguments[1]; const e = arguments[2]; let n = arguments[0]; return t > n && (n = t), e > n && (n = e), n } if (arguments.length === 4) { const r = arguments[1]; const i = arguments[2]; const o = arguments[3]; let s = arguments[0]; return r > s && (s = r), i > s && (s = i), o > s && (s = o), s } }, L.average = function (t, e) { return (t + e) / 2 }, R.LOG_10.get = function () { return Math.log(10) }, Object.defineProperties(L, R); const A = function (t) { this.str = t }; A.prototype.append = function (t) { this.str += t }, A.prototype.setCharAt = function (t, e) { this.str = this.str.substr(0, t) + e + this.str.substr(t + 1) }, A.prototype.toString = function (t) { return this.str }; const T = function (t) { this.value = t }; T.prototype.intValue = function () { return this.value }, T.prototype.compareTo = function (t) { return this.value < t ? -1 : this.value > t ? 1 : 0 }, T.isNaN = function (t) { return Number.isNaN(t) }; const D = function () {}; D.isWhitespace = function (t) { return t <= 32 && t >= 0 || t === 127 }, D.toUpperCase = function (t) { return t.toUpperCase() }; const F = function t () { if (this._hi = 0, this._lo = 0, arguments.length === 0) this.init(0); else if (arguments.length === 1) if (typeof arguments[0] === 'number') { const e = arguments[0]; this.init(e) } else if (arguments[0] instanceof t) { const n = arguments[0]; this.init(n) } else typeof arguments[0] === 'string' && t.call(this, t.parse(arguments[0])); else if (arguments.length === 2) { const r = arguments[0]; const i = arguments[1]; this.init(r, i) } }; const j = { PI: { configurable: !0 }, TWO_PI: { configurable: !0 }, PI_2: { configurable: !0 }, E: { configurable: !0 }, NaN: { configurable: !0 }, EPS: { configurable: !0 }, SPLIT: { configurable: !0 }, MAX_PRINT_DIGITS: { configurable: !0 }, TEN: { configurable: !0 }, ONE: { configurable: !0 }, SCI_NOT_EXPONENT_CHAR: { configurable: !0 }, SCI_NOT_ZERO: { configurable: !0 } }; F.prototype.le = function (t) { return (this._hi < t._hi || this._hi === t._hi) && this._lo <= t._lo }, F.prototype.extractSignificantDigits = function (t, e) { let n = this.abs(); let r = F.magnitude(n._hi); const i = F.TEN.pow(r); (n = n.divide(i)).gt(F.TEN) ? (n = n.divide(F.TEN), r += 1) : n.lt(F.ONE) && (n = n.multiply(F.TEN), r -= 1); for (var o = r + 1, s = new A(), a = F.MAX_PRINT_DIGITS - 1, u = 0; u <= a; u++) { t && u === o && s.append('.'); const l = Math.trunc(n._hi); if (l < 0) break; let c = !1; let f = 0; l > 9 ? (c = !0, f = '9') : f = '0' + l, s.append(f), n = n.subtract(F.valueOf(l)).multiply(F.TEN), c && n.selfAdd(F.TEN); let h = !0; const p = F.magnitude(n._hi); if (p < 0 && Math.abs(p) >= a - u && (h = !1), !h) break } return e[0] = r, s.toString() }, F.prototype.sqr = function () { return this.multiply(this) }, F.prototype.doubleValue = function () { return this._hi + this._lo }, F.prototype.subtract = function () { if (arguments[0] instanceof F) { const t = arguments[0]; return this.add(t.negate()) } if (typeof arguments[0] === 'number') { const e = arguments[0]; return this.add(-e) } }, F.prototype.equals = function () { if (arguments.length === 1) { const t = arguments[0]; return this._hi === t._hi && this._lo === t._lo } }, F.prototype.isZero = function () { return this._hi === 0 && this._lo === 0 }, F.prototype.selfSubtract = function () { if (arguments[0] instanceof F) { const t = arguments[0]; return this.isNaN() ? this : this.selfAdd(-t._hi, -t._lo) } if (typeof arguments[0] === 'number') { const e = arguments[0]; return this.isNaN() ? this : this.selfAdd(-e, 0) } }, F.prototype.getSpecialNumberString = function () { return this.isZero() ? '0.0' : this.isNaN() ? 'NaN ' : null }, F.prototype.min = function (t) { return this.le(t) ? this : t }, F.prototype.selfDivide = function () { if (arguments.length === 1) { if (arguments[0] instanceof F) { const t = arguments[0]; return this.selfDivide(t._hi, t._lo) } if (typeof arguments[0] === 'number') { const e = arguments[0]; return this.selfDivide(e, 0) } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; let i = null; let o = null; let s = null; let a = null; let u = null; let l = null; let c = null; let f = null; return u = this._hi / n, f = (i = (l = F.SPLIT * u) - (i = l - u)) * (s = (f = F.SPLIT * n) - (s = f - n)) - (c = u * n) + i * (a = n - s) + (o = u - i) * s + o * a, f = u + (l = (this._hi - c - f + this._lo - u * r) / n), this._hi = f, this._lo = u - f + l, this } }, F.prototype.dump = function () { return 'DD<' + this._hi + ', ' + this._lo + '>' }, F.prototype.divide = function () { if (arguments[0] instanceof F) { const t = arguments[0]; let e = null; let n = null; let r = null; let i = null; let o = null; let s = null; let a = null; let u = null; return n = (o = this._hi / t._hi) - (e = (s = F.SPLIT * o) - (e = s - o)), u = e * (r = (u = F.SPLIT * t._hi) - (r = u - t._hi)) - (a = o * t._hi) + e * (i = t._hi - r) + n * r + n * i, s = (this._hi - a - u + this._lo - o * t._lo) / t._hi, new F(u = o + s, o - u + s) } if (typeof arguments[0] === 'number') { const l = arguments[0]; return m.isNaN(l) ? F.createNaN() : F.copy(this).selfDivide(l, 0) } }, F.prototype.ge = function (t) { return (this._hi > t._hi || this._hi === t._hi) && this._lo >= t._lo }, F.prototype.pow = function (t) { if (t === 0) return F.valueOf(1); let e = new F(this); let n = F.valueOf(1); let r = Math.abs(t); if (r > 1) for (;r > 0;)r % 2 == 1 && n.selfMultiply(e), (r /= 2) > 0 && (e = e.sqr()); else n = e; return t < 0 ? n.reciprocal() : n }, F.prototype.ceil = function () { if (this.isNaN()) return F.NaN; const t = Math.ceil(this._hi); let e = 0; return t === this._hi && (e = Math.ceil(this._lo)), new F(t, e) }, F.prototype.compareTo = function (t) { const e = t; return this._hi < e._hi ? -1 : this._hi > e._hi ? 1 : this._lo < e._lo ? -1 : this._lo > e._lo ? 1 : 0 }, F.prototype.rint = function () { return this.isNaN() ? this : this.add(0.5).floor() }, F.prototype.setValue = function () { if (arguments[0] instanceof F) { const t = arguments[0]; return this.init(t), this } if (typeof arguments[0] === 'number') { const e = arguments[0]; return this.init(e), this } }, F.prototype.max = function (t) { return this.ge(t) ? this : t }, F.prototype.sqrt = function () { if (this.isZero()) return F.valueOf(0); if (this.isNegative()) return F.NaN; const t = 1 / Math.sqrt(this._hi); const e = this._hi * t; const n = F.valueOf(e); const r = this.subtract(n.sqr())._hi * (0.5 * t); return n.add(r) }, F.prototype.selfAdd = function () { if (arguments.length === 1) { if (arguments[0] instanceof F) { const t = arguments[0]; return this.selfAdd(t._hi, t._lo) } if (typeof arguments[0] === 'number') { const e = arguments[0]; let n = null; let r = null; let i = null; let o = null; let s = null; let a = null; return o = (i = this._hi + e) - (s = i - this._hi), r = (a = (o = e - s + (this._hi - o)) + this._lo) + (i - (n = i + a)), this._hi = n + r, this._lo = r + (n - this._hi), this } } else if (arguments.length === 2) { const u = arguments[0]; const l = arguments[1]; let c = null; let f = null; let h = null; let p = null; let g = null; let d = null; let y = null; p = this._hi + u, f = this._lo + l, g = p - (d = p - this._hi), h = f - (y = f - this._lo); const v = (c = p + (d = (g = u - d + (this._hi - g)) + f)) + (d = (h = l - y + (this._lo - h)) + (d + (p - c))); const _ = d + (c - v); return this._hi = v, this._lo = _, this } }, F.prototype.selfMultiply = function () { if (arguments.length === 1) { if (arguments[0] instanceof F) { const t = arguments[0]; return this.selfMultiply(t._hi, t._lo) } if (typeof arguments[0] === 'number') { const e = arguments[0]; return this.selfMultiply(e, 0) } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; let i = null; let o = null; let s = null; let a = null; let u = null; let l = null; i = (u = F.SPLIT * this._hi) - this._hi, l = F.SPLIT * n, i = u - i, o = this._hi - i, s = l - n; const c = (u = this._hi * n) + (l = i * (s = l - s) - u + i * (a = n - s) + o * s + o * a + (this._hi * r + this._lo * n)); const f = l + (i = u - c); return this._hi = c, this._lo = f, this } }, F.prototype.selfSqr = function () { return this.selfMultiply(this) }, F.prototype.floor = function () { if (this.isNaN()) return F.NaN; const t = Math.floor(this._hi); let e = 0; return t === this._hi && (e = Math.floor(this._lo)), new F(t, e) }, F.prototype.negate = function () { return this.isNaN() ? this : new F(-this._hi, -this._lo) }, F.prototype.clone = function () {}, F.prototype.multiply = function () { if (arguments[0] instanceof F) { const t = arguments[0]; return t.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t) } if (typeof arguments[0] === 'number') { const e = arguments[0]; return m.isNaN(e) ? F.createNaN() : F.copy(this).selfMultiply(e, 0) } }, F.prototype.isNaN = function () { return m.isNaN(this._hi) }, F.prototype.intValue = function () { return Math.trunc(this._hi) }, F.prototype.toString = function () { const t = F.magnitude(this._hi); return t >= -3 && t <= 20 ? this.toStandardNotation() : this.toSciNotation() }, F.prototype.toStandardNotation = function () { const t = this.getSpecialNumberString(); if (t !== null) return t; const e = new Array(1).fill(null); const n = this.extractSignificantDigits(!0, e); const r = e[0] + 1; let i = n; if (n.charAt(0) === '.')i = '0' + n; else if (r < 0)i = '0.' + F.stringOfChar('0', -r) + n; else if (n.indexOf('.') === -1) { const o = r - n.length; i = n + F.stringOfChar('0', o) + '.0' } return this.isNegative() ? '-' + i : i }, F.prototype.reciprocal = function () { let t; let e; let n; let r; let i = null; let o = null; let s = null; let a = null; t = (n = 1 / this._hi) - (i = (s = F.SPLIT * n) - (i = s - n)), o = (a = F.SPLIT * this._hi) - this._hi; const u = n + (s = (1 - (r = n * this._hi) - (a = i * (o = a - o) - r + i * (e = this._hi - o) + t * o + t * e) - n * this._lo) / this._hi); return new F(u, n - u + s) }, F.prototype.toSciNotation = function () { if (this.isZero()) return F.SCI_NOT_ZERO; const t = this.getSpecialNumberString(); if (t !== null) return t; const e = new Array(1).fill(null); const n = this.extractSignificantDigits(!1, e); const r = F.SCI_NOT_EXPONENT_CHAR + e[0]; if (n.charAt(0) === '0') throw new Error('Found leading zero: ' + n); let i = ''; n.length > 1 && (i = n.substring(1)); const o = n.charAt(0) + '.' + i; return this.isNegative() ? '-' + o + r : o + r }, F.prototype.abs = function () { return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this) }, F.prototype.isPositive = function () { return (this._hi > 0 || this._hi === 0) && this._lo > 0 }, F.prototype.lt = function (t) { return (this._hi < t._hi || this._hi === t._hi) && this._lo < t._lo }, F.prototype.add = function () { if (arguments[0] instanceof F) { const t = arguments[0]; return F.copy(this).selfAdd(t) } if (typeof arguments[0] === 'number') { const e = arguments[0]; return F.copy(this).selfAdd(e) } }, F.prototype.init = function () { if (arguments.length === 1) { if (typeof arguments[0] === 'number') { const t = arguments[0]; this._hi = t, this._lo = 0 } else if (arguments[0] instanceof F) { const e = arguments[0]; this._hi = e._hi, this._lo = e._lo } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; this._hi = n, this._lo = r } }, F.prototype.gt = function (t) { return (this._hi > t._hi || this._hi === t._hi) && this._lo > t._lo }, F.prototype.isNegative = function () { return (this._hi < 0 || this._hi === 0) && this._lo < 0 }, F.prototype.trunc = function () { return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil() }, F.prototype.signum = function () { return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0 }, F.prototype.interfaces_ = function () { return [e, b, E] }, F.prototype.getClass = function () { return F }, F.sqr = function (t) { return F.valueOf(t).selfMultiply(t) }, F.valueOf = function () { if (typeof arguments[0] === 'string') { const t = arguments[0]; return F.parse(t) } if (typeof arguments[0] === 'number') return new F(arguments[0]) }, F.sqrt = function (t) { return F.valueOf(t).sqrt() }, F.parse = function (t) { for (var e = 0, n = t.length; D.isWhitespace(t.charAt(e));)e++; let r = !1; if (e < n) { const i = t.charAt(e); i !== '-' && i !== '+' || (e++, i === '-' && (r = !0)) } for (var o = new F(), s = 0, a = 0, u = 0; !(e >= n);) { const l = t.charAt(e); if (e++, D.isDigit(l)) { const c = l - '0'; o.selfMultiply(F.TEN), o.selfAdd(c), s++ } else { if (l !== '.') { if (l === 'e' || l === 'E') { const f = t.substring(e); try { u = T.parseInt(f) } catch (e) { throw e instanceof Error ? new Error('Invalid exponent ' + f + ' in string ' + t) : e } break } throw new Error("Unexpected character '" + l + "' at position " + e + ' in string ' + t) }a = s } } let h = o; const p = s - a - u; if (p === 0)h = o; else if (p > 0) { const g = F.TEN.pow(p); h = o.divide(g) } else if (p < 0) { const d = F.TEN.pow(-p); h = o.multiply(d) } return r ? h.negate() : h }, F.createNaN = function () { return new F(m.NaN, m.NaN) }, F.copy = function (t) { return new F(t) }, F.magnitude = function (t) { const e = Math.abs(t); const n = Math.log(e) / Math.log(10); let r = Math.trunc(Math.floor(n)); return 10 * Math.pow(10, r) <= e && (r += 1), r }, F.stringOfChar = function (t, e) { for (var n = new A(), r = 0; r < e; r++)n.append(t); return n.toString() }, j.PI.get = function () { return new F(3.141592653589793, 12246467991473532e-32) }, j.TWO_PI.get = function () { return new F(6.283185307179586, 24492935982947064e-32) }, j.PI_2.get = function () { return new F(1.5707963267948966, 6123233995736766e-32) }, j.E.get = function () { return new F(2.718281828459045, 14456468917292502e-32) }, j.NaN.get = function () { return new F(m.NaN, m.NaN) }, j.EPS.get = function () { return 123259516440783e-46 }, j.SPLIT.get = function () { return 134217729 }, j.MAX_PRINT_DIGITS.get = function () { return 32 }, j.TEN.get = function () { return F.valueOf(10) }, j.ONE.get = function () { return F.valueOf(1) }, j.SCI_NOT_EXPONENT_CHAR.get = function () { return 'E' }, j.SCI_NOT_ZERO.get = function () { return '0.0E0' }, Object.defineProperties(F, j); const k = function () {}; const G = { DP_SAFE_EPSILON: { configurable: !0 } }; k.prototype.interfaces_ = function () { return [] }, k.prototype.getClass = function () { return k }, k.orientationIndex = function (t, e, n) { const r = k.orientationIndexFilter(t, e, n); if (r <= 1) return r; const i = F.valueOf(e.x).selfAdd(-t.x); const o = F.valueOf(e.y).selfAdd(-t.y); const s = F.valueOf(n.x).selfAdd(-e.x); const a = F.valueOf(n.y).selfAdd(-e.y); return i.selfMultiply(a).selfSubtract(o.selfMultiply(s)).signum() }, k.signOfDet2x2 = function (t, e, n, r) { return t.multiply(r).selfSubtract(e.multiply(n)).signum() }, k.intersection = function (t, e, n, r) { const i = F.valueOf(r.y).selfSubtract(n.y).selfMultiply(F.valueOf(e.x).selfSubtract(t.x)); const o = F.valueOf(r.x).selfSubtract(n.x).selfMultiply(F.valueOf(e.y).selfSubtract(t.y)); const s = i.subtract(o); const a = F.valueOf(r.x).selfSubtract(n.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)); const u = F.valueOf(r.y).selfSubtract(n.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)); const l = a.subtract(u).selfDivide(s).doubleValue(); const c = F.valueOf(t.x).selfAdd(F.valueOf(e.x).selfSubtract(t.x).selfMultiply(l)).doubleValue(); const f = F.valueOf(e.x).selfSubtract(t.x).selfMultiply(F.valueOf(t.y).selfSubtract(n.y)); const h = F.valueOf(e.y).selfSubtract(t.y).selfMultiply(F.valueOf(t.x).selfSubtract(n.x)); const p = f.subtract(h).selfDivide(s).doubleValue(); const g = F.valueOf(n.y).selfAdd(F.valueOf(r.y).selfSubtract(n.y).selfMultiply(p)).doubleValue(); return new I(c, g) }, k.orientationIndexFilter = function (t, e, n) { let r = null; const i = (t.x - n.x) * (e.y - n.y); const o = (t.y - n.y) * (e.x - n.x); const s = i - o; if (i > 0) { if (o <= 0) return k.signum(s); r = i + o } else { if (!(i < 0)) return k.signum(s); if (o >= 0) return k.signum(s); r = -i - o } const a = k.DP_SAFE_EPSILON * r; return s >= a || -s >= a ? k.signum(s) : 2 }, k.signum = function (t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }, G.DP_SAFE_EPSILON.get = function () { return 1e-15 }, Object.defineProperties(k, G); const q = function () {}; const B = { X: { configurable: !0 }, Y: { configurable: !0 }, Z: { configurable: !0 }, M: { configurable: !0 } }; B.X.get = function () { return 0 }, B.Y.get = function () { return 1 }, B.Z.get = function () { return 2 }, B.M.get = function () { return 3 }, q.prototype.setOrdinate = function (t, e, n) {}, q.prototype.size = function () {}, q.prototype.getOrdinate = function (t, e) {}, q.prototype.getCoordinate = function () {}, q.prototype.getCoordinateCopy = function (t) {}, q.prototype.getDimension = function () {}, q.prototype.getX = function (t) {}, q.prototype.clone = function () {}, q.prototype.expandEnvelope = function (t) {}, q.prototype.copy = function () {}, q.prototype.getY = function (t) {}, q.prototype.toCoordinateArray = function () {}, q.prototype.interfaces_ = function () { return [E] }, q.prototype.getClass = function () { return q }, Object.defineProperties(q, B); const z = function () {}; const U = (function (t) { function e () { t.call(this, 'Projective point not representable on the Cartesian plane.') } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(z)); const X = function () {}; X.arraycopy = function (t, e, n, r, i) { for (let o = 0, s = e; s < e + i; s++)n[r + o] = t[s], o++ }, X.getProperty = function (t) { return { 'line.separator': '\n' }[t] }; const Y = function t () { if (this.x = null, this.y = null, this.w = null, arguments.length === 0) this.x = 0, this.y = 0, this.w = 1; else if (arguments.length === 1) { const e = arguments[0]; this.x = e.x, this.y = e.y, this.w = 1 } else if (arguments.length === 2) { if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') { const n = arguments[0]; const r = arguments[1]; this.x = n, this.y = r, this.w = 1 } else if (arguments[0] instanceof t && arguments[1] instanceof t) { const i = arguments[0]; const o = arguments[1]; this.x = i.y * o.w - o.y * i.w, this.y = o.x * i.w - i.x * o.w, this.w = i.x * o.y - o.x * i.y } else if (arguments[0] instanceof I && arguments[1] instanceof I) { const s = arguments[0]; const a = arguments[1]; this.x = s.y - a.y, this.y = a.x - s.x, this.w = s.x * a.y - a.x * s.y } } else if (arguments.length === 3) { const u = arguments[0]; const l = arguments[1]; const c = arguments[2]; this.x = u, this.y = l, this.w = c } else if (arguments.length === 4) { const f = arguments[0]; const h = arguments[1]; const p = arguments[2]; const g = arguments[3]; const d = f.y - h.y; const y = h.x - f.x; const v = f.x * h.y - h.x * f.y; const _ = p.y - g.y; const m = g.x - p.x; const x = p.x * g.y - g.x * p.y; this.x = y * x - m * v, this.y = _ * v - d * x, this.w = d * m - _ * y } }; Y.prototype.getY = function () { const t = this.y / this.w; if (m.isNaN(t) || m.isInfinite(t)) throw new U(); return t }, Y.prototype.getX = function () { const t = this.x / this.w; if (m.isNaN(t) || m.isInfinite(t)) throw new U(); return t }, Y.prototype.getCoordinate = function () { const t = new I(); return t.x = this.getX(), t.y = this.getY(), t }, Y.prototype.interfaces_ = function () { return [] }, Y.prototype.getClass = function () { return Y }, Y.intersection = function (t, e, n, r) { const i = t.y - e.y; const o = e.x - t.x; const s = t.x * e.y - e.x * t.y; const a = n.y - r.y; const u = r.x - n.x; const l = n.x * r.y - r.x * n.y; const c = i * u - a * o; const f = (o * l - u * s) / c; const h = (a * s - i * l) / c; if (m.isNaN(f) || m.isInfinite(f) || m.isNaN(h) || m.isInfinite(h)) throw new U(); return new I(f, h) }; const V = function t () { if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, arguments.length === 0) this.init(); else if (arguments.length === 1) { if (arguments[0] instanceof I) { const e = arguments[0]; this.init(e.x, e.x, e.y, e.y) } else if (arguments[0] instanceof t) { const n = arguments[0]; this.init(n) } } else if (arguments.length === 2) { const r = arguments[0]; const i = arguments[1]; this.init(r.x, i.x, r.y, i.y) } else if (arguments.length === 4) { const o = arguments[0]; const s = arguments[1]; const a = arguments[2]; const u = arguments[3]; this.init(o, s, a, u) } }; const W = { serialVersionUID: { configurable: !0 } }; V.prototype.getArea = function () { return this.getWidth() * this.getHeight() }, V.prototype.equals = function (t) { if (!(t instanceof V)) return !1; const e = t; return this.isNull() ? e.isNull() : this._maxx === e.getMaxX() && this._maxy === e.getMaxY() && this._minx === e.getMinX() && this._miny === e.getMinY() }, V.prototype.intersection = function (t) { if (this.isNull() || t.isNull() || !this.intersects(t)) return new V(); const e = this._minx > t._minx ? this._minx : t._minx; const n = this._miny > t._miny ? this._miny : t._miny; const r = this._maxx < t._maxx ? this._maxx : t._maxx; const i = this._maxy < t._maxy ? this._maxy : t._maxy; return new V(e, r, n, i) }, V.prototype.isNull = function () { return this._maxx < this._minx }, V.prototype.getMaxX = function () { return this._maxx }, V.prototype.covers = function () { if (arguments.length === 1) { if (arguments[0] instanceof I) { const t = arguments[0]; return this.covers(t.x, t.y) } if (arguments[0] instanceof V) { const e = arguments[0]; return !this.isNull() && !e.isNull() && e.getMinX() >= this._minx && e.getMaxX() <= this._maxx && e.getMinY() >= this._miny && e.getMaxY() <= this._maxy } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; return !this.isNull() && n >= this._minx && n <= this._maxx && r >= this._miny && r <= this._maxy } }, V.prototype.intersects = function () { if (arguments.length === 1) { if (arguments[0] instanceof V) { const t = arguments[0]; return !this.isNull() && !t.isNull() && !(t._minx > this._maxx || t._maxx < this._minx || t._miny > this._maxy || t._maxy < this._miny) } if (arguments[0] instanceof I) { const e = arguments[0]; return this.intersects(e.x, e.y) } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; return !this.isNull() && !(n > this._maxx || n < this._minx || r > this._maxy || r < this._miny) } }, V.prototype.getMinY = function () { return this._miny }, V.prototype.getMinX = function () { return this._minx }, V.prototype.expandToInclude = function () { if (arguments.length === 1) { if (arguments[0] instanceof I) { const t = arguments[0]; this.expandToInclude(t.x, t.y) } else if (arguments[0] instanceof V) { const e = arguments[0]; if (e.isNull()) return null; this.isNull() ? (this._minx = e.getMinX(), this._maxx = e.getMaxX(), this._miny = e.getMinY(), this._maxy = e.getMaxY()) : (e._minx < this._minx && (this._minx = e._minx), e._maxx > this._maxx && (this._maxx = e._maxx), e._miny < this._miny && (this._miny = e._miny), e._maxy > this._maxy && (this._maxy = e._maxy)) } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; this.isNull() ? (this._minx = n, this._maxx = n, this._miny = r, this._maxy = r) : (n < this._minx && (this._minx = n), n > this._maxx && (this._maxx = n), r < this._miny && (this._miny = r), r > this._maxy && (this._maxy = r)) } }, V.prototype.minExtent = function () { if (this.isNull()) return 0; const t = this.getWidth(); const e = this.getHeight(); return t < e ? t : e }, V.prototype.getWidth = function () { return this.isNull() ? 0 : this._maxx - this._minx }, V.prototype.compareTo = function (t) { const e = t; return this.isNull() ? e.isNull() ? 0 : -1 : e.isNull() ? 1 : this._minx < e._minx ? -1 : this._minx > e._minx ? 1 : this._miny < e._miny ? -1 : this._miny > e._miny ? 1 : this._maxx < e._maxx ? -1 : this._maxx > e._maxx ? 1 : this._maxy < e._maxy ? -1 : this._maxy > e._maxy ? 1 : 0 }, V.prototype.translate = function (t, e) { if (this.isNull()) return null; this.init(this.getMinX() + t, this.getMaxX() + t, this.getMinY() + e, this.getMaxY() + e) }, V.prototype.toString = function () { return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']' }, V.prototype.setToNull = function () { this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1 }, V.prototype.getHeight = function () { return this.isNull() ? 0 : this._maxy - this._miny }, V.prototype.maxExtent = function () { if (this.isNull()) return 0; const t = this.getWidth(); const e = this.getHeight(); return t > e ? t : e }, V.prototype.expandBy = function () { if (arguments.length === 1) { const t = arguments[0]; this.expandBy(t, t) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (this.isNull()) return null; this._minx -= e, this._maxx += e, this._miny -= n, this._maxy += n, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull() } }, V.prototype.contains = function () { if (arguments.length === 1) { if (arguments[0] instanceof V) { const t = arguments[0]; return this.covers(t) } if (arguments[0] instanceof I) { const e = arguments[0]; return this.covers(e) } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; return this.covers(n, r) } }, V.prototype.centre = function () { return this.isNull() ? null : new I((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2) }, V.prototype.init = function () { if (arguments.length === 0) this.setToNull(); else if (arguments.length === 1) { if (arguments[0] instanceof I) { const t = arguments[0]; this.init(t.x, t.x, t.y, t.y) } else if (arguments[0] instanceof V) { const e = arguments[0]; this._minx = e._minx, this._maxx = e._maxx, this._miny = e._miny, this._maxy = e._maxy } } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; this.init(n.x, r.x, n.y, r.y) } else if (arguments.length === 4) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; const a = arguments[3]; i < o ? (this._minx = i, this._maxx = o) : (this._minx = o, this._maxx = i), s < a ? (this._miny = s, this._maxy = a) : (this._miny = a, this._maxy = s) } }, V.prototype.getMaxY = function () { return this._maxy }, V.prototype.distance = function (t) { if (this.intersects(t)) return 0; let e = 0; this._maxx < t._minx ? e = t._minx - this._maxx : this._minx > t._maxx && (e = this._minx - t._maxx); let n = 0; return this._maxy < t._miny ? n = t._miny - this._maxy : this._miny > t._maxy && (n = this._miny - t._maxy), e === 0 ? n : n === 0 ? e : Math.sqrt(e * e + n * n) }, V.prototype.hashCode = function () { let t = 17; return 37 * (t = 37 * (t = 37 * (t = 37 * t + I.hashCode(this._minx)) + I.hashCode(this._maxx)) + I.hashCode(this._miny)) + I.hashCode(this._maxy) }, V.prototype.interfaces_ = function () { return [b, e] }, V.prototype.getClass = function () { return V }, V.intersects = function () { if (arguments.length === 3) { const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; return n.x >= (t.x < e.x ? t.x : e.x) && n.x <= (t.x > e.x ? t.x : e.x) && n.y >= (t.y < e.y ? t.y : e.y) && n.y <= (t.y > e.y ? t.y : e.y) } if (arguments.length === 4) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; const s = arguments[3]; let a = Math.min(o.x, s.x); let u = Math.max(o.x, s.x); let l = Math.min(r.x, i.x); let c = Math.max(r.x, i.x); return !(l > u || c < a || (a = Math.min(o.y, s.y), u = Math.max(o.y, s.y), l = Math.min(r.y, i.y), c = Math.max(r.y, i.y), l > u || c < a)) } }, W.serialVersionUID.get = function () { return 0x51845cd552189800 }, Object.defineProperties(V, W); const H = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }; const J = function (t) { this.geometryFactory = t || new ve() }; J.prototype.read = function (t) { let e, n, r; t = t.replace(/[\n\r]/g, ' '); let i = H.typeStr.exec(t); if (t.search('EMPTY') !== -1 && ((i = H.emptyTypeStr.exec(t))[2] = void 0), i && (n = i[1].toLowerCase(), r = i[2], K[n] && (e = K[n].apply(this, [r]))), void 0 === e) throw new Error('Could not parse WKT ' + t); return e }, J.prototype.write = function (t) { return this.extractGeometry(t) }, J.prototype.extractGeometry = function (t) { const e = t.getGeometryType().toLowerCase(); if (!Z[e]) return null; const n = e.toUpperCase(); return t.isEmpty() ? n + ' EMPTY' : n + '(' + Z[e].apply(this, [t]) + ')' }; var Z = { coordinate: function (t) { return t.x + ' ' + t.y }, point: function (t) { return Z.coordinate.call(this, t._coordinates._coordinates[0]) }, multipoint: function (t) { for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)e.push('(' + Z.point.apply(this, [t._geometries[n]]) + ')'); return e.join(',') }, linestring: function (t) { for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n)e.push(Z.coordinate.apply(this, [t._points._coordinates[n]])); return e.join(',') }, linearring: function (t) { for (var e = [], n = 0, r = t._points._coordinates.length; n < r; ++n)e.push(Z.coordinate.apply(this, [t._points._coordinates[n]])); return e.join(',') }, multilinestring: function (t) { for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)e.push('(' + Z.linestring.apply(this, [t._geometries[n]]) + ')'); return e.join(',') }, polygon: function (t) { const e = []; e.push('(' + Z.linestring.apply(this, [t._shell]) + ')'); for (let n = 0, r = t._holes.length; n < r; ++n)e.push('(' + Z.linestring.apply(this, [t._holes[n]]) + ')'); return e.join(',') }, multipolygon: function (t) { for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)e.push('(' + Z.polygon.apply(this, [t._geometries[n]]) + ')'); return e.join(',') }, geometrycollection: function (t) { for (var e = [], n = 0, r = t._geometries.length; n < r; ++n)e.push(this.extractGeometry(t._geometries[n])); return e.join(',') } }; var K = { point: function (t) { if (void 0 === t) return this.geometryFactory.createPoint(); const e = t.trim().split(H.spaces); return this.geometryFactory.createPoint(new I(Number.parseFloat(e[0]), Number.parseFloat(e[1]))) }, multipoint: function (t) { if (void 0 === t) return this.geometryFactory.createMultiPoint(); for (var e, n = t.trim().split(','), r = [], i = 0, o = n.length; i < o; ++i)e = n[i].replace(H.trimParens, '$1'), r.push(K.point.apply(this, [e])); return this.geometryFactory.createMultiPoint(r) }, linestring: function (t) { if (void 0 === t) return this.geometryFactory.createLineString(); for (var e, n = t.trim().split(','), r = [], i = 0, o = n.length; i < o; ++i)e = n[i].trim().split(H.spaces), r.push(new I(Number.parseFloat(e[0]), Number.parseFloat(e[1]))); return this.geometryFactory.createLineString(r) }, linearring: function (t) { if (void 0 === t) return this.geometryFactory.createLinearRing(); for (var e, n = t.trim().split(','), r = [], i = 0, o = n.length; i < o; ++i)e = n[i].trim().split(H.spaces), r.push(new I(Number.parseFloat(e[0]), Number.parseFloat(e[1]))); return this.geometryFactory.createLinearRing(r) }, multilinestring: function (t) { if (void 0 === t) return this.geometryFactory.createMultiLineString(); for (var e, n = t.trim().split(H.parenComma), r = [], i = 0, o = n.length; i < o; ++i)e = n[i].replace(H.trimParens, '$1'), r.push(K.linestring.apply(this, [e])); return this.geometryFactory.createMultiLineString(r) }, polygon: function (t) { if (void 0 === t) return this.geometryFactory.createPolygon(); for (var e, n, r, i, o = t.trim().split(H.parenComma), s = [], a = 0, u = o.length; a < u; ++a)e = o[a].replace(H.trimParens, '$1'), n = K.linestring.apply(this, [e]), r = this.geometryFactory.createLinearRing(n._points), a === 0 ? i = r : s.push(r); return this.geometryFactory.createPolygon(i, s) }, multipolygon: function (t) { if (void 0 === t) return this.geometryFactory.createMultiPolygon(); for (var e, n = t.trim().split(H.doubleParenComma), r = [], i = 0, o = n.length; i < o; ++i)e = n[i].replace(H.trimParens, '$1'), r.push(K.polygon.apply(this, [e])); return this.geometryFactory.createMultiPolygon(r) }, geometrycollection: function (t) { if (void 0 === t) return this.geometryFactory.createGeometryCollection(); for (var e = (t = t.replace(/,\s*([A-Za-z])/g, '|$1')).trim().split('|'), n = [], r = 0, i = e.length; r < i; ++r)n.push(this.read(e[r])); return this.geometryFactory.createGeometryCollection(n) } }; const Q = function (t) { this.parser = new J(t) }; Q.prototype.write = function (t) { return this.parser.write(t) }, Q.toLineString = function (t, e) { if (arguments.length !== 2) throw new Error('Not implemented'); return 'LINESTRING ( ' + t.x + ' ' + t.y + ', ' + e.x + ' ' + e.y + ' )' }; const $ = (function (t) { function e (e) { t.call(this, e), this.name = 'RuntimeException', this.message = e, this.stack = (new t()).stack } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e }(Error)); const tt = (function (t) { function e () { if (t.call(this), arguments.length === 0)t.call(this); else if (arguments.length === 1) { const e = arguments[0]; t.call(this, e) } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }($)); const et = function () {}; et.prototype.interfaces_ = function () { return [] }, et.prototype.getClass = function () { return et }, et.shouldNeverReachHere = function () { if (arguments.length === 0)et.shouldNeverReachHere(null); else if (arguments.length === 1) { const t = arguments[0]; throw new tt('Should never reach here' + (t !== null ? ': ' + t : '')) } }, et.isTrue = function () { let t; if (arguments.length === 1)et.isTrue(arguments[0], null); else if (arguments.length === 2 && (t = arguments[1], !arguments[0])) throw t === null ? new tt() : new tt(t) }, et.equals = function () { let t, e, n; if (arguments.length === 2)et.equals(t = arguments[0], e = arguments[1], null); else if (arguments.length === 3 && (t = arguments[0], n = arguments[2], !(e = arguments[1]).equals(t))) throw new tt('Expected ' + t + ' but encountered ' + e + (n !== null ? ': ' + n : '')) }; const nt = function () { this._result = null, this._inputLines = Array(2).fill().map(function () { return Array(2) }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new I(), this._intPt[1] = new I(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0 }; const rt = { DONT_INTERSECT: { configurable: !0 }, DO_INTERSECT: { configurable: !0 }, COLLINEAR: { configurable: !0 }, NO_INTERSECTION: { configurable: !0 }, POINT_INTERSECTION: { configurable: !0 }, COLLINEAR_INTERSECTION: { configurable: !0 } }; nt.prototype.getIndexAlongSegment = function (t, e) { return this.computeIntLineIndex(), this._intLineIndex[t][e] }, nt.prototype.getTopologySummary = function () { const t = new A(); return this.isEndPoint() && t.append(' endpoint'), this._isProper && t.append(' proper'), this.isCollinear() && t.append(' collinear'), t.toString() }, nt.prototype.computeIntersection = function (t, e, n, r) { this._inputLines[0][0] = t, this._inputLines[0][1] = e, this._inputLines[1][0] = n, this._inputLines[1][1] = r, this._result = this.computeIntersect(t, e, n, r) }, nt.prototype.getIntersectionNum = function () { return this._result }, nt.prototype.computeIntLineIndex = function () { if (arguments.length === 0) this._intLineIndex === null && (this._intLineIndex = Array(2).fill().map(function () { return Array(2) }), this.computeIntLineIndex(0), this.computeIntLineIndex(1)); else if (arguments.length === 1) { const t = arguments[0]; this.getEdgeDistance(t, 0) > this.getEdgeDistance(t, 1) ? (this._intLineIndex[t][0] = 0, this._intLineIndex[t][1] = 1) : (this._intLineIndex[t][0] = 1, this._intLineIndex[t][1] = 0) } }, nt.prototype.isProper = function () { return this.hasIntersection() && this._isProper }, nt.prototype.setPrecisionModel = function (t) { this._precisionModel = t }, nt.prototype.isInteriorIntersection = function () { if (arguments.length === 0) return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1); if (arguments.length === 1) { for (let t = arguments[0], e = 0; e < this._result; e++) if (!this._intPt[e].equals2D(this._inputLines[t][0]) && !this._intPt[e].equals2D(this._inputLines[t][1])) return !0; return !1 } }, nt.prototype.getIntersection = function (t) { return this._intPt[t] }, nt.prototype.isEndPoint = function () { return this.hasIntersection() && !this._isProper }, nt.prototype.hasIntersection = function () { return this._result !== nt.NO_INTERSECTION }, nt.prototype.getEdgeDistance = function (t, e) { return nt.computeEdgeDistance(this._intPt[e], this._inputLines[t][0], this._inputLines[t][1]) }, nt.prototype.isCollinear = function () { return this._result === nt.COLLINEAR_INTERSECTION }, nt.prototype.toString = function () { return Q.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + Q.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary() }, nt.prototype.getEndpoint = function (t, e) { return this._inputLines[t][e] }, nt.prototype.isIntersection = function (t) { for (let e = 0; e < this._result; e++) if (this._intPt[e].equals2D(t)) return !0; return !1 }, nt.prototype.getIntersectionAlongSegment = function (t, e) { return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t][e]] }, nt.prototype.interfaces_ = function () { return [] }, nt.prototype.getClass = function () { return nt }, nt.computeEdgeDistance = function (t, e, n) { const r = Math.abs(n.x - e.x); const i = Math.abs(n.y - e.y); let o = -1; if (t.equals(e))o = 0; else if (t.equals(n))o = r > i ? r : i; else { const s = Math.abs(t.x - e.x); const a = Math.abs(t.y - e.y); (o = r > i ? s : a) !== 0 || t.equals(e) || (o = Math.max(s, a)) } return et.isTrue(!(o === 0 && !t.equals(e)), 'Bad distance calculation'), o }, nt.nonRobustComputeEdgeDistance = function (t, e, n) { const r = t.x - e.x; const i = t.y - e.y; const o = Math.sqrt(r * r + i * i); return et.isTrue(!(o === 0 && !t.equals(e)), 'Invalid distance calculation'), o }, rt.DONT_INTERSECT.get = function () { return 0 }, rt.DO_INTERSECT.get = function () { return 1 }, rt.COLLINEAR.get = function () { return 2 }, rt.NO_INTERSECTION.get = function () { return 0 }, rt.POINT_INTERSECTION.get = function () { return 1 }, rt.COLLINEAR_INTERSECTION.get = function () { return 2 }, Object.defineProperties(nt, rt); const it = (function (t) { function e () { t.apply(this, arguments) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isInSegmentEnvelopes = function (t) { const e = new V(this._inputLines[0][0], this._inputLines[0][1]); const n = new V(this._inputLines[1][0], this._inputLines[1][1]); return e.contains(t) && n.contains(t) }, e.prototype.computeIntersection = function () { if (arguments.length !== 3) return t.prototype.computeIntersection.apply(this, arguments); const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; if (this._isProper = !1, V.intersects(n, r, e) && at.orientationIndex(n, r, e) === 0 && at.orientationIndex(r, n, e) === 0) return this._isProper = !0, (e.equals(n) || e.equals(r)) && (this._isProper = !1), this._result = t.POINT_INTERSECTION, null; this._result = t.NO_INTERSECTION }, e.prototype.normalizeToMinimum = function (t, e, n, r, i) { i.x = this.smallestInAbsValue(t.x, e.x, n.x, r.x), i.y = this.smallestInAbsValue(t.y, e.y, n.y, r.y), t.x -= i.x, t.y -= i.y, e.x -= i.x, e.y -= i.y, n.x -= i.x, n.y -= i.y, r.x -= i.x, r.y -= i.y }, e.prototype.safeHCoordinateIntersection = function (t, n, r, i) { let o = null; try { o = Y.intersection(t, n, r, i) } catch (s) { if (!(s instanceof U)) throw s; o = e.nearestEndpoint(t, n, r, i) } return o }, e.prototype.intersection = function (t, n, r, i) { let o = this.intersectionWithNormalization(t, n, r, i); return this.isInSegmentEnvelopes(o) || (o = new I(e.nearestEndpoint(t, n, r, i))), this._precisionModel !== null && this._precisionModel.makePrecise(o), o }, e.prototype.smallestInAbsValue = function (t, e, n, r) { let i = t; let o = Math.abs(i); return Math.abs(e) < o && (i = e, o = Math.abs(e)), Math.abs(n) < o && (i = n, o = Math.abs(n)), Math.abs(r) < o && (i = r), i }, e.prototype.checkDD = function (t, e, n, r, i) { const o = k.intersection(t, e, n, r); const s = this.isInSegmentEnvelopes(o); X.out.println('DD in env = ' + s + '  --------------------- ' + o), i.distance(o) > 1e-4 && X.out.println('Distance = ' + i.distance(o)) }, e.prototype.intersectionWithNormalization = function (t, e, n, r) { const i = new I(t); const o = new I(e); const s = new I(n); const a = new I(r); const u = new I(); this.normalizeToEnvCentre(i, o, s, a, u); const l = this.safeHCoordinateIntersection(i, o, s, a); return l.x += u.x, l.y += u.y, l }, e.prototype.computeCollinearIntersection = function (e, n, r, i) { const o = V.intersects(e, n, r); const s = V.intersects(e, n, i); const a = V.intersects(r, i, e); const u = V.intersects(r, i, n); return o && s ? (this._intPt[0] = r, this._intPt[1] = i, t.COLLINEAR_INTERSECTION) : a && u ? (this._intPt[0] = e, this._intPt[1] = n, t.COLLINEAR_INTERSECTION) : o && a ? (this._intPt[0] = r, this._intPt[1] = e, !r.equals(e) || s || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : o && u ? (this._intPt[0] = r, this._intPt[1] = n, !r.equals(n) || s || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && a ? (this._intPt[0] = i, this._intPt[1] = e, !i.equals(e) || o || u ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : s && u ? (this._intPt[0] = i, this._intPt[1] = n, !i.equals(n) || o || a ? t.COLLINEAR_INTERSECTION : t.POINT_INTERSECTION) : t.NO_INTERSECTION }, e.prototype.normalizeToEnvCentre = function (t, e, n, r, i) { const o = t.x < e.x ? t.x : e.x; const s = t.y < e.y ? t.y : e.y; const a = t.x > e.x ? t.x : e.x; const u = t.y > e.y ? t.y : e.y; const l = n.x < r.x ? n.x : r.x; const c = n.y < r.y ? n.y : r.y; const f = n.x > r.x ? n.x : r.x; const h = n.y > r.y ? n.y : r.y; const p = ((o > l ? o : l) + (a < f ? a : f)) / 2; const g = ((s > c ? s : c) + (u < h ? u : h)) / 2; i.x = p, i.y = g, t.x -= i.x, t.y -= i.y, e.x -= i.x, e.y -= i.y, n.x -= i.x, n.y -= i.y, r.x -= i.x, r.y -= i.y }, e.prototype.computeIntersect = function (e, n, r, i) { if (this._isProper = !1, !V.intersects(e, n, r, i)) return t.NO_INTERSECTION; const o = at.orientationIndex(e, n, r); const s = at.orientationIndex(e, n, i); if (o > 0 && s > 0 || o < 0 && s < 0) return t.NO_INTERSECTION; const a = at.orientationIndex(r, i, e); const u = at.orientationIndex(r, i, n); return a > 0 && u > 0 || a < 0 && u < 0 ? t.NO_INTERSECTION : o === 0 && s === 0 && a === 0 && u === 0 ? this.computeCollinearIntersection(e, n, r, i) : (o === 0 || s === 0 || a === 0 || u === 0 ? (this._isProper = !1, e.equals2D(r) || e.equals2D(i) ? this._intPt[0] = e : n.equals2D(r) || n.equals2D(i) ? this._intPt[0] = n : o === 0 ? this._intPt[0] = new I(r) : s === 0 ? this._intPt[0] = new I(i) : a === 0 ? this._intPt[0] = new I(e) : u === 0 && (this._intPt[0] = new I(n))) : (this._isProper = !0, this._intPt[0] = this.intersection(e, n, r, i)), t.POINT_INTERSECTION) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e.nearestEndpoint = function (t, e, n, r) { let i = t; let o = at.distancePointLine(t, n, r); let s = at.distancePointLine(e, n, r); return s < o && (o = s, i = e), (s = at.distancePointLine(n, t, e)) < o && (o = s, i = n), (s = at.distancePointLine(r, t, e)) < o && (o = s, i = r), i }, e }(nt)); const ot = function () {}; ot.prototype.interfaces_ = function () { return [] }, ot.prototype.getClass = function () { return ot }, ot.orientationIndex = function (t, e, n) { const r = e.x - t.x; const i = e.y - t.y; const o = n.x - e.x; const s = n.y - e.y; return ot.signOfDet2x2(r, i, o, s) }, ot.signOfDet2x2 = function (t, e, n, r) { let i = null; let o = null; let s = null; if (i = 1, t === 0 || r === 0) return e === 0 || n === 0 ? 0 : e > 0 ? n > 0 ? -i : i : n > 0 ? i : -i; if (e === 0 || n === 0) return r > 0 ? t > 0 ? i : -i : t > 0 ? -i : i; if (e > 0 ? r > 0 ? e <= r || (i = -i, o = t, t = n, n = o, o = e, e = r, r = o) : e <= -r ? (i = -i, n = -n, r = -r) : (o = t, t = -n, n = o, o = e, e = -r, r = o) : r > 0 ? -e <= r ? (i = -i, t = -t, e = -e) : (o = -t, t = n, n = o, o = -e, e = r, r = o) : e >= r ? (t = -t, e = -e, n = -n, r = -r) : (i = -i, o = -t, t = -n, n = o, o = -e, e = -r, r = o), t > 0) { if (!(n > 0)) return i; if (!(t <= n)) return i } else { if (n > 0) return -i; if (!(t >= n)) return -i; i = -i, t = -t, n = -n } for (;;) { if ((r -= (s = Math.floor(n / t)) * e) < 0) return -i; if (r > e) return i; if (t > (n -= s * t) + n) { if (e < r + r) return i } else { if (e > r + r) return -i; n = t - n, r = e - r, i = -i } if (r === 0) return n === 0 ? 0 : -i; if (n === 0) return i; if ((e -= (s = Math.floor(t / n)) * r) < 0) return i; if (e > r) return -i; if (n > (t -= s * n) + t) { if (r < e + e) return -i } else { if (r > e + e) return i; t = n - t, e = r - e, i = -i } if (e === 0) return t === 0 ? 0 : i; if (t === 0) return -i } }; const st = function () { this._p = null, this._crossingCount = 0, this._isPointOnSegment = !1; const t = arguments[0]; this._p = t }; st.prototype.countSegment = function (t, e) { if (t.x < this._p.x && e.x < this._p.x) return null; if (this._p.x === e.x && this._p.y === e.y) return this._isPointOnSegment = !0, null; if (t.y === this._p.y && e.y === this._p.y) { let n = t.x; let r = e.x; return n > r && (n = e.x, r = t.x), this._p.x >= n && this._p.x <= r && (this._isPointOnSegment = !0), null } if (t.y > this._p.y && e.y <= this._p.y || e.y > this._p.y && t.y <= this._p.y) { const i = t.x - this._p.x; const o = t.y - this._p.y; const s = e.x - this._p.x; const a = e.y - this._p.y; let u = ot.signOfDet2x2(i, o, s, a); if (u === 0) return this._isPointOnSegment = !0, null; a < o && (u = -u), u > 0 && this._crossingCount++ } }, st.prototype.isPointInPolygon = function () { return this.getLocation() !== C.EXTERIOR }, st.prototype.getLocation = function () { return this._isPointOnSegment ? C.BOUNDARY : this._crossingCount % 2 == 1 ? C.INTERIOR : C.EXTERIOR }, st.prototype.isOnSegment = function () { return this._isPointOnSegment }, st.prototype.interfaces_ = function () { return [] }, st.prototype.getClass = function () { return st }, st.locatePointInRing = function () { if (arguments[0] instanceof I && O(arguments[1], q)) { for (var t = arguments[1], e = new st(arguments[0]), n = new I(), r = new I(), i = 1; i < t.size(); i++) if (t.getCoordinate(i, n), t.getCoordinate(i - 1, r), e.countSegment(n, r), e.isOnSegment()) return e.getLocation(); return e.getLocation() } if (arguments[0] instanceof I && arguments[1] instanceof Array) { for (var o = arguments[1], s = new st(arguments[0]), a = 1; a < o.length; a++) { const u = o[a]; const l = o[a - 1]; if (s.countSegment(u, l), s.isOnSegment()) return s.getLocation() } return s.getLocation() } }; var at = function () {}; const ut = { CLOCKWISE: { configurable: !0 }, RIGHT: { configurable: !0 }, COUNTERCLOCKWISE: { configurable: !0 }, LEFT: { configurable: !0 }, COLLINEAR: { configurable: !0 }, STRAIGHT: { configurable: !0 } }; at.prototype.interfaces_ = function () { return [] }, at.prototype.getClass = function () { return at }, at.orientationIndex = function (t, e, n) { return k.orientationIndex(t, e, n) }, at.signedArea = function () { if (arguments[0] instanceof Array) { const t = arguments[0]; if (t.length < 3) return 0; for (var e = 0, n = t[0].x, r = 1; r < t.length - 1; r++) { const i = t[r].x - n; const o = t[r + 1].y; e += i * (t[r - 1].y - o) } return e / 2 } if (O(arguments[0], q)) { const s = arguments[0]; const a = s.size(); if (a < 3) return 0; const u = new I(); const l = new I(); const c = new I(); s.getCoordinate(0, l), s.getCoordinate(1, c); const f = l.x; c.x -= f; for (var h = 0, p = 1; p < a - 1; p++)u.y = l.y, l.x = c.x, l.y = c.y, s.getCoordinate(p + 1, c), c.x -= f, h += l.x * (u.y - c.y); return h / 2 } }, at.distanceLineLine = function (t, e, n, r) { if (t.equals(e)) return at.distancePointLine(t, n, r); if (n.equals(r)) return at.distancePointLine(r, t, e); let i = !1; if (V.intersects(t, e, n, r)) { const o = (e.x - t.x) * (r.y - n.y) - (e.y - t.y) * (r.x - n.x); if (o === 0)i = !0; else { const s = (t.y - n.y) * (r.x - n.x) - (t.x - n.x) * (r.y - n.y); const a = ((t.y - n.y) * (e.x - t.x) - (t.x - n.x) * (e.y - t.y)) / o; const u = s / o; (u < 0 || u > 1 || a < 0 || a > 1) && (i = !0) } } else i = !0; return i ? L.min(at.distancePointLine(t, n, r), at.distancePointLine(e, n, r), at.distancePointLine(n, t, e), at.distancePointLine(r, t, e)) : 0 }, at.isPointInRing = function (t, e) { return at.locatePointInRing(t, e) !== C.EXTERIOR }, at.computeLength = function (t) { const e = t.size(); if (e <= 1) return 0; let n = 0; const r = new I(); t.getCoordinate(0, r); for (let i = r.x, o = r.y, s = 1; s < e; s++) { t.getCoordinate(s, r); const a = r.x; const u = r.y; const l = a - i; const c = u - o; n += Math.sqrt(l * l + c * c), i = a, o = u } return n }, at.isCCW = function (t) { const e = t.length - 1; if (e < 3) throw new _('Ring has fewer than 4 points, so orientation cannot be determined'); for (var n = t[0], r = 0, i = 1; i <= e; i++) { const o = t[i]; o.y > n.y && (n = o, r = i) } let s = r; do { (s -= 1) < 0 && (s = e) } while (t[s].equals2D(n) && s !== r); let a = r; do { a = (a + 1) % e } while (t[a].equals2D(n) && a !== r); const u = t[s]; const l = t[a]; if (u.equals2D(n) || l.equals2D(n) || u.equals2D(l)) return !1; const c = at.computeOrientation(u, n, l); return c === 0 ? u.x > l.x : c > 0 }, at.locatePointInRing = function (t, e) { return st.locatePointInRing(t, e) }, at.distancePointLinePerpendicular = function (t, e, n) { const r = (n.x - e.x) * (n.x - e.x) + (n.y - e.y) * (n.y - e.y); const i = ((e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)) / r; return Math.abs(i) * Math.sqrt(r) }, at.computeOrientation = function (t, e, n) { return at.orientationIndex(t, e, n) }, at.distancePointLine = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; if (e.length === 0) throw new _('Line array must contain at least one vertex'); for (var n = t.distance(e[0]), r = 0; r < e.length - 1; r++) { const i = at.distancePointLine(t, e[r], e[r + 1]); i < n && (n = i) } return n } if (arguments.length === 3) { const o = arguments[0]; const s = arguments[1]; const a = arguments[2]; if (s.x === a.x && s.y === a.y) return o.distance(s); const u = (a.x - s.x) * (a.x - s.x) + (a.y - s.y) * (a.y - s.y); const l = ((o.x - s.x) * (a.x - s.x) + (o.y - s.y) * (a.y - s.y)) / u; if (l <= 0) return o.distance(s); if (l >= 1) return o.distance(a); const c = ((s.y - o.y) * (a.x - s.x) - (s.x - o.x) * (a.y - s.y)) / u; return Math.abs(c) * Math.sqrt(u) } }, at.isOnLine = function (t, e) { for (let n = new it(), r = 1; r < e.length; r++) { const i = e[r - 1]; const o = e[r]; if (n.computeIntersection(t, i, o), n.hasIntersection()) return !0 } return !1 }, ut.CLOCKWISE.get = function () { return -1 }, ut.RIGHT.get = function () { return at.CLOCKWISE }, ut.COUNTERCLOCKWISE.get = function () { return 1 }, ut.LEFT.get = function () { return at.COUNTERCLOCKWISE }, ut.COLLINEAR.get = function () { return 0 }, ut.STRAIGHT.get = function () { return at.COLLINEAR }, Object.defineProperties(at, ut); const lt = function () {}; lt.prototype.filter = function (t) {}, lt.prototype.interfaces_ = function () { return [] }, lt.prototype.getClass = function () { return lt }; const ct = function () { const t = arguments[0]; this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t, this._SRID = t.getSRID() }; const ft = { serialVersionUID: { configurable: !0 }, SORTINDEX_POINT: { configurable: !0 }, SORTINDEX_MULTIPOINT: { configurable: !0 }, SORTINDEX_LINESTRING: { configurable: !0 }, SORTINDEX_LINEARRING: { configurable: !0 }, SORTINDEX_MULTILINESTRING: { configurable: !0 }, SORTINDEX_POLYGON: { configurable: !0 }, SORTINDEX_MULTIPOLYGON: { configurable: !0 }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: !0 }, geometryChangedFilter: { configurable: !0 } }; ct.prototype.isGeometryCollection = function () { return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION }, ct.prototype.getFactory = function () { return this._factory }, ct.prototype.getGeometryN = function (t) { return this }, ct.prototype.getArea = function () { return 0 }, ct.prototype.isRectangle = function () { return !1 }, ct.prototype.equals = function () { if (arguments[0] instanceof ct) { const t = arguments[0]; return t !== null && this.equalsTopo(t) } if (arguments[0] instanceof Object) { const e = arguments[0]; if (!(e instanceof ct)) return !1; const n = e; return this.equalsExact(n) } }, ct.prototype.equalsExact = function (t) { return this === t || this.equalsExact(t, 0) }, ct.prototype.geometryChanged = function () { this.apply(ct.geometryChangedFilter) }, ct.prototype.geometryChangedAction = function () { this._envelope = null }, ct.prototype.equalsNorm = function (t) { return t !== null && this.norm().equalsExact(t.norm()) }, ct.prototype.getLength = function () { return 0 }, ct.prototype.getNumGeometries = function () { return 1 }, ct.prototype.compareTo = function () { if (arguments.length === 1) { const t = arguments[0]; const e = t; return this.getSortIndex() !== e.getSortIndex() ? this.getSortIndex() - e.getSortIndex() : this.isEmpty() && e.isEmpty() ? 0 : this.isEmpty() ? -1 : e.isEmpty() ? 1 : this.compareToSameClass(t) } if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; return this.getSortIndex() !== n.getSortIndex() ? this.getSortIndex() - n.getSortIndex() : this.isEmpty() && n.isEmpty() ? 0 : this.isEmpty() ? -1 : n.isEmpty() ? 1 : this.compareToSameClass(n, r) } }, ct.prototype.getUserData = function () { return this._userData }, ct.prototype.getSRID = function () { return this._SRID }, ct.prototype.getEnvelope = function () { return this.getFactory().toGeometry(this.getEnvelopeInternal()) }, ct.prototype.checkNotGeometryCollection = function (t) { if (t.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION) throw new _('This method does not support GeometryCollection arguments') }, ct.prototype.equal = function (t, e, n) { return n === 0 ? t.equals(e) : t.distance(e) <= n }, ct.prototype.norm = function () { const t = this.copy(); return t.normalize(), t }, ct.prototype.getPrecisionModel = function () { return this._factory.getPrecisionModel() }, ct.prototype.getEnvelopeInternal = function () { return this._envelope === null && (this._envelope = this.computeEnvelopeInternal()), new V(this._envelope) }, ct.prototype.setSRID = function (t) { this._SRID = t }, ct.prototype.setUserData = function (t) { this._userData = t }, ct.prototype.compare = function (t, e) { for (var n = t.iterator(), r = e.iterator(); n.hasNext() && r.hasNext();) { const i = n.next(); const o = r.next(); const s = i.compareTo(o); if (s !== 0) return s } return n.hasNext() ? 1 : r.hasNext() ? -1 : 0 }, ct.prototype.hashCode = function () { return this.getEnvelopeInternal().hashCode() }, ct.prototype.isGeometryCollectionOrDerived = function () { return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON }, ct.prototype.interfaces_ = function () { return [E, b, e] }, ct.prototype.getClass = function () { return ct }, ct.hasNonEmptyElements = function (t) { for (let e = 0; e < t.length; e++) if (!t[e].isEmpty()) return !0; return !1 }, ct.hasNullElements = function (t) { for (let e = 0; e < t.length; e++) if (t[e] === null) return !0; return !1 }, ft.serialVersionUID.get = function () { return 0x799ea46522854c00 }, ft.SORTINDEX_POINT.get = function () { return 0 }, ft.SORTINDEX_MULTIPOINT.get = function () { return 1 }, ft.SORTINDEX_LINESTRING.get = function () { return 2 }, ft.SORTINDEX_LINEARRING.get = function () { return 3 }, ft.SORTINDEX_MULTILINESTRING.get = function () { return 4 }, ft.SORTINDEX_POLYGON.get = function () { return 5 }, ft.SORTINDEX_MULTIPOLYGON.get = function () { return 6 }, ft.SORTINDEX_GEOMETRYCOLLECTION.get = function () { return 7 }, ft.geometryChangedFilter.get = function () { return ht }, Object.defineProperties(ct, ft); var ht = function () {}; ht.interfaces_ = function () { return [lt] }, ht.filter = function (t) { t.geometryChangedAction() }; const pt = function () {}; pt.prototype.filter = function (t) {}, pt.prototype.interfaces_ = function () { return [] }, pt.prototype.getClass = function () { return pt }; const gt = function () {}; const dt = { Mod2BoundaryNodeRule: { configurable: !0 }, EndPointBoundaryNodeRule: { configurable: !0 }, MultiValentEndPointBoundaryNodeRule: { configurable: !0 }, MonoValentEndPointBoundaryNodeRule: { configurable: !0 }, MOD2_BOUNDARY_RULE: { configurable: !0 }, ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: !0 }, OGC_SFS_BOUNDARY_RULE: { configurable: !0 } }; gt.prototype.isInBoundary = function (t) {}, gt.prototype.interfaces_ = function () { return [] }, gt.prototype.getClass = function () { return gt }, dt.Mod2BoundaryNodeRule.get = function () { return yt }, dt.EndPointBoundaryNodeRule.get = function () { return vt }, dt.MultiValentEndPointBoundaryNodeRule.get = function () { return _t }, dt.MonoValentEndPointBoundaryNodeRule.get = function () { return mt }, dt.MOD2_BOUNDARY_RULE.get = function () { return new yt() }, dt.ENDPOINT_BOUNDARY_RULE.get = function () { return new vt() }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new _t() }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new mt() }, dt.OGC_SFS_BOUNDARY_RULE.get = function () { return gt.MOD2_BOUNDARY_RULE }, Object.defineProperties(gt, dt); var yt = function () {}; yt.prototype.isInBoundary = function (t) { return t % 2 == 1 }, yt.prototype.interfaces_ = function () { return [gt] }, yt.prototype.getClass = function () { return yt }; var vt = function () {}; vt.prototype.isInBoundary = function (t) { return t > 0 }, vt.prototype.interfaces_ = function () { return [gt] }, vt.prototype.getClass = function () { return vt }; var _t = function () {}; _t.prototype.isInBoundary = function (t) { return t > 1 }, _t.prototype.interfaces_ = function () { return [gt] }, _t.prototype.getClass = function () { return _t }; var mt = function () {}; mt.prototype.isInBoundary = function (t) { return t === 1 }, mt.prototype.interfaces_ = function () { return [gt] }, mt.prototype.getClass = function () { return mt }; var xt = function () {}; xt.prototype.add = function () {}, xt.prototype.addAll = function () {}, xt.prototype.isEmpty = function () {}, xt.prototype.iterator = function () {}, xt.prototype.size = function () {}, xt.prototype.toArray = function () {}, xt.prototype.remove = function () {}, (n.prototype = new Error()).name = 'IndexOutOfBoundsException'; const bt = function () {}; bt.prototype.hasNext = function () {}, bt.prototype.next = function () {}, bt.prototype.remove = function () {}; const Et = (function (t) { function e () { t.apply(this, arguments) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function () {}, e.prototype.set = function () {}, e.prototype.isEmpty = function () {}, e }(xt)); (r.prototype = new Error()).name = 'NoSuchElementException'; const wt = (function (t) { function e () { t.call(this), this.array_ = [], arguments[0] instanceof xt && this.addAll(arguments[0]) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.ensureCapacity = function () {}, e.prototype.interfaces_ = function () { return [t, xt] }, e.prototype.add = function (t) { return arguments.length === 1 ? this.array_.push(t) : this.array_.splice(arguments[0], arguments[1]), !0 }, e.prototype.clear = function () { this.array_ = [] }, e.prototype.addAll = function (t) { for (let e = t.iterator(); e.hasNext();) this.add(e.next()); return !0 }, e.prototype.set = function (t, e) { const n = this.array_[t]; return this.array_[t] = e, n }, e.prototype.iterator = function () { return new It(this) }, e.prototype.get = function (t) { if (t < 0 || t >= this.size()) throw new n(); return this.array_[t] }, e.prototype.isEmpty = function () { return this.array_.length === 0 }, e.prototype.size = function () { return this.array_.length }, e.prototype.toArray = function () { for (var t = [], e = 0, n = this.array_.length; e < n; e++)t.push(this.array_[e]); return t }, e.prototype.remove = function (t) { for (var e = !1, n = 0, r = this.array_.length; n < r; n++) if (this.array_[n] === t) { this.array_.splice(n, 1), e = !0; break } return e }, e }(Et)); var It = (function (t) { function e (e) { t.call(this), this.arrayList_ = e, this.position_ = 0 } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () { if (this.position_ === this.arrayList_.size()) throw new r(); return this.arrayList_.get(this.position_++) }, e.prototype.hasNext = function () { return this.position_ < this.arrayList_.size() }, e.prototype.set = function (t) { return this.arrayList_.set(this.position_ - 1, t) }, e.prototype.remove = function () { this.arrayList_.remove(this.arrayList_.get(this.position_)) }, e }(bt)); const St = (function (t) { function e () { if (t.call(this), arguments.length === 0);else if (arguments.length === 1) { const e = arguments[0]; this.ensureCapacity(e.length), this.add(e, !0) } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; this.ensureCapacity(n.length), this.add(n, r) } }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { coordArrayType: { configurable: !0 } }; return n.coordArrayType.get = function () { return new Array(0).fill(null) }, e.prototype.getCoordinate = function (t) { return this.get(t) }, e.prototype.addAll = function () { if (arguments.length === 2) { for (var e = arguments[1], n = !1, r = arguments[0].iterator(); r.hasNext();) this.add(r.next(), e), n = !0; return n } return t.prototype.addAll.apply(this, arguments) }, e.prototype.clone = function () { for (var e = t.prototype.clone.call(this), n = 0; n < this.size(); n++)e.add(n, this.get(n).copy()); return e }, e.prototype.toCoordinateArray = function () { return this.toArray(e.coordArrayType) }, e.prototype.add = function () { if (arguments.length === 1) { const e = arguments[0]; t.prototype.add.call(this, e) } else if (arguments.length === 2) { if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') { const n = arguments[0]; const r = arguments[1]; return this.add(n, r, !0), !0 } if (arguments[0] instanceof I && typeof arguments[1] === 'boolean') { const i = arguments[0]; if (!arguments[1] && this.size() >= 1 && this.get(this.size() - 1).equals2D(i)) return null; t.prototype.add.call(this, i) } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') { const o = arguments[0]; const s = arguments[1]; return this.add(o, s), !0 } } else if (arguments.length === 3) { if (typeof arguments[2] === 'boolean' && arguments[0] instanceof Array && typeof arguments[1] === 'boolean') { const a = arguments[0]; const u = arguments[1]; if (arguments[2]) for (let l = 0; l < a.length; l++) this.add(a[l], u); else for (let c = a.length - 1; c >= 0; c--) this.add(a[c], u); return !0 } if (typeof arguments[2] === 'boolean' && Number.isInteger(arguments[0]) && arguments[1] instanceof I) { const f = arguments[0]; const h = arguments[1]; if (!arguments[2]) { const p = this.size(); if (p > 0) { if (f > 0 && this.get(f - 1).equals2D(h)) return null; if (f < p && this.get(f).equals2D(h)) return null } }t.prototype.add.call(this, f, h) } } else if (arguments.length === 4) { const g = arguments[0]; const d = arguments[1]; const y = arguments[2]; const v = arguments[3]; let _ = 1; y > v && (_ = -1); for (let m = y; m !== v; m += _) this.add(g[m], d); return !0 } }, e.prototype.closeRing = function () { this.size() > 0 && this.add(new I(this.get(0)), !1) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, Object.defineProperties(e, n), e }(wt)); const Nt = function () {}; const Pt = { ForwardComparator: { configurable: !0 }, BidirectionalComparator: { configurable: !0 }, coordArrayType: { configurable: !0 } }; Pt.ForwardComparator.get = function () { return Ct }, Pt.BidirectionalComparator.get = function () { return Mt }, Pt.coordArrayType.get = function () { return new Array(0).fill(null) }, Nt.prototype.interfaces_ = function () { return [] }, Nt.prototype.getClass = function () { return Nt }, Nt.isRing = function (t) { return !(t.length < 4 || !t[0].equals2D(t[t.length - 1])) }, Nt.ptNotInList = function (t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; if (Nt.indexOf(r, e) < 0) return r } return null }, Nt.scroll = function (t, e) { const n = Nt.indexOf(e, t); if (n < 0) return null; const r = new Array(t.length).fill(null); X.arraycopy(t, n, r, 0, t.length - n), X.arraycopy(t, 0, r, t.length - n, n), X.arraycopy(r, 0, t, 0, t.length) }, Nt.equals = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; if (t === e) return !0; if (t === null || e === null) return !1; if (t.length !== e.length) return !1; for (let n = 0; n < t.length; n++) if (!t[n].equals(e[n])) return !1; return !0 } if (arguments.length === 3) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; if (r === i) return !0; if (r === null || i === null) return !1; if (r.length !== i.length) return !1; for (let s = 0; s < r.length; s++) if (o.compare(r[s], i[s]) !== 0) return !1; return !0 } }, Nt.intersection = function (t, e) { for (var n = new St(), r = 0; r < t.length; r++)e.intersects(t[r]) && n.add(t[r], !0); return n.toCoordinateArray() }, Nt.hasRepeatedPoints = function (t) { for (let e = 1; e < t.length; e++) if (t[e - 1].equals(t[e])) return !0; return !1 }, Nt.removeRepeatedPoints = function (t) { return Nt.hasRepeatedPoints(t) ? new St(t, !1).toCoordinateArray() : t }, Nt.reverse = function (t) { for (let e = t.length - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++) { const i = t[r]; t[r] = t[e - r], t[e - r] = i } }, Nt.removeNull = function (t) { for (var e = 0, n = 0; n < t.length; n++)t[n] !== null && e++; const r = new Array(e).fill(null); if (e === 0) return r; for (let i = 0, o = 0; o < t.length; o++)t[o] !== null && (r[i++] = t[o]); return r }, Nt.copyDeep = function () { if (arguments.length === 1) { for (var t = arguments[0], e = new Array(t.length).fill(null), n = 0; n < t.length; n++)e[n] = new I(t[n]); return e } if (arguments.length === 5) for (let r = arguments[0], i = arguments[1], o = arguments[2], s = arguments[3], a = arguments[4], u = 0; u < a; u++)o[s + u] = new I(r[i + u]) }, Nt.isEqualReversed = function (t, e) { for (let n = 0; n < t.length; n++) { const r = t[n]; const i = e[t.length - n - 1]; if (r.compareTo(i) !== 0) return !1 } return !0 }, Nt.envelope = function (t) { for (var e = new V(), n = 0; n < t.length; n++)e.expandToInclude(t[n]); return e }, Nt.toCoordinateArray = function (t) { return t.toArray(Nt.coordArrayType) }, Nt.atLeastNCoordinatesOrNothing = function (t, e) { return e.length >= t ? e : [] }, Nt.indexOf = function (t, e) { for (let n = 0; n < e.length; n++) if (t.equals(e[n])) return n; return -1 }, Nt.increasingDirection = function (t) { for (let e = 0; e < Math.trunc(t.length / 2); e++) { const n = t.length - 1 - e; const r = t[e].compareTo(t[n]); if (r !== 0) return r } return 1 }, Nt.compare = function (t, e) { for (var n = 0; n < t.length && n < e.length;) { const r = t[n].compareTo(e[n]); if (r !== 0) return r; n++ } return n < e.length ? -1 : n < t.length ? 1 : 0 }, Nt.minCoordinate = function (t) { for (var e = null, n = 0; n < t.length; n++)(e === null || e.compareTo(t[n]) > 0) && (e = t[n]); return e }, Nt.extract = function (t, e, n) { e = L.clamp(e, 0, t.length); let r = (n = L.clamp(n, -1, t.length)) - e + 1; n < 0 && (r = 0), e >= t.length && (r = 0), n < e && (r = 0); const i = new Array(r).fill(null); if (r === 0) return i; for (let o = 0, s = e; s <= n; s++)i[o++] = t[s]; return i }, Object.defineProperties(Nt, Pt); var Ct = function () {}; Ct.prototype.compare = function (t, e) { return Nt.compare(t, e) }, Ct.prototype.interfaces_ = function () { return [w] }, Ct.prototype.getClass = function () { return Ct }; var Mt = function () {}; Mt.prototype.compare = function (t, e) { const n = t; const r = e; if (n.length < r.length) return -1; if (n.length > r.length) return 1; if (n.length === 0) return 0; const i = Nt.compare(n, r); return Nt.isEqualReversed(n, r) ? 0 : i }, Mt.prototype.OLDcompare = function (t, e) { const n = t; const r = e; if (n.length < r.length) return -1; if (n.length > r.length) return 1; if (n.length === 0) return 0; for (let i = Nt.increasingDirection(n), o = Nt.increasingDirection(r), s = i > 0 ? 0 : n.length - 1, a = o > 0 ? 0 : n.length - 1, u = 0; u < n.length; u++) { const l = n[s].compareTo(r[a]); if (l !== 0) return l; s += i, a += o } return 0 }, Mt.prototype.interfaces_ = function () { return [w] }, Mt.prototype.getClass = function () { return Mt }; const Ot = function () {}; Ot.prototype.get = function () {}, Ot.prototype.put = function () {}, Ot.prototype.size = function () {}, Ot.prototype.values = function () {}, Ot.prototype.entrySet = function () {}; const Lt = (function (t) { function e () { t.apply(this, arguments) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e }(Ot)); (i.prototype = new Error()).name = 'OperationNotSupported', (o.prototype = new xt()).contains = function () {}; const Rt = (function (t) { function e () { t.call(this), this.array_ = [], arguments[0] instanceof xt && this.addAll(arguments[0]) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.contains = function (t) { for (let e = 0, n = this.array_.length; e < n; e++) if (this.array_[e] === t) return !0; return !1 }, e.prototype.add = function (t) { return !this.contains(t) && (this.array_.push(t), !0) }, e.prototype.addAll = function (t) { for (let e = t.iterator(); e.hasNext();) this.add(e.next()); return !0 }, e.prototype.remove = function (t) { throw new Error() }, e.prototype.size = function () { return this.array_.length }, e.prototype.isEmpty = function () { return this.array_.length === 0 }, e.prototype.toArray = function () { for (var t = [], e = 0, n = this.array_.length; e < n; e++)t.push(this.array_[e]); return t }, e.prototype.iterator = function () { return new At(this) }, e }(o)); var At = (function (t) { function e (e) { t.call(this), this.hashSet_ = e, this.position_ = 0 } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.next = function () { if (this.position_ === this.hashSet_.size()) throw new r(); return this.hashSet_.array_[this.position_++] }, e.prototype.hasNext = function () { return this.position_ < this.hashSet_.size() }, e.prototype.remove = function () { throw new i() }, e }(bt)); var Tt = 0; (f.prototype = new Lt()).get = function (t) { for (let e = this.root_; e !== null;) { const n = t.compareTo(e.key); if (n < 0)e = e.left; else { if (!(n > 0)) return e.value; e = e.right } } return null }, f.prototype.put = function (t, e) { if (this.root_ === null) return this.root_ = { key: t, value: e, left: null, right: null, parent: null, color: Tt, getValue: function () { return this.value }, getKey: function () { return this.key } }, this.size_ = 1, null; let n; let r; let i = this.root_; do { if (n = i, (r = t.compareTo(i.key)) < 0)i = i.left; else { if (!(r > 0)) { const o = i.value; return i.value = e, o }i = i.right } } while (i !== null); const s = { key: t, left: null, right: null, value: e, parent: n, color: Tt, getValue: function () { return this.value }, getKey: function () { return this.key } }; return r < 0 ? n.left = s : n.right = s, this.fixAfterInsertion(s), this.size_++, null }, f.prototype.fixAfterInsertion = function (t) { for (t.color = 1; t != null && t !== this.root_ && t.parent.color === 1;) if (a(t) === l(a(a(t)))) { const e = c(a(a(t))); s(e) === 1 ? (u(a(t), Tt), u(e, Tt), u(a(a(t)), 1), t = a(a(t))) : (t === c(a(t)) && (t = a(t), this.rotateLeft(t)), u(a(t), Tt), u(a(a(t)), 1), this.rotateRight(a(a(t)))) } else { const n = l(a(a(t))); s(n) === 1 ? (u(a(t), Tt), u(n, Tt), u(a(a(t)), 1), t = a(a(t))) : (t === l(a(t)) && (t = a(t), this.rotateRight(t)), u(a(t), Tt), u(a(a(t)), 1), this.rotateLeft(a(a(t)))) } this.root_.color = Tt }, f.prototype.values = function () { const t = new wt(); let e = this.getFirstEntry(); if (e !== null) for (t.add(e.value); (e = f.successor(e)) !== null;)t.add(e.value); return t }, f.prototype.entrySet = function () { const t = new Rt(); let e = this.getFirstEntry(); if (e !== null) for (t.add(e); (e = f.successor(e)) !== null;)t.add(e); return t }, f.prototype.rotateLeft = function (t) { if (t != null) { const e = t.right; t.right = e.left, e.left != null && (e.left.parent = t), e.parent = t.parent, t.parent === null ? this.root_ = e : t.parent.left === t ? t.parent.left = e : t.parent.right = e, e.left = t, t.parent = e } }, f.prototype.rotateRight = function (t) { if (t != null) { const e = t.left; t.left = e.right, e.right != null && (e.right.parent = t), e.parent = t.parent, t.parent === null ? this.root_ = e : t.parent.right === t ? t.parent.right = e : t.parent.left = e, e.right = t, t.parent = e } }, f.prototype.getFirstEntry = function () { let t = this.root_; if (t != null) for (;t.left != null;)t = t.left; return t }, f.successor = function (t) { if (t === null) return null; if (t.right !== null) { for (var e = t.right; e.left !== null;)e = e.left; return e } for (var n = t.parent, r = t; n !== null && r === n.right;)r = n, n = n.parent; return n }, f.prototype.size = function () { return this.size_ }; const Dt = function () {}; Dt.prototype.interfaces_ = function () { return [] }, Dt.prototype.getClass = function () { return Dt }, h.prototype = new o(), (p.prototype = new h()).contains = function (t) { for (let e = 0, n = this.array_.length; e < n; e++) if (this.array_[e].compareTo(t) === 0) return !0; return !1 }, p.prototype.add = function (t) { if (this.contains(t)) return !1; for (let e = 0, n = this.array_.length; e < n; e++) if (this.array_[e].compareTo(t) === 1) return this.array_.splice(e, 0, t), !0; return this.array_.push(t), !0 }, p.prototype.addAll = function (t) { for (let e = t.iterator(); e.hasNext();) this.add(e.next()); return !0 }, p.prototype.remove = function (t) { throw new i() }, p.prototype.size = function () { return this.array_.length }, p.prototype.isEmpty = function () { return this.array_.length === 0 }, p.prototype.toArray = function () { for (var t = [], e = 0, n = this.array_.length; e < n; e++)t.push(this.array_[e]); return t }, p.prototype.iterator = function () { return new Ft(this) }; var Ft = function (t) { this.treeSet_ = t, this.position_ = 0 }; Ft.prototype.next = function () { if (this.position_ === this.treeSet_.size()) throw new r(); return this.treeSet_.array_[this.position_++] }, Ft.prototype.hasNext = function () { return this.position_ < this.treeSet_.size() }, Ft.prototype.remove = function () { throw new i() }; const jt = function () {}; jt.sort = function () { let t; let e; let n; let r; const i = arguments[0]; if (arguments.length === 1)r = function (t, e) { return t.compareTo(e) }, i.sort(r); else if (arguments.length === 2)n = arguments[1], r = function (t, e) { return n.compare(t, e) }, i.sort(r); else if (arguments.length === 3) { (e = i.slice(arguments[1], arguments[2])).sort(); var o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length)); for (i.splice(0, i.length), t = 0; t < o.length; t++)i.push(o[t]) } else if (arguments.length === 4) for (e = i.slice(arguments[1], arguments[2]), n = arguments[3], r = function (t, e) { return n.compare(t, e) }, e.sort(r), o = i.slice(0, arguments[1]).concat(e, i.slice(arguments[2], i.length)), i.splice(0, i.length), t = 0; t < o.length; t++)i.push(o[t]) }, jt.asList = function (t) { for (var e = new wt(), n = 0, r = t.length; n < r; n++)e.add(t[n]); return e }; const kt = function () {}; const Gt = { P: { configurable: !0 }, L: { configurable: !0 }, A: { configurable: !0 }, FALSE: { configurable: !0 }, TRUE: { configurable: !0 }, DONTCARE: { configurable: !0 }, SYM_FALSE: { configurable: !0 }, SYM_TRUE: { configurable: !0 }, SYM_DONTCARE: { configurable: !0 }, SYM_P: { configurable: !0 }, SYM_L: { configurable: !0 }, SYM_A: { configurable: !0 } }; Gt.P.get = function () { return 0 }, Gt.L.get = function () { return 1 }, Gt.A.get = function () { return 2 }, Gt.FALSE.get = function () { return -1 }, Gt.TRUE.get = function () { return -2 }, Gt.DONTCARE.get = function () { return -3 }, Gt.SYM_FALSE.get = function () { return 'F' }, Gt.SYM_TRUE.get = function () { return 'T' }, Gt.SYM_DONTCARE.get = function () { return '*' }, Gt.SYM_P.get = function () { return '0' }, Gt.SYM_L.get = function () { return '1' }, Gt.SYM_A.get = function () { return '2' }, kt.prototype.interfaces_ = function () { return [] }, kt.prototype.getClass = function () { return kt }, kt.toDimensionSymbol = function (t) { switch (t) { case kt.FALSE:return kt.SYM_FALSE; case kt.TRUE:return kt.SYM_TRUE; case kt.DONTCARE:return kt.SYM_DONTCARE; case kt.P:return kt.SYM_P; case kt.L:return kt.SYM_L; case kt.A:return kt.SYM_A } throw new _('Unknown dimension value: ' + t) }, kt.toDimensionValue = function (t) { switch (D.toUpperCase(t)) { case kt.SYM_FALSE:return kt.FALSE; case kt.SYM_TRUE:return kt.TRUE; case kt.SYM_DONTCARE:return kt.DONTCARE; case kt.SYM_P:return kt.P; case kt.SYM_L:return kt.L; case kt.SYM_A:return kt.A } throw new _('Unknown dimension symbol: ' + t) }, Object.defineProperties(kt, Gt); const qt = function () {}; qt.prototype.filter = function (t) {}, qt.prototype.interfaces_ = function () { return [] }, qt.prototype.getClass = function () { return qt }; const Bt = function () {}; Bt.prototype.filter = function (t, e) {}, Bt.prototype.isDone = function () {}, Bt.prototype.isGeometryChanged = function () {}, Bt.prototype.interfaces_ = function () { return [] }, Bt.prototype.getClass = function () { return Bt }; const zt = (function (t) { function e (e, n) { if (t.call(this, n), this._geometries = e || [], t.hasNullElements(this._geometries)) throw new _('geometries must not contain null elements') }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.computeEnvelopeInternal = function () { for (var t = new V(), e = 0; e < this._geometries.length; e++)t.expandToInclude(this._geometries[e].getEnvelopeInternal()); return t }, e.prototype.getGeometryN = function (t) { return this._geometries[t] }, e.prototype.getSortIndex = function () { return t.SORTINDEX_GEOMETRYCOLLECTION }, e.prototype.getCoordinates = function () { for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = 0; n < this._geometries.length; n++) for (let r = this._geometries[n].getCoordinates(), i = 0; i < r.length; i++)t[++e] = r[i]; return t }, e.prototype.getArea = function () { for (var t = 0, e = 0; e < this._geometries.length; e++)t += this._geometries[e].getArea(); return t }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (!this.isEquivalentClass(e)) return !1; const r = e; if (this._geometries.length !== r._geometries.length) return !1; for (let i = 0; i < this._geometries.length; i++) if (!this._geometries[i].equalsExact(r._geometries[i], n)) return !1; return !0 } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.normalize = function () { for (let t = 0; t < this._geometries.length; t++) this._geometries[t].normalize(); jt.sort(this._geometries) }, e.prototype.getCoordinate = function () { return this.isEmpty() ? null : this._geometries[0].getCoordinate() }, e.prototype.getBoundaryDimension = function () { for (var t = kt.FALSE, e = 0; e < this._geometries.length; e++)t = Math.max(t, this._geometries[e].getBoundaryDimension()); return t }, e.prototype.getDimension = function () { for (var t = kt.FALSE, e = 0; e < this._geometries.length; e++)t = Math.max(t, this._geometries[e].getDimension()); return t }, e.prototype.getLength = function () { for (var t = 0, e = 0; e < this._geometries.length; e++)t += this._geometries[e].getLength(); return t }, e.prototype.getNumPoints = function () { for (var t = 0, e = 0; e < this._geometries.length; e++)t += this._geometries[e].getNumPoints(); return t }, e.prototype.getNumGeometries = function () { return this._geometries.length }, e.prototype.reverse = function () { for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++)e[n] = this._geometries[n].reverse(); return this.getFactory().createGeometryCollection(e) }, e.prototype.compareToSameClass = function () { if (arguments.length === 1) { const t = arguments[0]; const e = new p(jt.asList(this._geometries)); const n = new p(jt.asList(t._geometries)); return this.compare(e, n) } if (arguments.length === 2) { for (var r = arguments[1], i = arguments[0], o = this.getNumGeometries(), s = i.getNumGeometries(), a = 0; a < o && a < s;) { const u = this.getGeometryN(a); const l = i.getGeometryN(a); const c = u.compareToSameClass(l, r); if (c !== 0) return c; a++ } return a < o ? 1 : a < s ? -1 : 0 } }, e.prototype.apply = function () { if (O(arguments[0], pt)) for (let t = arguments[0], e = 0; e < this._geometries.length; e++) this._geometries[e].apply(t); else if (O(arguments[0], Bt)) { const n = arguments[0]; if (this._geometries.length === 0) return null; for (let r = 0; r < this._geometries.length && (this._geometries[r].apply(n), !n.isDone()); r++);n.isGeometryChanged() && this.geometryChanged() } else if (O(arguments[0], qt)) { const i = arguments[0]; i.filter(this); for (let o = 0; o < this._geometries.length; o++) this._geometries[o].apply(i) } else if (O(arguments[0], lt)) { const s = arguments[0]; s.filter(this); for (let a = 0; a < this._geometries.length; a++) this._geometries[a].apply(s) } }, e.prototype.getBoundary = function () { return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null }, e.prototype.clone = function () { const e = t.prototype.clone.call(this); e._geometries = new Array(this._geometries.length).fill(null); for (let n = 0; n < this._geometries.length; n++)e._geometries[n] = this._geometries[n].clone(); return e }, e.prototype.getGeometryType = function () { return 'GeometryCollection' }, e.prototype.copy = function () { for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)t[n] = this._geometries[n].copy(); return new e(t, this._factory) }, e.prototype.isEmpty = function () { for (let t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isEmpty()) return !1; return !0 }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return -0x4f07bcb1f857d800 }, Object.defineProperties(e, n), e }(ct)); const Ut = (function (t) { function e () { t.apply(this, arguments) }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.getSortIndex = function () { return ct.SORTINDEX_MULTILINESTRING }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n) } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.getBoundaryDimension = function () { return this.isClosed() ? kt.FALSE : 0 }, e.prototype.isClosed = function () { if (this.isEmpty()) return !1; for (let t = 0; t < this._geometries.length; t++) if (!this._geometries[t].isClosed()) return !1; return !0 }, e.prototype.getDimension = function () { return 1 }, e.prototype.reverse = function () { for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++)e[t - 1 - n] = this._geometries[n].reverse(); return this.getFactory().createMultiLineString(e) }, e.prototype.getBoundary = function () { return new Xt(this).getBoundary() }, e.prototype.getGeometryType = function () { return 'MultiLineString' }, e.prototype.copy = function () { for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)t[n] = this._geometries[n].copy(); return new e(t, this._factory) }, e.prototype.interfaces_ = function () { return [Dt] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return 0x7155d2ab4afa8000 }, Object.defineProperties(e, n), e }(zt)); var Xt = function () { if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, arguments.length === 1) { const t = arguments[0]; const e = gt.MOD2_BOUNDARY_RULE; this._geom = t, this._geomFact = t.getFactory(), this._bnRule = e } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; this._geom = n, this._geomFact = n.getFactory(), this._bnRule = r } }; Xt.prototype.boundaryMultiLineString = function (t) { if (this._geom.isEmpty()) return this.getEmptyMultiPoint(); const e = this.computeBoundaryCoordinates(t); return e.length === 1 ? this._geomFact.createPoint(e[0]) : this._geomFact.createMultiPointFromCoords(e) }, Xt.prototype.getBoundary = function () { return this._geom instanceof Jt ? this.boundaryLineString(this._geom) : this._geom instanceof Ut ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary() }, Xt.prototype.boundaryLineString = function (t) { return this._geom.isEmpty() ? this.getEmptyMultiPoint() : t.isClosed() ? this._bnRule.isInBoundary(2) ? t.getStartPoint() : this._geomFact.createMultiPoint() : this._geomFact.createMultiPoint([t.getStartPoint(), t.getEndPoint()]) }, Xt.prototype.getEmptyMultiPoint = function () { return this._geomFact.createMultiPoint() }, Xt.prototype.computeBoundaryCoordinates = function (t) { const e = new wt(); this._endpointMap = new f(); for (let n = 0; n < t.getNumGeometries(); n++) { const r = t.getGeometryN(n); r.getNumPoints() !== 0 && (this.addEndpoint(r.getCoordinateN(0)), this.addEndpoint(r.getCoordinateN(r.getNumPoints() - 1))) } for (let i = this._endpointMap.entrySet().iterator(); i.hasNext();) { const o = i.next(); const s = o.getValue().count; this._bnRule.isInBoundary(s) && e.add(o.getKey()) } return Nt.toCoordinateArray(e) }, Xt.prototype.addEndpoint = function (t) { let e = this._endpointMap.get(t); e === null && (e = new Yt(), this._endpointMap.put(t, e)), e.count++ }, Xt.prototype.interfaces_ = function () { return [] }, Xt.prototype.getClass = function () { return Xt }, Xt.getBoundary = function () { return arguments.length === 1 ? new Xt(arguments[0]).getBoundary() : arguments.length === 2 ? new Xt(arguments[0], arguments[1]).getBoundary() : void 0 }; var Yt = function () { this.count = null }; Yt.prototype.interfaces_ = function () { return [] }, Yt.prototype.getClass = function () { return Yt }; const Vt = function () {}; const Wt = { NEWLINE: { configurable: !0 }, SIMPLE_ORDINATE_FORMAT: { configurable: !0 } }; Vt.prototype.interfaces_ = function () { return [] }, Vt.prototype.getClass = function () { return Vt }, Vt.chars = function (t, e) { for (var n = new Array(e).fill(null), r = 0; r < e; r++)n[r] = t; return String(n) }, Vt.getStackTrace = function () { if (arguments.length === 1) { const t = arguments[0]; const e = new function () {}(); const n = new function () {}(e); return t.printStackTrace(n), e.toString() } if (arguments.length === 2) { for (var r = arguments[0], i = arguments[1], o = '', s = new function () {}(new function () {}(Vt.getStackTrace(r))), a = 0; a < i; a++) try { o += s.readLine() + Vt.NEWLINE } catch (t) { if (!(t instanceof g)) throw t; et.shouldNeverReachHere() } return o } }, Vt.split = function (t, e) { for (var n = e.length, r = new wt(), i = '' + t, o = i.indexOf(e); o >= 0;) { const s = i.substring(0, o); r.add(s), o = (i = i.substring(o + n)).indexOf(e) }i.length > 0 && r.add(i); for (var a = new Array(r.size()).fill(null), u = 0; u < a.length; u++)a[u] = r.get(u); return a }, Vt.toString = function () { if (arguments.length === 1) { const t = arguments[0]; return Vt.SIMPLE_ORDINATE_FORMAT.format(t) } }, Vt.spaces = function (t) { return Vt.chars(' ', t) }, Wt.NEWLINE.get = function () { return X.getProperty('line.separator') }, Wt.SIMPLE_ORDINATE_FORMAT.get = function () { return new function () {}('0.#') }, Object.defineProperties(Vt, Wt); const Ht = function () {}; Ht.prototype.interfaces_ = function () { return [] }, Ht.prototype.getClass = function () { return Ht }, Ht.copyCoord = function (t, e, n, r) { for (let i = Math.min(t.getDimension(), n.getDimension()), o = 0; o < i; o++)n.setOrdinate(r, o, t.getOrdinate(e, o)) }, Ht.isRing = function (t) { const e = t.size(); return e === 0 || !(e <= 3) && t.getOrdinate(0, q.X) === t.getOrdinate(e - 1, q.X) && t.getOrdinate(0, q.Y) === t.getOrdinate(e - 1, q.Y) }, Ht.isEqual = function (t, e) { const n = t.size(); if (n !== e.size()) return !1; for (let r = Math.min(t.getDimension(), e.getDimension()), i = 0; i < n; i++) for (let o = 0; o < r; o++) { const s = t.getOrdinate(i, o); const a = e.getOrdinate(i, o); if (!(t.getOrdinate(i, o) === e.getOrdinate(i, o) || m.isNaN(s) && m.isNaN(a))) return !1 } return !0 }, Ht.extend = function (t, e, n) { const r = t.create(n, e.getDimension()); const i = e.size(); if (Ht.copy(e, 0, r, 0, i), i > 0) for (let o = i; o < n; o++)Ht.copy(e, i - 1, r, o, 1); return r }, Ht.reverse = function (t) { for (let e = t.size() - 1, n = Math.trunc(e / 2), r = 0; r <= n; r++)Ht.swap(t, r, e - r) }, Ht.swap = function (t, e, n) { if (e === n) return null; for (let r = 0; r < t.getDimension(); r++) { const i = t.getOrdinate(e, r); t.setOrdinate(e, r, t.getOrdinate(n, r)), t.setOrdinate(n, r, i) } }, Ht.copy = function (t, e, n, r, i) { for (let o = 0; o < i; o++)Ht.copyCoord(t, e + o, n, r + o) }, Ht.toString = function () { if (arguments.length === 1) { const t = arguments[0]; const e = t.size(); if (e === 0) return '()'; const n = t.getDimension(); const r = new A(); r.append('('); for (let i = 0; i < e; i++) { i > 0 && r.append(' '); for (let o = 0; o < n; o++)o > 0 && r.append(','), r.append(Vt.toString(t.getOrdinate(i, o))) } return r.append(')'), r.toString() } }, Ht.ensureValidRing = function (t, e) { const n = e.size(); return n === 0 ? e : n <= 3 ? Ht.createClosedRing(t, e, 4) : e.getOrdinate(0, q.X) === e.getOrdinate(n - 1, q.X) && e.getOrdinate(0, q.Y) === e.getOrdinate(n - 1, q.Y) ? e : Ht.createClosedRing(t, e, n + 1) }, Ht.createClosedRing = function (t, e, n) { const r = t.create(n, e.getDimension()); const i = e.size(); Ht.copy(e, 0, r, 0, i); for (let o = i; o < n; o++)Ht.copy(e, 0, r, o, 1); return r }; var Jt = (function (t) { function e (e, n) { t.call(this, n), this._points = null, this.init(e) }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.computeEnvelopeInternal = function () { return this.isEmpty() ? new V() : this._points.expandEnvelope(new V()) }, e.prototype.isRing = function () { return this.isClosed() && this.isSimple() }, e.prototype.getSortIndex = function () { return t.SORTINDEX_LINESTRING }, e.prototype.getCoordinates = function () { return this._points.toCoordinateArray() }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (!this.isEquivalentClass(e)) return !1; const r = e; if (this._points.size() !== r._points.size()) return !1; for (let i = 0; i < this._points.size(); i++) if (!this.equal(this._points.getCoordinate(i), r._points.getCoordinate(i), n)) return !1; return !0 } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.normalize = function () { for (let t = 0; t < Math.trunc(this._points.size() / 2); t++) { const e = this._points.size() - 1 - t; if (!this._points.getCoordinate(t).equals(this._points.getCoordinate(e))) return this._points.getCoordinate(t).compareTo(this._points.getCoordinate(e)) > 0 && Ht.reverse(this._points), null } }, e.prototype.getCoordinate = function () { return this.isEmpty() ? null : this._points.getCoordinate(0) }, e.prototype.getBoundaryDimension = function () { return this.isClosed() ? kt.FALSE : 0 }, e.prototype.isClosed = function () { return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1)) }, e.prototype.getEndPoint = function () { return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1) }, e.prototype.getDimension = function () { return 1 }, e.prototype.getLength = function () { return at.computeLength(this._points) }, e.prototype.getNumPoints = function () { return this._points.size() }, e.prototype.reverse = function () { const t = this._points.copy(); return Ht.reverse(t), this.getFactory().createLineString(t) }, e.prototype.compareToSameClass = function () { if (arguments.length === 1) { for (var t = arguments[0], e = 0, n = 0; e < this._points.size() && n < t._points.size();) { const r = this._points.getCoordinate(e).compareTo(t._points.getCoordinate(n)); if (r !== 0) return r; e++, n++ } return e < this._points.size() ? 1 : n < t._points.size() ? -1 : 0 } if (arguments.length === 2) { const i = arguments[0]; return arguments[1].compare(this._points, i._points) } }, e.prototype.apply = function () { if (O(arguments[0], pt)) for (let t = arguments[0], e = 0; e < this._points.size(); e++)t.filter(this._points.getCoordinate(e)); else if (O(arguments[0], Bt)) { const n = arguments[0]; if (this._points.size() === 0) return null; for (let r = 0; r < this._points.size() && (n.filter(this._points, r), !n.isDone()); r++);n.isGeometryChanged() && this.geometryChanged() } else (O(arguments[0], qt) || O(arguments[0], lt)) && arguments[0].filter(this) }, e.prototype.getBoundary = function () { return new Xt(this).getBoundary() }, e.prototype.isEquivalentClass = function (t) { return t instanceof e }, e.prototype.clone = function () { const e = t.prototype.clone.call(this); return e._points = this._points.clone(), e }, e.prototype.getCoordinateN = function (t) { return this._points.getCoordinate(t) }, e.prototype.getGeometryType = function () { return 'LineString' }, e.prototype.copy = function () { return new e(this._points.copy(), this._factory) }, e.prototype.getCoordinateSequence = function () { return this._points }, e.prototype.isEmpty = function () { return this._points.size() === 0 }, e.prototype.init = function (t) { if (t === null && (t = this.getFactory().getCoordinateSequenceFactory().create([])), t.size() === 1) throw new _('Invalid number of points in LineString (found ' + t.size() + ' - must be 0 or >= 2)'); this._points = t }, e.prototype.isCoordinate = function (t) { for (let e = 0; e < this._points.size(); e++) if (this._points.getCoordinate(e).equals(t)) return !0; return !1 }, e.prototype.getStartPoint = function () { return this.isEmpty() ? null : this.getPointN(0) }, e.prototype.getPointN = function (t) { return this.getFactory().createPoint(this._points.getCoordinate(t)) }, e.prototype.interfaces_ = function () { return [Dt] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return 0x2b2b51ba435c8e00 }, Object.defineProperties(e, n), e }(ct)); const Zt = function () {}; Zt.prototype.interfaces_ = function () { return [] }, Zt.prototype.getClass = function () { return Zt }; const Kt = (function (t) { function e (e, n) { t.call(this, n), this._coordinates = e || null, this.init(this._coordinates) }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.computeEnvelopeInternal = function () { if (this.isEmpty()) return new V(); const t = new V(); return t.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t }, e.prototype.getSortIndex = function () { return t.SORTINDEX_POINT }, e.prototype.getCoordinates = function () { return this.isEmpty() ? [] : [this.getCoordinate()] }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return !!this.isEquivalentClass(e) && (!(!this.isEmpty() || !e.isEmpty()) || this.isEmpty() === e.isEmpty() && this.equal(e.getCoordinate(), this.getCoordinate(), n)) } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.normalize = function () {}, e.prototype.getCoordinate = function () { return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null }, e.prototype.getBoundaryDimension = function () { return kt.FALSE }, e.prototype.getDimension = function () { return 0 }, e.prototype.getNumPoints = function () { return this.isEmpty() ? 0 : 1 }, e.prototype.reverse = function () { return this.copy() }, e.prototype.getX = function () { if (this.getCoordinate() === null) throw new Error('getX called on empty Point'); return this.getCoordinate().x }, e.prototype.compareToSameClass = function () { if (arguments.length === 1) { const t = arguments[0]; return this.getCoordinate().compareTo(t.getCoordinate()) } if (arguments.length === 2) { const e = arguments[0]; return arguments[1].compare(this._coordinates, e._coordinates) } }, e.prototype.apply = function () { if (O(arguments[0], pt)) { const t = arguments[0]; if (this.isEmpty()) return null; t.filter(this.getCoordinate()) } else if (O(arguments[0], Bt)) { const e = arguments[0]; if (this.isEmpty()) return null; e.filter(this._coordinates, 0), e.isGeometryChanged() && this.geometryChanged() } else (O(arguments[0], qt) || O(arguments[0], lt)) && arguments[0].filter(this) }, e.prototype.getBoundary = function () { return this.getFactory().createGeometryCollection(null) }, e.prototype.clone = function () { const e = t.prototype.clone.call(this); return e._coordinates = this._coordinates.clone(), e }, e.prototype.getGeometryType = function () { return 'Point' }, e.prototype.copy = function () { return new e(this._coordinates.copy(), this._factory) }, e.prototype.getCoordinateSequence = function () { return this._coordinates }, e.prototype.getY = function () { if (this.getCoordinate() === null) throw new Error('getY called on empty Point'); return this.getCoordinate().y }, e.prototype.isEmpty = function () { return this._coordinates.size() === 0 }, e.prototype.init = function (t) { t === null && (t = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t.size() <= 1), this._coordinates = t }, e.prototype.isSimple = function () { return !0 }, e.prototype.interfaces_ = function () { return [Zt] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return 0x44077bad161cbc00 }, Object.defineProperties(e, n), e }(ct)); const Qt = function () {}; Qt.prototype.interfaces_ = function () { return [] }, Qt.prototype.getClass = function () { return Qt }; const $t = (function (t) { function e (e, n, r) { if (t.call(this, r), this._shell = null, this._holes = null, e === null && (e = this.getFactory().createLinearRing()), n === null && (n = []), t.hasNullElements(n)) throw new _('holes must not contain null elements'); if (e.isEmpty() && t.hasNonEmptyElements(n)) throw new _('shell is empty but holes are not'); this._shell = e, this._holes = n }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.computeEnvelopeInternal = function () { return this._shell.getEnvelopeInternal() }, e.prototype.getSortIndex = function () { return t.SORTINDEX_POLYGON }, e.prototype.getCoordinates = function () { if (this.isEmpty()) return []; for (var t = new Array(this.getNumPoints()).fill(null), e = -1, n = this._shell.getCoordinates(), r = 0; r < n.length; r++)t[++e] = n[r]; for (let i = 0; i < this._holes.length; i++) for (let o = this._holes[i].getCoordinates(), s = 0; s < o.length; s++)t[++e] = o[s]; return t }, e.prototype.getArea = function () { let t = 0; t += Math.abs(at.signedArea(this._shell.getCoordinateSequence())); for (let e = 0; e < this._holes.length; e++)t -= Math.abs(at.signedArea(this._holes[e].getCoordinateSequence())); return t }, e.prototype.isRectangle = function () { if (this.getNumInteriorRing() !== 0) return !1; if (this._shell === null) return !1; if (this._shell.getNumPoints() !== 5) return !1; for (var t = this._shell.getCoordinateSequence(), e = this.getEnvelopeInternal(), n = 0; n < 5; n++) { const r = t.getX(n); if (r !== e.getMinX() && r !== e.getMaxX()) return !1; const i = t.getY(n); if (i !== e.getMinY() && i !== e.getMaxY()) return !1 } for (let o = t.getX(0), s = t.getY(0), a = 1; a <= 4; a++) { const u = t.getX(a); const l = t.getY(a); if (u !== o == (l !== s)) return !1; o = u, s = l } return !0 }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (!this.isEquivalentClass(e)) return !1; const r = e; const i = this._shell; const o = r._shell; if (!i.equalsExact(o, n)) return !1; if (this._holes.length !== r._holes.length) return !1; for (let s = 0; s < this._holes.length; s++) if (!this._holes[s].equalsExact(r._holes[s], n)) return !1; return !0 } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.normalize = function () { if (arguments.length === 0) { this.normalize(this._shell, !0); for (let t = 0; t < this._holes.length; t++) this.normalize(this._holes[t], !1); jt.sort(this._holes) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (e.isEmpty()) return null; const r = new Array(e.getCoordinates().length - 1).fill(null); X.arraycopy(e.getCoordinates(), 0, r, 0, r.length); const i = Nt.minCoordinate(e.getCoordinates()); Nt.scroll(r, i), X.arraycopy(r, 0, e.getCoordinates(), 0, r.length), e.getCoordinates()[r.length] = r[0], at.isCCW(e.getCoordinates()) === n && Nt.reverse(e.getCoordinates()) } }, e.prototype.getCoordinate = function () { return this._shell.getCoordinate() }, e.prototype.getNumInteriorRing = function () { return this._holes.length }, e.prototype.getBoundaryDimension = function () { return 1 }, e.prototype.getDimension = function () { return 2 }, e.prototype.getLength = function () { let t = 0; t += this._shell.getLength(); for (let e = 0; e < this._holes.length; e++)t += this._holes[e].getLength(); return t }, e.prototype.getNumPoints = function () { for (var t = this._shell.getNumPoints(), e = 0; e < this._holes.length; e++)t += this._holes[e].getNumPoints(); return t }, e.prototype.reverse = function () { const t = this.copy(); t._shell = this._shell.copy().reverse(), t._holes = new Array(this._holes.length).fill(null); for (let e = 0; e < this._holes.length; e++)t._holes[e] = this._holes[e].copy().reverse(); return t }, e.prototype.convexHull = function () { return this.getExteriorRing().convexHull() }, e.prototype.compareToSameClass = function () { if (arguments.length === 1) { const t = arguments[0]; const e = this._shell; const n = t._shell; return e.compareToSameClass(n) } if (arguments.length === 2) { const r = arguments[1]; const i = arguments[0]; const o = this._shell; const s = i._shell; const a = o.compareToSameClass(s, r); if (a !== 0) return a; for (var u = this.getNumInteriorRing(), l = i.getNumInteriorRing(), c = 0; c < u && c < l;) { const f = this.getInteriorRingN(c); const h = i.getInteriorRingN(c); const p = f.compareToSameClass(h, r); if (p !== 0) return p; c++ } return c < u ? 1 : c < l ? -1 : 0 } }, e.prototype.apply = function (t) { if (O(t, pt)) { this._shell.apply(t); for (let e = 0; e < this._holes.length; e++) this._holes[e].apply(t) } else if (O(t, Bt)) { if (this._shell.apply(t), !t.isDone()) for (let n = 0; n < this._holes.length && (this._holes[n].apply(t), !t.isDone()); n++);t.isGeometryChanged() && this.geometryChanged() } else if (O(t, qt))t.filter(this); else if (O(t, lt)) { t.filter(this), this._shell.apply(t); for (let r = 0; r < this._holes.length; r++) this._holes[r].apply(t) } }, e.prototype.getBoundary = function () { if (this.isEmpty()) return this.getFactory().createMultiLineString(); const t = new Array(this._holes.length + 1).fill(null); t[0] = this._shell; for (let e = 0; e < this._holes.length; e++)t[e + 1] = this._holes[e]; return t.length <= 1 ? this.getFactory().createLinearRing(t[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t) }, e.prototype.clone = function () { const e = t.prototype.clone.call(this); e._shell = this._shell.clone(), e._holes = new Array(this._holes.length).fill(null); for (let n = 0; n < this._holes.length; n++)e._holes[n] = this._holes[n].clone(); return e }, e.prototype.getGeometryType = function () { return 'Polygon' }, e.prototype.copy = function () { for (var t = this._shell.copy(), n = new Array(this._holes.length).fill(null), r = 0; r < n.length; r++)n[r] = this._holes[r].copy(); return new e(t, n, this._factory) }, e.prototype.getExteriorRing = function () { return this._shell }, e.prototype.isEmpty = function () { return this._shell.isEmpty() }, e.prototype.getInteriorRingN = function (t) { return this._holes[t] }, e.prototype.interfaces_ = function () { return [Qt] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return -0x307ffefd8dc97200 }, Object.defineProperties(e, n), e }(ct)); const te = (function (t) { function e () { t.apply(this, arguments) }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.getSortIndex = function () { return ct.SORTINDEX_MULTIPOINT }, e.prototype.isValid = function () { return !0 }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n) } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.getCoordinate = function () { if (arguments.length === 1) { const e = arguments[0]; return this._geometries[e].getCoordinate() } return t.prototype.getCoordinate.apply(this, arguments) }, e.prototype.getBoundaryDimension = function () { return kt.FALSE }, e.prototype.getDimension = function () { return 0 }, e.prototype.getBoundary = function () { return this.getFactory().createGeometryCollection(null) }, e.prototype.getGeometryType = function () { return 'MultiPoint' }, e.prototype.copy = function () { for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)t[n] = this._geometries[n].copy(); return new e(t, this._factory) }, e.prototype.interfaces_ = function () { return [Zt] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return -0x6fb1ed4162e0fc00 }, Object.defineProperties(e, n), e }(zt)); const ee = (function (t) { function e (e, n) { e instanceof I && n instanceof ve && (e = n.getCoordinateSequenceFactory().create(e)), t.call(this, e, n), this.validateConstruction() }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { MINIMUM_VALID_SIZE: { configurable: !0 }, serialVersionUID: { configurable: !0 } }; return e.prototype.getSortIndex = function () { return ct.SORTINDEX_LINEARRING }, e.prototype.getBoundaryDimension = function () { return kt.FALSE }, e.prototype.isClosed = function () { return !!this.isEmpty() || t.prototype.isClosed.call(this) }, e.prototype.reverse = function () { const t = this._points.copy(); return Ht.reverse(t), this.getFactory().createLinearRing(t) }, e.prototype.validateConstruction = function () { if (!this.isEmpty() && !t.prototype.isClosed.call(this)) throw new _('Points of LinearRing do not form a closed linestring'); if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e.MINIMUM_VALID_SIZE) throw new _('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)') }, e.prototype.getGeometryType = function () { return 'LinearRing' }, e.prototype.copy = function () { return new e(this._points.copy(), this._factory) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, n.MINIMUM_VALID_SIZE.get = function () { return 4 }, n.serialVersionUID.get = function () { return -0x3b229e262367a600 }, Object.defineProperties(e, n), e }(Jt)); const ne = (function (t) { function e () { t.apply(this, arguments) }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { serialVersionUID: { configurable: !0 } }; return e.prototype.getSortIndex = function () { return ct.SORTINDEX_MULTIPOLYGON }, e.prototype.equalsExact = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return !!this.isEquivalentClass(e) && t.prototype.equalsExact.call(this, e, n) } return t.prototype.equalsExact.apply(this, arguments) }, e.prototype.getBoundaryDimension = function () { return 1 }, e.prototype.getDimension = function () { return 2 }, e.prototype.reverse = function () { for (var t = this._geometries.length, e = new Array(t).fill(null), n = 0; n < this._geometries.length; n++)e[n] = this._geometries[n].reverse(); return this.getFactory().createMultiPolygon(e) }, e.prototype.getBoundary = function () { if (this.isEmpty()) return this.getFactory().createMultiLineString(); for (var t = new wt(), e = 0; e < this._geometries.length; e++) for (let n = this._geometries[e].getBoundary(), r = 0; r < n.getNumGeometries(); r++)t.add(n.getGeometryN(r)); const i = new Array(t.size()).fill(null); return this.getFactory().createMultiLineString(t.toArray(i)) }, e.prototype.getGeometryType = function () { return 'MultiPolygon' }, e.prototype.copy = function () { for (var t = new Array(this._geometries.length).fill(null), n = 0; n < t.length; n++)t[n] = this._geometries[n].copy(); return new e(t, this._factory) }, e.prototype.interfaces_ = function () { return [Qt] }, e.prototype.getClass = function () { return e }, n.serialVersionUID.get = function () { return -0x7a5aa1369171980 }, Object.defineProperties(e, n), e }(zt)); const re = function (t) { this._factory = t || null, this._isUserDataCopied = !1 }; const ie = { NoOpGeometryOperation: { configurable: !0 }, CoordinateOperation: { configurable: !0 }, CoordinateSequenceOperation: { configurable: !0 } }; re.prototype.setCopyUserData = function (t) { this._isUserDataCopied = t }, re.prototype.edit = function (t, e) { if (t === null) return null; const n = this.editInternal(t, e); return this._isUserDataCopied && n.setUserData(t.getUserData()), n }, re.prototype.editInternal = function (t, e) { return this._factory === null && (this._factory = t.getFactory()), t instanceof zt ? this.editGeometryCollection(t, e) : t instanceof $t ? this.editPolygon(t, e) : t instanceof Kt || t instanceof Jt ? e.edit(t, this._factory) : (et.shouldNeverReachHere('Unsupported Geometry class: ' + t.getClass().getName()), null) }, re.prototype.editGeometryCollection = function (t, e) { for (var n = e.edit(t, this._factory), r = new wt(), i = 0; i < n.getNumGeometries(); i++) { const o = this.edit(n.getGeometryN(i), e); o === null || o.isEmpty() || r.add(o) } return n.getClass() === te ? this._factory.createMultiPoint(r.toArray([])) : n.getClass() === Ut ? this._factory.createMultiLineString(r.toArray([])) : n.getClass() === ne ? this._factory.createMultiPolygon(r.toArray([])) : this._factory.createGeometryCollection(r.toArray([])) }, re.prototype.editPolygon = function (t, e) { let n = e.edit(t, this._factory); if (n === null && (n = this._factory.createPolygon(null)), n.isEmpty()) return n; const r = this.edit(n.getExteriorRing(), e); if (r === null || r.isEmpty()) return this._factory.createPolygon(); for (var i = new wt(), o = 0; o < n.getNumInteriorRing(); o++) { const s = this.edit(n.getInteriorRingN(o), e); s === null || s.isEmpty() || i.add(s) } return this._factory.createPolygon(r, i.toArray([])) }, re.prototype.interfaces_ = function () { return [] }, re.prototype.getClass = function () { return re }, re.GeometryEditorOperation = function () {}, ie.NoOpGeometryOperation.get = function () { return oe }, ie.CoordinateOperation.get = function () { return se }, ie.CoordinateSequenceOperation.get = function () { return ae }, Object.defineProperties(re, ie); var oe = function () {}; oe.prototype.edit = function (t, e) { return t }, oe.prototype.interfaces_ = function () { return [re.GeometryEditorOperation] }, oe.prototype.getClass = function () { return oe }; var se = function () {}; se.prototype.edit = function (t, e) { const n = this.editCoordinates(t.getCoordinates(), t); return n === null ? t : t instanceof ee ? e.createLinearRing(n) : t instanceof Jt ? e.createLineString(n) : t instanceof Kt ? n.length > 0 ? e.createPoint(n[0]) : e.createPoint() : t }, se.prototype.interfaces_ = function () { return [re.GeometryEditorOperation] }, se.prototype.getClass = function () { return se }; var ae = function () {}; ae.prototype.edit = function (t, e) { return t instanceof ee ? e.createLinearRing(this.edit(t.getCoordinateSequence(), t)) : t instanceof Jt ? e.createLineString(this.edit(t.getCoordinateSequence(), t)) : t instanceof Kt ? e.createPoint(this.edit(t.getCoordinateSequence(), t)) : t }, ae.prototype.interfaces_ = function () { return [re.GeometryEditorOperation] }, ae.prototype.getClass = function () { return ae }; const ue = function () { if (this._dimension = 3, this._coordinates = null, arguments.length === 1) { if (arguments[0] instanceof Array) this._coordinates = arguments[0], this._dimension = 3; else if (Number.isInteger(arguments[0])) { const t = arguments[0]; this._coordinates = new Array(t).fill(null); for (let e = 0; e < t; e++) this._coordinates[e] = new I() } else if (O(arguments[0], q)) { const n = arguments[0]; if (n === null) return this._coordinates = new Array(0).fill(null), null; this._dimension = n.getDimension(), this._coordinates = new Array(n.size()).fill(null); for (let r = 0; r < this._coordinates.length; r++) this._coordinates[r] = n.getCoordinateCopy(r) } } else if (arguments.length === 2) if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) { const i = arguments[0]; const o = arguments[1]; this._coordinates = i, this._dimension = o, i === null && (this._coordinates = new Array(0).fill(null)) } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) { const s = arguments[0]; const a = arguments[1]; this._coordinates = new Array(s).fill(null), this._dimension = a; for (let u = 0; u < s; u++) this._coordinates[u] = new I() } }; const le = { serialVersionUID: { configurable: !0 } }; ue.prototype.setOrdinate = function (t, e, n) { switch (e) { case q.X:this._coordinates[t].x = n; break; case q.Y:this._coordinates[t].y = n; break; case q.Z:this._coordinates[t].z = n; break; default:throw new _('invalid ordinateIndex') } }, ue.prototype.size = function () { return this._coordinates.length }, ue.prototype.getOrdinate = function (t, e) { switch (e) { case q.X:return this._coordinates[t].x; case q.Y:return this._coordinates[t].y; case q.Z:return this._coordinates[t].z } return m.NaN }, ue.prototype.getCoordinate = function () { if (arguments.length === 1) { const t = arguments[0]; return this._coordinates[t] } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; n.x = this._coordinates[e].x, n.y = this._coordinates[e].y, n.z = this._coordinates[e].z } }, ue.prototype.getCoordinateCopy = function (t) { return new I(this._coordinates[t]) }, ue.prototype.getDimension = function () { return this._dimension }, ue.prototype.getX = function (t) { return this._coordinates[t].x }, ue.prototype.clone = function () { for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++)t[e] = this._coordinates[e].clone(); return new ue(t, this._dimension) }, ue.prototype.expandEnvelope = function (t) { for (let e = 0; e < this._coordinates.length; e++)t.expandToInclude(this._coordinates[e]); return t }, ue.prototype.copy = function () { for (var t = new Array(this.size()).fill(null), e = 0; e < this._coordinates.length; e++)t[e] = this._coordinates[e].copy(); return new ue(t, this._dimension) }, ue.prototype.toString = function () { if (this._coordinates.length > 0) { const t = new A(17 * this._coordinates.length); t.append('('), t.append(this._coordinates[0]); for (let e = 1; e < this._coordinates.length; e++)t.append(', '), t.append(this._coordinates[e]); return t.append(')'), t.toString() } return '()' }, ue.prototype.getY = function (t) { return this._coordinates[t].y }, ue.prototype.toCoordinateArray = function () { return this._coordinates }, ue.prototype.interfaces_ = function () { return [q, e] }, ue.prototype.getClass = function () { return ue }, le.serialVersionUID.get = function () { return -0xcb44a778db18e00 }, Object.defineProperties(ue, le); const ce = function () {}; const fe = { serialVersionUID: { configurable: !0 }, instanceObject: { configurable: !0 } }; ce.prototype.readResolve = function () { return ce.instance() }, ce.prototype.create = function () { if (arguments.length === 1) { if (arguments[0] instanceof Array) return new ue(arguments[0]); if (O(arguments[0], q)) return new ue(arguments[0]) } else if (arguments.length === 2) { const t = arguments[0]; let e = arguments[1]; return e > 3 && (e = 3), e < 2 ? new ue(t) : new ue(t, e) } }, ce.prototype.interfaces_ = function () { return [P, e] }, ce.prototype.getClass = function () { return ce }, ce.instance = function () { return ce.instanceObject }, fe.serialVersionUID.get = function () { return -0x38e49fa6cf6f2e00 }, fe.instanceObject.get = function () { return new ce() }, Object.defineProperties(ce, fe); const he = (function (t) { function e () { t.call(this), this.map_ = new Map() } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.get = function (t) { return this.map_.get(t) || null }, e.prototype.put = function (t, e) { return this.map_.set(t, e), e }, e.prototype.values = function () { for (var t = new wt(), e = this.map_.values(), n = e.next(); !n.done;)t.add(n.value), n = e.next(); return t }, e.prototype.entrySet = function () { const t = new Rt(); return this.map_.entries().forEach(function (e) { return t.add(e) }), t }, e.prototype.size = function () { return this.map_.size() }, e }(Ot)); const pe = function t () { if (this._modelType = null, this._scale = null, arguments.length === 0) this._modelType = t.FLOATING; else if (arguments.length === 1) if (arguments[0] instanceof de) { const e = arguments[0]; this._modelType = e, e === t.FIXED && this.setScale(1) } else if (typeof arguments[0] === 'number') { const n = arguments[0]; this._modelType = t.FIXED, this.setScale(n) } else if (arguments[0] instanceof t) { const r = arguments[0]; this._modelType = r._modelType, this._scale = r._scale } }; const ge = { serialVersionUID: { configurable: !0 }, maximumPreciseValue: { configurable: !0 } }; pe.prototype.equals = function (t) { if (!(t instanceof pe)) return !1; const e = t; return this._modelType === e._modelType && this._scale === e._scale }, pe.prototype.compareTo = function (t) { const e = t; const n = this.getMaximumSignificantDigits(); const r = e.getMaximumSignificantDigits(); return new T(n).compareTo(new T(r)) }, pe.prototype.getScale = function () { return this._scale }, pe.prototype.isFloating = function () { return this._modelType === pe.FLOATING || this._modelType === pe.FLOATING_SINGLE }, pe.prototype.getType = function () { return this._modelType }, pe.prototype.toString = function () { let t = 'UNKNOWN'; return this._modelType === pe.FLOATING ? t = 'Floating' : this._modelType === pe.FLOATING_SINGLE ? t = 'Floating-Single' : this._modelType === pe.FIXED && (t = 'Fixed (Scale=' + this.getScale() + ')'), t }, pe.prototype.makePrecise = function () { if (typeof arguments[0] === 'number') { const t = arguments[0]; return m.isNaN(t) || this._modelType === pe.FLOATING_SINGLE ? t : this._modelType === pe.FIXED ? Math.round(t * this._scale) / this._scale : t } if (arguments[0] instanceof I) { const e = arguments[0]; if (this._modelType === pe.FLOATING) return null; e.x = this.makePrecise(e.x), e.y = this.makePrecise(e.y) } }, pe.prototype.getMaximumSignificantDigits = function () { let t = 16; return this._modelType === pe.FLOATING ? t = 16 : this._modelType === pe.FLOATING_SINGLE ? t = 6 : this._modelType === pe.FIXED && (t = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t }, pe.prototype.setScale = function (t) { this._scale = Math.abs(t) }, pe.prototype.interfaces_ = function () { return [e, b] }, pe.prototype.getClass = function () { return pe }, pe.mostPrecise = function (t, e) { return t.compareTo(e) >= 0 ? t : e }, ge.serialVersionUID.get = function () { return 0x6bee6404e9a25c00 }, ge.maximumPreciseValue.get = function () { return 9007199254740992 }, Object.defineProperties(pe, ge); var de = function t (e) { this._name = e || null, t.nameToTypeMap.put(e, this) }; const ye = { serialVersionUID: { configurable: !0 }, nameToTypeMap: { configurable: !0 } }; de.prototype.readResolve = function () { return de.nameToTypeMap.get(this._name) }, de.prototype.toString = function () { return this._name }, de.prototype.interfaces_ = function () { return [e] }, de.prototype.getClass = function () { return de }, ye.serialVersionUID.get = function () { return -552860263173159e4 }, ye.nameToTypeMap.get = function () { return new he() }, Object.defineProperties(de, ye), pe.Type = de, pe.FIXED = new de('FIXED'), pe.FLOATING = new de('FLOATING'), pe.FLOATING_SINGLE = new de('FLOATING SINGLE'); var ve = function t () { this._precisionModel = new pe(), this._SRID = 0, this._coordinateSequenceFactory = t.getDefaultCoordinateSequenceFactory(), arguments.length === 0 || (arguments.length === 1 ? O(arguments[0], P) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof pe && (this._precisionModel = arguments[0]) : arguments.length === 2 ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : arguments.length === 3 && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2])) }; const _e = { serialVersionUID: { configurable: !0 } }; ve.prototype.toGeometry = function (t) { return t.isNull() ? this.createPoint(null) : t.getMinX() === t.getMaxX() && t.getMinY() === t.getMaxY() ? this.createPoint(new I(t.getMinX(), t.getMinY())) : t.getMinX() === t.getMaxX() || t.getMinY() === t.getMaxY() ? this.createLineString([new I(t.getMinX(), t.getMinY()), new I(t.getMaxX(), t.getMaxY())]) : this.createPolygon(this.createLinearRing([new I(t.getMinX(), t.getMinY()), new I(t.getMinX(), t.getMaxY()), new I(t.getMaxX(), t.getMaxY()), new I(t.getMaxX(), t.getMinY()), new I(t.getMinX(), t.getMinY())]), null) }, ve.prototype.createLineString = function (t) { return t ? t instanceof Array ? new Jt(this.getCoordinateSequenceFactory().create(t), this) : O(t, q) ? new Jt(t, this) : void 0 : new Jt(this.getCoordinateSequenceFactory().create([]), this) }, ve.prototype.createMultiLineString = function () { return arguments.length === 0 ? new Ut(null, this) : arguments.length === 1 ? new Ut(arguments[0], this) : void 0 }, ve.prototype.buildGeometry = function (t) { for (var e = null, n = !1, r = !1, i = t.iterator(); i.hasNext();) { const o = i.next(); const s = o.getClass(); e === null && (e = s), s !== e && (n = !0), o.isGeometryCollectionOrDerived() && (r = !0) } if (e === null) return this.createGeometryCollection(); if (n || r) return this.createGeometryCollection(ve.toGeometryArray(t)); const a = t.iterator().next(); if (t.size() > 1) { if (a instanceof $t) return this.createMultiPolygon(ve.toPolygonArray(t)); if (a instanceof Jt) return this.createMultiLineString(ve.toLineStringArray(t)); if (a instanceof Kt) return this.createMultiPoint(ve.toPointArray(t)); et.shouldNeverReachHere('Unhandled class: ' + a.getClass().getName()) } return a }, ve.prototype.createMultiPointFromCoords = function (t) { return this.createMultiPoint(t !== null ? this.getCoordinateSequenceFactory().create(t) : null) }, ve.prototype.createPoint = function () { if (arguments.length === 0) return this.createPoint(this.getCoordinateSequenceFactory().create([])); if (arguments.length === 1) { if (arguments[0] instanceof I) { const t = arguments[0]; return this.createPoint(t !== null ? this.getCoordinateSequenceFactory().create([t]) : null) } if (O(arguments[0], q)) return new Kt(arguments[0], this) } }, ve.prototype.getCoordinateSequenceFactory = function () { return this._coordinateSequenceFactory }, ve.prototype.createPolygon = function () { if (arguments.length === 0) return new $t(null, null, this); if (arguments.length === 1) { if (O(arguments[0], q)) { const t = arguments[0]; return this.createPolygon(this.createLinearRing(t)) } if (arguments[0] instanceof Array) { const e = arguments[0]; return this.createPolygon(this.createLinearRing(e)) } if (arguments[0] instanceof ee) { const n = arguments[0]; return this.createPolygon(n, null) } } else if (arguments.length === 2) return new $t(arguments[0], arguments[1], this) }, ve.prototype.getSRID = function () { return this._SRID }, ve.prototype.createGeometryCollection = function () { return arguments.length === 0 ? new zt(null, this) : arguments.length === 1 ? new zt(arguments[0], this) : void 0 }, ve.prototype.createGeometry = function (t) { return new re(this).edit(t, { edit: function () { if (arguments.length === 2) { const t = arguments[0]; return this._coordinateSequenceFactory.create(t) } } }) }, ve.prototype.getPrecisionModel = function () { return this._precisionModel }, ve.prototype.createLinearRing = function () { if (arguments.length === 0) return this.createLinearRing(this.getCoordinateSequenceFactory().create([])); if (arguments.length === 1) { if (arguments[0] instanceof Array) { const t = arguments[0]; return this.createLinearRing(t !== null ? this.getCoordinateSequenceFactory().create(t) : null) } if (O(arguments[0], q)) return new ee(arguments[0], this) } }, ve.prototype.createMultiPolygon = function () { return arguments.length === 0 ? new ne(null, this) : arguments.length === 1 ? new ne(arguments[0], this) : void 0 }, ve.prototype.createMultiPoint = function () { if (arguments.length === 0) return new te(null, this); if (arguments.length === 1) { if (arguments[0] instanceof Array) return new te(arguments[0], this); if (arguments[0] instanceof Array) { const t = arguments[0]; return this.createMultiPoint(t !== null ? this.getCoordinateSequenceFactory().create(t) : null) } if (O(arguments[0], q)) { const e = arguments[0]; if (e === null) return this.createMultiPoint(new Array(0).fill(null)); for (var n = new Array(e.size()).fill(null), r = 0; r < e.size(); r++) { const i = this.getCoordinateSequenceFactory().create(1, e.getDimension()); Ht.copy(e, r, i, 0, 1), n[r] = this.createPoint(i) } return this.createMultiPoint(n) } } }, ve.prototype.interfaces_ = function () { return [e] }, ve.prototype.getClass = function () { return ve }, ve.toMultiPolygonArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.toGeometryArray = function (t) { if (t === null) return null; const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.getDefaultCoordinateSequenceFactory = function () { return ce.instance() }, ve.toMultiLineStringArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.toLineStringArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.toMultiPointArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.toLinearRingArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.toPointArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.toPolygonArray = function (t) { const e = new Array(t.size()).fill(null); return t.toArray(e) }, ve.createPointFromInternalCoord = function (t, e) { return e.getPrecisionModel().makePrecise(t), e.getFactory().createPoint(t) }, _e.serialVersionUID.get = function () { return -0x5ea75f2051eeb400 }, Object.defineProperties(ve, _e); const me = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon']; const xe = function (t) { this.geometryFactory = t || new ve() }; xe.prototype.read = function (t) { let e; const n = (e = typeof t === 'string' ? JSON.parse(t) : t).type; if (!be[n]) throw new Error('Unknown GeoJSON type: ' + e.type); return me.indexOf(n) !== -1 ? be[n].apply(this, [e.coordinates]) : n === 'GeometryCollection' ? be[n].apply(this, [e.geometries]) : be[n].apply(this, [e]) }, xe.prototype.write = function (t) { const e = t.getGeometryType(); if (!Ee[e]) throw new Error('Geometry is not supported'); return Ee[e].apply(this, [t]) }; var be = { Feature: function (t) { const e = {}; for (const n in t)e[n] = t[n]; if (t.geometry) { const r = t.geometry.type; if (!be[r]) throw new Error('Unknown GeoJSON type: ' + t.type); e.geometry = this.read(t.geometry) } return t.bbox && (e.bbox = be.bbox.apply(this, [t.bbox])), e }, FeatureCollection: function (t) { const e = {}; if (t.features) { e.features = []; for (let n = 0; n < t.features.length; ++n)e.features.push(this.read(t.features[n])) } return t.bbox && (e.bbox = this.parse.bbox.apply(this, [t.bbox])), e }, coordinates: function (t) { for (var e = [], n = 0; n < t.length; ++n) { const r = t[n]; e.push(new I(r[0], r[1])) } return e }, bbox: function (t) { return this.geometryFactory.createLinearRing([new I(t[0], t[1]), new I(t[2], t[1]), new I(t[2], t[3]), new I(t[0], t[3]), new I(t[0], t[1])]) }, Point: function (t) { const e = new I(t[0], t[1]); return this.geometryFactory.createPoint(e) }, MultiPoint: function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(be.Point.apply(this, [t[n]])); return this.geometryFactory.createMultiPoint(e) }, LineString: function (t) { const e = be.coordinates.apply(this, [t]); return this.geometryFactory.createLineString(e) }, MultiLineString: function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(be.LineString.apply(this, [t[n]])); return this.geometryFactory.createMultiLineString(e) }, Polygon: function (t) { for (var e = be.coordinates.apply(this, [t[0]]), n = this.geometryFactory.createLinearRing(e), r = [], i = 1; i < t.length; ++i) { const o = t[i]; const s = be.coordinates.apply(this, [o]); const a = this.geometryFactory.createLinearRing(s); r.push(a) } return this.geometryFactory.createPolygon(n, r) }, MultiPolygon: function (t) { for (var e = [], n = 0; n < t.length; ++n) { const r = t[n]; e.push(be.Polygon.apply(this, [r])) } return this.geometryFactory.createMultiPolygon(e) }, GeometryCollection: function (t) { for (var e = [], n = 0; n < t.length; ++n) { const r = t[n]; e.push(this.read(r)) } return this.geometryFactory.createGeometryCollection(e) } }; var Ee = { coordinate: function (t) { return [t.x, t.y] }, Point: function (t) { return { type: 'Point', coordinates: Ee.coordinate.apply(this, [t.getCoordinate()]) } }, MultiPoint: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { const r = t._geometries[n]; const i = Ee.Point.apply(this, [r]); e.push(i.coordinates) } return { type: 'MultiPoint', coordinates: e } }, LineString: function (t) { for (var e = [], n = t.getCoordinates(), r = 0; r < n.length; ++r) { const i = n[r]; e.push(Ee.coordinate.apply(this, [i])) } return { type: 'LineString', coordinates: e } }, MultiLineString: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { const r = t._geometries[n]; const i = Ee.LineString.apply(this, [r]); e.push(i.coordinates) } return { type: 'MultiLineString', coordinates: e } }, Polygon: function (t) { const e = []; const n = Ee.LineString.apply(this, [t._shell]); e.push(n.coordinates); for (let r = 0; r < t._holes.length; ++r) { const i = t._holes[r]; const o = Ee.LineString.apply(this, [i]); e.push(o.coordinates) } return { type: 'Polygon', coordinates: e } }, MultiPolygon: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { const r = t._geometries[n]; const i = Ee.Polygon.apply(this, [r]); e.push(i.coordinates) } return { type: 'MultiPolygon', coordinates: e } }, GeometryCollection: function (t) { for (var e = [], n = 0; n < t._geometries.length; ++n) { const r = t._geometries[n]; const i = r.getGeometryType(); e.push(Ee[i].apply(this, [r])) } return { type: 'GeometryCollection', geometries: e } } }; const we = function (t) { this.geometryFactory = t || new ve(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new xe(this.geometryFactory) }; we.prototype.read = function (t) { const e = this.parser.read(t); return this.precisionModel.getType() === pe.FIXED && this.reducePrecision(e), e }, we.prototype.reducePrecision = function (t) { let e, n; if (t.coordinate) this.precisionModel.makePrecise(t.coordinate); else if (t.points) for (e = 0, n = t.points.length; e < n; e++) this.precisionModel.makePrecise(t.points[e]); else if (t.geometries) for (e = 0, n = t.geometries.length; e < n; e++) this.reducePrecision(t.geometries[e]) }; const Ie = function () { this.parser = new xe(this.geometryFactory) }; Ie.prototype.write = function (t) { return this.parser.write(t) }; const Se = function () {}; const Ne = { ON: { configurable: !0 }, LEFT: { configurable: !0 }, RIGHT: { configurable: !0 } }; Se.prototype.interfaces_ = function () { return [] }, Se.prototype.getClass = function () { return Se }, Se.opposite = function (t) { return t === Se.LEFT ? Se.RIGHT : t === Se.RIGHT ? Se.LEFT : t }, Ne.ON.get = function () { return 0 }, Ne.LEFT.get = function () { return 1 }, Ne.RIGHT.get = function () { return 2 }, Object.defineProperties(Se, Ne), (d.prototype = new Error()).name = 'EmptyStackException', (y.prototype = new Et()).add = function (t) { return this.array_.push(t), !0 }, y.prototype.get = function (t) { if (t < 0 || t >= this.size()) throw new Error(); return this.array_[t] }, y.prototype.push = function (t) { return this.array_.push(t), t }, y.prototype.pop = function (t) { if (this.array_.length === 0) throw new d(); return this.array_.pop() }, y.prototype.peek = function () { if (this.array_.length === 0) throw new d(); return this.array_[this.array_.length - 1] }, y.prototype.empty = function () { return this.array_.length === 0 }, y.prototype.isEmpty = function () { return this.empty() }, y.prototype.search = function (t) { return this.array_.indexOf(t) }, y.prototype.size = function () { return this.array_.length }, y.prototype.toArray = function () { for (var t = [], e = 0, n = this.array_.length; e < n; e++)t.push(this.array_[e]); return t }; const Pe = function () { this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null }; Pe.prototype.getCoordinate = function () { return this._minCoord }, Pe.prototype.getRightmostSide = function (t, e) { let n = this.getRightmostSideOfSegment(t, e); return n < 0 && (n = this.getRightmostSideOfSegment(t, e - 1)), n < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t)), n }, Pe.prototype.findRightmostEdgeAtVertex = function () { const t = this._minDe.getEdge().getCoordinates(); et.isTrue(this._minIndex > 0 && this._minIndex < t.length, 'rightmost point expected to be interior vertex of edge'); const e = t[this._minIndex - 1]; const n = t[this._minIndex + 1]; const r = at.computeOrientation(this._minCoord, n, e); let i = !1; (e.y < this._minCoord.y && n.y < this._minCoord.y && r === at.COUNTERCLOCKWISE || e.y > this._minCoord.y && n.y > this._minCoord.y && r === at.CLOCKWISE) && (i = !0), i && (this._minIndex = this._minIndex - 1) }, Pe.prototype.getRightmostSideOfSegment = function (t, e) { const n = t.getEdge().getCoordinates(); if (e < 0 || e + 1 >= n.length) return -1; if (n[e].y === n[e + 1].y) return -1; let r = Se.LEFT; return n[e].y < n[e + 1].y && (r = Se.RIGHT), r }, Pe.prototype.getEdge = function () { return this._orientedDe }, Pe.prototype.checkForRightmostCoordinate = function (t) { for (let e = t.getEdge().getCoordinates(), n = 0; n < e.length - 1; n++)(this._minCoord === null || e[n].x > this._minCoord.x) && (this._minDe = t, this._minIndex = n, this._minCoord = e[n]) }, Pe.prototype.findRightmostEdgeAtNode = function () { const t = this._minDe.getNode().getEdges(); this._minDe = t.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1) }, Pe.prototype.findEdge = function (t) { for (let e = t.iterator(); e.hasNext();) { const n = e.next(); n.isForward() && this.checkForRightmostCoordinate(n) }et.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing'), this._minIndex === 0 ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe, this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym()) }, Pe.prototype.interfaces_ = function () { return [] }, Pe.prototype.getClass = function () { return Pe }; const Ce = (function (t) { function e (n, r) { t.call(this, e.msgWithCoord(n, r)), this.pt = r ? new I(r) : null, this.name = 'TopologyException' } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getCoordinate = function () { return this.pt }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e.msgWithCoord = function (t, e) { return e ? t : t + ' [ ' + e + ' ]' }, e }($)); const Me = function () { this.array_ = [] }; Me.prototype.addLast = function (t) { this.array_.push(t) }, Me.prototype.removeFirst = function () { return this.array_.shift() }, Me.prototype.isEmpty = function () { return this.array_.length === 0 }; const Oe = function () { this._finder = null, this._dirEdgeList = new wt(), this._nodes = new wt(), this._rightMostCoord = null, this._env = null, this._finder = new Pe() }; Oe.prototype.clearVisitedEdges = function () { for (let t = this._dirEdgeList.iterator(); t.hasNext();)t.next().setVisited(!1) }, Oe.prototype.getRightmostCoordinate = function () { return this._rightMostCoord }, Oe.prototype.computeNodeDepth = function (t) { for (var e = null, n = t.getEdges().iterator(); n.hasNext();) { const r = n.next(); if (r.isVisited() || r.getSym().isVisited()) { e = r; break } } if (e === null) throw new Ce('unable to find edge to compute depths at ' + t.getCoordinate()); t.getEdges().computeDepths(e); for (let i = t.getEdges().iterator(); i.hasNext();) { const o = i.next(); o.setVisited(!0), this.copySymDepths(o) } }, Oe.prototype.computeDepth = function (t) { this.clearVisitedEdges(); const e = this._finder.getEdge(); e.setEdgeDepths(Se.RIGHT, t), this.copySymDepths(e), this.computeDepths(e) }, Oe.prototype.create = function (t) { this.addReachable(t), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate() }, Oe.prototype.findResultEdges = function () { for (let t = this._dirEdgeList.iterator(); t.hasNext();) { const e = t.next(); e.getDepth(Se.RIGHT) >= 1 && e.getDepth(Se.LEFT) <= 0 && !e.isInteriorAreaEdge() && e.setInResult(!0) } }, Oe.prototype.computeDepths = function (t) { const e = new Rt(); const n = new Me(); const r = t.getNode(); for (n.addLast(r), e.add(r), t.setVisited(!0); !n.isEmpty();) { const i = n.removeFirst(); e.add(i), this.computeNodeDepth(i); for (let o = i.getEdges().iterator(); o.hasNext();) { const s = o.next().getSym(); if (!s.isVisited()) { const a = s.getNode(); e.contains(a) || (n.addLast(a), e.add(a)) } } } }, Oe.prototype.compareTo = function (t) { const e = t; return this._rightMostCoord.x < e._rightMostCoord.x ? -1 : this._rightMostCoord.x > e._rightMostCoord.x ? 1 : 0 }, Oe.prototype.getEnvelope = function () { if (this._env === null) { for (var t = new V(), e = this._dirEdgeList.iterator(); e.hasNext();) for (let n = e.next().getEdge().getCoordinates(), r = 0; r < n.length - 1; r++)t.expandToInclude(n[r]); this._env = t } return this._env }, Oe.prototype.addReachable = function (t) { const e = new y(); for (e.add(t); !e.empty();) { const n = e.pop(); this.add(n, e) } }, Oe.prototype.copySymDepths = function (t) { const e = t.getSym(); e.setDepth(Se.LEFT, t.getDepth(Se.RIGHT)), e.setDepth(Se.RIGHT, t.getDepth(Se.LEFT)) }, Oe.prototype.add = function (t, e) { t.setVisited(!0), this._nodes.add(t); for (let n = t.getEdges().iterator(); n.hasNext();) { const r = n.next(); this._dirEdgeList.add(r); const i = r.getSym().getNode(); i.isVisited() || e.push(i) } }, Oe.prototype.getNodes = function () { return this._nodes }, Oe.prototype.getDirectedEdges = function () { return this._dirEdgeList }, Oe.prototype.interfaces_ = function () { return [b] }, Oe.prototype.getClass = function () { return Oe }; const Le = function t () { if (this.location = null, arguments.length === 1) { if (arguments[0] instanceof Array) { const e = arguments[0]; this.init(e.length) } else if (Number.isInteger(arguments[0])) { const n = arguments[0]; this.init(1), this.location[Se.ON] = n } else if (arguments[0] instanceof t) { const r = arguments[0]; if (this.init(r.location.length), r !== null) for (let i = 0; i < this.location.length; i++) this.location[i] = r.location[i] } } else if (arguments.length === 3) { const o = arguments[0]; const s = arguments[1]; const a = arguments[2]; this.init(3), this.location[Se.ON] = o, this.location[Se.LEFT] = s, this.location[Se.RIGHT] = a } }; Le.prototype.setAllLocations = function (t) { for (let e = 0; e < this.location.length; e++) this.location[e] = t }, Le.prototype.isNull = function () { for (let t = 0; t < this.location.length; t++) if (this.location[t] !== C.NONE) return !1; return !0 }, Le.prototype.setAllLocationsIfNull = function (t) { for (let e = 0; e < this.location.length; e++) this.location[e] === C.NONE && (this.location[e] = t) }, Le.prototype.isLine = function () { return this.location.length === 1 }, Le.prototype.merge = function (t) { if (t.location.length > this.location.length) { const e = new Array(3).fill(null); e[Se.ON] = this.location[Se.ON], e[Se.LEFT] = C.NONE, e[Se.RIGHT] = C.NONE, this.location = e } for (let n = 0; n < this.location.length; n++) this.location[n] === C.NONE && n < t.location.length && (this.location[n] = t.location[n]) }, Le.prototype.getLocations = function () { return this.location }, Le.prototype.flip = function () { if (this.location.length <= 1) return null; const t = this.location[Se.LEFT]; this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t }, Le.prototype.toString = function () { const t = new A(); return this.location.length > 1 && t.append(C.toLocationSymbol(this.location[Se.LEFT])), t.append(C.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t.append(C.toLocationSymbol(this.location[Se.RIGHT])), t.toString() }, Le.prototype.setLocations = function (t, e, n) { this.location[Se.ON] = t, this.location[Se.LEFT] = e, this.location[Se.RIGHT] = n }, Le.prototype.get = function (t) { return t < this.location.length ? this.location[t] : C.NONE }, Le.prototype.isArea = function () { return this.location.length > 1 }, Le.prototype.isAnyNull = function () { for (let t = 0; t < this.location.length; t++) if (this.location[t] === C.NONE) return !0; return !1 }, Le.prototype.setLocation = function () { if (arguments.length === 1) { const t = arguments[0]; this.setLocation(Se.ON, t) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; this.location[e] = n } }, Le.prototype.init = function (t) { this.location = new Array(t).fill(null), this.setAllLocations(C.NONE) }, Le.prototype.isEqualOnSide = function (t, e) { return this.location[e] === t.location[e] }, Le.prototype.allPositionsEqual = function (t) { for (let e = 0; e < this.location.length; e++) if (this.location[e] !== t) return !1; return !0 }, Le.prototype.interfaces_ = function () { return [] }, Le.prototype.getClass = function () { return Le }; const Re = function t () { if (this.elt = new Array(2).fill(null), arguments.length === 1) { if (Number.isInteger(arguments[0])) { const e = arguments[0]; this.elt[0] = new Le(e), this.elt[1] = new Le(e) } else if (arguments[0] instanceof t) { const n = arguments[0]; this.elt[0] = new Le(n.elt[0]), this.elt[1] = new Le(n.elt[1]) } } else if (arguments.length === 2) { const r = arguments[0]; const i = arguments[1]; this.elt[0] = new Le(C.NONE), this.elt[1] = new Le(C.NONE), this.elt[r].setLocation(i) } else if (arguments.length === 3) { const o = arguments[0]; const s = arguments[1]; const a = arguments[2]; this.elt[0] = new Le(o, s, a), this.elt[1] = new Le(o, s, a) } else if (arguments.length === 4) { const u = arguments[0]; const l = arguments[1]; const c = arguments[2]; const f = arguments[3]; this.elt[0] = new Le(C.NONE, C.NONE, C.NONE), this.elt[1] = new Le(C.NONE, C.NONE, C.NONE), this.elt[u].setLocations(l, c, f) } }; Re.prototype.getGeometryCount = function () { let t = 0; return this.elt[0].isNull() || t++, this.elt[1].isNull() || t++, t }, Re.prototype.setAllLocations = function (t, e) { this.elt[t].setAllLocations(e) }, Re.prototype.isNull = function (t) { return this.elt[t].isNull() }, Re.prototype.setAllLocationsIfNull = function () { if (arguments.length === 1) { const t = arguments[0]; this.setAllLocationsIfNull(0, t), this.setAllLocationsIfNull(1, t) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; this.elt[e].setAllLocationsIfNull(n) } }, Re.prototype.isLine = function (t) { return this.elt[t].isLine() }, Re.prototype.merge = function (t) { for (let e = 0; e < 2; e++) this.elt[e] === null && t.elt[e] !== null ? this.elt[e] = new Le(t.elt[e]) : this.elt[e].merge(t.elt[e]) }, Re.prototype.flip = function () { this.elt[0].flip(), this.elt[1].flip() }, Re.prototype.getLocation = function () { if (arguments.length === 1) { const t = arguments[0]; return this.elt[t].get(Se.ON) } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return this.elt[e].get(n) } }, Re.prototype.toString = function () { const t = new A(); return this.elt[0] !== null && (t.append('A:'), t.append(this.elt[0].toString())), this.elt[1] !== null && (t.append(' B:'), t.append(this.elt[1].toString())), t.toString() }, Re.prototype.isArea = function () { if (arguments.length === 0) return this.elt[0].isArea() || this.elt[1].isArea(); if (arguments.length === 1) { const t = arguments[0]; return this.elt[t].isArea() } }, Re.prototype.isAnyNull = function (t) { return this.elt[t].isAnyNull() }, Re.prototype.setLocation = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; this.elt[t].setLocation(Se.ON, e) } else if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; this.elt[n].setLocation(r, i) } }, Re.prototype.isEqualOnSide = function (t, e) { return this.elt[0].isEqualOnSide(t.elt[0], e) && this.elt[1].isEqualOnSide(t.elt[1], e) }, Re.prototype.allPositionsEqual = function (t, e) { return this.elt[t].allPositionsEqual(e) }, Re.prototype.toLine = function (t) { this.elt[t].isArea() && (this.elt[t] = new Le(this.elt[t].location[0])) }, Re.prototype.interfaces_ = function () { return [] }, Re.prototype.getClass = function () { return Re }, Re.toLineLabel = function (t) { for (var e = new Re(C.NONE), n = 0; n < 2; n++)e.setLocation(n, t.getLocation(n)); return e }; const Ae = function () { this._startDe = null, this._maxNodeDegree = -1, this._edges = new wt(), this._pts = new wt(), this._label = new Re(C.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new wt(), this._geometryFactory = null; const t = arguments[0]; const e = arguments[1]; this._geometryFactory = e, this.computePoints(t), this.computeRing() }; Ae.prototype.computeRing = function () { if (this._ring !== null) return null; for (var t = new Array(this._pts.size()).fill(null), e = 0; e < this._pts.size(); e++)t[e] = this._pts.get(e); this._ring = this._geometryFactory.createLinearRing(t), this._isHole = at.isCCW(this._ring.getCoordinates()) }, Ae.prototype.isIsolated = function () { return this._label.getGeometryCount() === 1 }, Ae.prototype.computePoints = function (t) { this._startDe = t; let e = t; let n = !0; do { if (e === null) throw new Ce('Found null DirectedEdge'); if (e.getEdgeRing() === this) throw new Ce('Directed Edge visited twice during ring-building at ' + e.getCoordinate()); this._edges.add(e); const r = e.getLabel(); et.isTrue(r.isArea()), this.mergeLabel(r), this.addPoints(e.getEdge(), e.isForward(), n), n = !1, this.setEdgeRing(e, this), e = this.getNext(e) } while (e !== this._startDe) }, Ae.prototype.getLinearRing = function () { return this._ring }, Ae.prototype.getCoordinate = function (t) { return this._pts.get(t) }, Ae.prototype.computeMaxNodeDegree = function () { this._maxNodeDegree = 0; let t = this._startDe; do { const e = t.getNode().getEdges().getOutgoingDegree(this); e > this._maxNodeDegree && (this._maxNodeDegree = e), t = this.getNext(t) } while (t !== this._startDe); this._maxNodeDegree *= 2 }, Ae.prototype.addPoints = function (t, e, n) { const r = t.getCoordinates(); if (e) { let i = 1; n && (i = 0); for (let o = i; o < r.length; o++) this._pts.add(r[o]) } else { let s = r.length - 2; n && (s = r.length - 1); for (let a = s; a >= 0; a--) this._pts.add(r[a]) } }, Ae.prototype.isHole = function () { return this._isHole }, Ae.prototype.setInResult = function () { let t = this._startDe; do { t.getEdge().setInResult(!0), t = t.getNext() } while (t !== this._startDe) }, Ae.prototype.containsPoint = function (t) { const e = this.getLinearRing(); if (!e.getEnvelopeInternal().contains(t)) return !1; if (!at.isPointInRing(t, e.getCoordinates())) return !1; for (let n = this._holes.iterator(); n.hasNext();) if (n.next().containsPoint(t)) return !1; return !0 }, Ae.prototype.addHole = function (t) { this._holes.add(t) }, Ae.prototype.isShell = function () { return this._shell === null }, Ae.prototype.getLabel = function () { return this._label }, Ae.prototype.getEdges = function () { return this._edges }, Ae.prototype.getMaxNodeDegree = function () { return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree }, Ae.prototype.getShell = function () { return this._shell }, Ae.prototype.mergeLabel = function () { if (arguments.length === 1) { const t = arguments[0]; this.mergeLabel(t, 0), this.mergeLabel(t, 1) } else if (arguments.length === 2) { const e = arguments[1]; const n = arguments[0].getLocation(e, Se.RIGHT); if (n === C.NONE) return null; if (this._label.getLocation(e) === C.NONE) return this._label.setLocation(e, n), null } }, Ae.prototype.setShell = function (t) { this._shell = t, t !== null && t.addHole(this) }, Ae.prototype.toPolygon = function (t) { for (var e = new Array(this._holes.size()).fill(null), n = 0; n < this._holes.size(); n++)e[n] = this._holes.get(n).getLinearRing(); return t.createPolygon(this.getLinearRing(), e) }, Ae.prototype.interfaces_ = function () { return [] }, Ae.prototype.getClass = function () { return Ae }; const Te = (function (t) { function e () { const e = arguments[0]; const n = arguments[1]; t.call(this, e, n) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.setEdgeRing = function (t, e) { t.setMinEdgeRing(e) }, e.prototype.getNext = function (t) { return t.getNextMin() }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Ae)); const De = (function (t) { function e () { const e = arguments[0]; const n = arguments[1]; t.call(this, e, n) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildMinimalRings = function () { const t = new wt(); let e = this._startDe; do { if (e.getMinEdgeRing() === null) { const n = new Te(e, this._geometryFactory); t.add(n) }e = e.getNext() } while (e !== this._startDe); return t }, e.prototype.setEdgeRing = function (t, e) { t.setEdgeRing(e) }, e.prototype.linkDirectedEdgesForMinimalEdgeRings = function () { let t = this._startDe; do { t.getNode().getEdges().linkMinimalDirectedEdges(this), t = t.getNext() } while (t !== this._startDe) }, e.prototype.getNext = function (t) { return t.getNext() }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Ae)); const Fe = function () { if (this._label = null, this._isInResult = !1, this._isCovered = !1, this._isCoveredSet = !1, this._isVisited = !1, arguments.length === 0);else if (arguments.length === 1) { const t = arguments[0]; this._label = t } }; Fe.prototype.setVisited = function (t) { this._isVisited = t }, Fe.prototype.setInResult = function (t) { this._isInResult = t }, Fe.prototype.isCovered = function () { return this._isCovered }, Fe.prototype.isCoveredSet = function () { return this._isCoveredSet }, Fe.prototype.setLabel = function (t) { this._label = t }, Fe.prototype.getLabel = function () { return this._label }, Fe.prototype.setCovered = function (t) { this._isCovered = t, this._isCoveredSet = !0 }, Fe.prototype.updateIM = function (t) { et.isTrue(this._label.getGeometryCount() >= 2, 'found partial label'), this.computeIM(t) }, Fe.prototype.isInResult = function () { return this._isInResult }, Fe.prototype.isVisited = function () { return this._isVisited }, Fe.prototype.interfaces_ = function () { return [] }, Fe.prototype.getClass = function () { return Fe }; const je = (function (t) { function e () { t.call(this), this._coord = null, this._edges = null; const e = arguments[0]; const n = arguments[1]; this._coord = e, this._edges = n, this._label = new Re(0, C.NONE) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isIncidentEdgeInResult = function () { for (let t = this.getEdges().getEdges().iterator(); t.hasNext();) if (t.next().getEdge().isInResult()) return !0; return !1 }, e.prototype.isIsolated = function () { return this._label.getGeometryCount() === 1 }, e.prototype.getCoordinate = function () { return this._coord }, e.prototype.print = function (t) { t.println('node ' + this._coord + ' lbl: ' + this._label) }, e.prototype.computeIM = function (t) {}, e.prototype.computeMergedLocation = function (t, e) { let n = C.NONE; if (n = this._label.getLocation(e), !t.isNull(e)) { const r = t.getLocation(e); n !== C.BOUNDARY && (n = r) } return n }, e.prototype.setLabel = function () { if (arguments.length !== 2) return t.prototype.setLabel.apply(this, arguments); const e = arguments[0]; const n = arguments[1]; this._label === null ? this._label = new Re(e, n) : this._label.setLocation(e, n) }, e.prototype.getEdges = function () { return this._edges }, e.prototype.mergeLabel = function () { if (arguments[0] instanceof e) { const t = arguments[0]; this.mergeLabel(t._label) } else if (arguments[0] instanceof Re) for (let n = arguments[0], r = 0; r < 2; r++) { const i = this.computeMergedLocation(n, r); this._label.getLocation(r) === C.NONE && this._label.setLocation(r, i) } }, e.prototype.add = function (t) { this._edges.insert(t), t.setNode(this) }, e.prototype.setLabelBoundary = function (t) { if (this._label === null) return null; let e = C.NONE; this._label !== null && (e = this._label.getLocation(t)); let n = null; if (e === C.BOUNDARY)n = C.INTERIOR; else n = C.BOUNDARY; this._label.setLocation(t, n) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Fe)); const ke = function () { this.nodeMap = new f(), this.nodeFact = null; const t = arguments[0]; this.nodeFact = t }; ke.prototype.find = function (t) { return this.nodeMap.get(t) }, ke.prototype.addNode = function () { if (arguments[0] instanceof I) { const t = arguments[0]; let e = this.nodeMap.get(t); return e === null && (e = this.nodeFact.createNode(t), this.nodeMap.put(t, e)), e } if (arguments[0] instanceof je) { const n = arguments[0]; const r = this.nodeMap.get(n.getCoordinate()); return r === null ? (this.nodeMap.put(n.getCoordinate(), n), n) : (r.mergeLabel(n), r) } }, ke.prototype.print = function (t) { for (let e = this.iterator(); e.hasNext();)e.next().print(t) }, ke.prototype.iterator = function () { return this.nodeMap.values().iterator() }, ke.prototype.values = function () { return this.nodeMap.values() }, ke.prototype.getBoundaryNodes = function (t) { for (var e = new wt(), n = this.iterator(); n.hasNext();) { const r = n.next(); r.getLabel().getLocation(t) === C.BOUNDARY && e.add(r) } return e }, ke.prototype.add = function (t) { const e = t.getCoordinate(); this.addNode(e).add(t) }, ke.prototype.interfaces_ = function () { return [] }, ke.prototype.getClass = function () { return ke }; const Ge = function () {}; const qe = { NE: { configurable: !0 }, NW: { configurable: !0 }, SW: { configurable: !0 }, SE: { configurable: !0 } }; Ge.prototype.interfaces_ = function () { return [] }, Ge.prototype.getClass = function () { return Ge }, Ge.isNorthern = function (t) { return t === Ge.NE || t === Ge.NW }, Ge.isOpposite = function (t, e) { return t !== e && (t - e + 4) % 4 == 2 }, Ge.commonHalfPlane = function (t, e) { if (t === e) return t; if ((t - e + 4) % 4 == 2) return -1; const n = t < e ? t : e; return n === 0 && (t > e ? t : e) === 3 ? 3 : n }, Ge.isInHalfPlane = function (t, e) { return e === Ge.SE ? t === Ge.SE || t === Ge.SW : t === e || t === e + 1 }, Ge.quadrant = function () { if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') { const t = arguments[0]; const e = arguments[1]; if (t === 0 && e === 0) throw new _('Cannot compute the quadrant for point ( ' + t + ', ' + e + ' )'); return t >= 0 ? e >= 0 ? Ge.NE : Ge.SE : e >= 0 ? Ge.NW : Ge.SW } if (arguments[0] instanceof I && arguments[1] instanceof I) { const n = arguments[0]; const r = arguments[1]; if (r.x === n.x && r.y === n.y) throw new _('Cannot compute the quadrant for two identical points ' + n); return r.x >= n.x ? r.y >= n.y ? Ge.NE : Ge.SE : r.y >= n.y ? Ge.NW : Ge.SW } }, qe.NE.get = function () { return 0 }, qe.NW.get = function () { return 1 }, qe.SW.get = function () { return 2 }, qe.SE.get = function () { return 3 }, Object.defineProperties(Ge, qe); const Be = function () { if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, arguments.length === 1) { const t = arguments[0]; this._edge = t } else if (arguments.length === 3) { const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; this._edge = e, this.init(n, r), this._label = null } else if (arguments.length === 4) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; const a = arguments[3]; this._edge = i, this.init(o, s), this._label = a } }; Be.prototype.compareDirection = function (t) { return this._dx === t._dx && this._dy === t._dy ? 0 : this._quadrant > t._quadrant ? 1 : this._quadrant < t._quadrant ? -1 : at.computeOrientation(t._p0, t._p1, this._p1) }, Be.prototype.getDy = function () { return this._dy }, Be.prototype.getCoordinate = function () { return this._p0 }, Be.prototype.setNode = function (t) { this._node = t }, Be.prototype.print = function (t) { const e = Math.atan2(this._dy, this._dx); const n = this.getClass().getName(); const r = n.lastIndexOf('.'); const i = n.substring(r + 1); t.print('  ' + i + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + e + '   ' + this._label) }, Be.prototype.compareTo = function (t) { const e = t; return this.compareDirection(e) }, Be.prototype.getDirectedCoordinate = function () { return this._p1 }, Be.prototype.getDx = function () { return this._dx }, Be.prototype.getLabel = function () { return this._label }, Be.prototype.getEdge = function () { return this._edge }, Be.prototype.getQuadrant = function () { return this._quadrant }, Be.prototype.getNode = function () { return this._node }, Be.prototype.toString = function () { const t = Math.atan2(this._dy, this._dx); const e = this.getClass().getName(); const n = e.lastIndexOf('.'); return '  ' + e.substring(n + 1) + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + t + '   ' + this._label }, Be.prototype.computeLabel = function (t) {}, Be.prototype.init = function (t, e) { this._p0 = t, this._p1 = e, this._dx = e.x - t.x, this._dy = e.y - t.y, this._quadrant = Ge.quadrant(this._dx, this._dy), et.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found') }, Be.prototype.interfaces_ = function () { return [b] }, Be.prototype.getClass = function () { return Be }; const ze = (function (t) { function e () { const e = arguments[0]; const n = arguments[1]; if (t.call(this, e), this._isForward = null, this._isInResult = !1, this._isVisited = !1, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n, n) this.init(e.getCoordinate(0), e.getCoordinate(1)); else { const r = e.getNumPoints() - 1; this.init(e.getCoordinate(r), e.getCoordinate(r - 1)) } this.computeDirectedLabel() } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getNextMin = function () { return this._nextMin }, e.prototype.getDepth = function (t) { return this._depth[t] }, e.prototype.setVisited = function (t) { this._isVisited = t }, e.prototype.computeDirectedLabel = function () { this._label = new Re(this._edge.getLabel()), this._isForward || this._label.flip() }, e.prototype.getNext = function () { return this._next }, e.prototype.setDepth = function (t, e) { if (this._depth[t] !== -999 && this._depth[t] !== e) throw new Ce('assigned depths do not match', this.getCoordinate()); this._depth[t] = e }, e.prototype.isInteriorAreaEdge = function () { for (var t = !0, e = 0; e < 2; e++) this._label.isArea(e) && this._label.getLocation(e, Se.LEFT) === C.INTERIOR && this._label.getLocation(e, Se.RIGHT) === C.INTERIOR || (t = !1); return t }, e.prototype.setNextMin = function (t) { this._nextMin = t }, e.prototype.print = function (e) { t.prototype.print.call(this, e), e.print(' ' + this._depth[Se.LEFT] + '/' + this._depth[Se.RIGHT]), e.print(' (' + this.getDepthDelta() + ')'), this._isInResult && e.print(' inResult') }, e.prototype.setMinEdgeRing = function (t) { this._minEdgeRing = t }, e.prototype.isLineEdge = function () { const t = this._label.isLine(0) || this._label.isLine(1); const e = !this._label.isArea(0) || this._label.allPositionsEqual(0, C.EXTERIOR); const n = !this._label.isArea(1) || this._label.allPositionsEqual(1, C.EXTERIOR); return t && e && n }, e.prototype.setEdgeRing = function (t) { this._edgeRing = t }, e.prototype.getMinEdgeRing = function () { return this._minEdgeRing }, e.prototype.getDepthDelta = function () { let t = this._edge.getDepthDelta(); return this._isForward || (t = -t), t }, e.prototype.setInResult = function (t) { this._isInResult = t }, e.prototype.getSym = function () { return this._sym }, e.prototype.isForward = function () { return this._isForward }, e.prototype.getEdge = function () { return this._edge }, e.prototype.printEdge = function (t) { this.print(t), t.print(' '), this._isForward ? this._edge.print(t) : this._edge.printReverse(t) }, e.prototype.setSym = function (t) { this._sym = t }, e.prototype.setVisitedEdge = function (t) { this.setVisited(t), this._sym.setVisited(t) }, e.prototype.setEdgeDepths = function (t, e) { let n = this.getEdge().getDepthDelta(); this._isForward || (n = -n); let r = 1; t === Se.LEFT && (r = -1); const i = Se.opposite(t); const o = e + n * r; this.setDepth(t, e), this.setDepth(i, o) }, e.prototype.getEdgeRing = function () { return this._edgeRing }, e.prototype.isInResult = function () { return this._isInResult }, e.prototype.setNext = function (t) { this._next = t }, e.prototype.isVisited = function () { return this._isVisited }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e.depthFactor = function (t, e) { return t === C.EXTERIOR && e === C.INTERIOR ? 1 : t === C.INTERIOR && e === C.EXTERIOR ? -1 : 0 }, e }(Be)); const Ue = function () {}; Ue.prototype.createNode = function (t) { return new je(t, null) }, Ue.prototype.interfaces_ = function () { return [] }, Ue.prototype.getClass = function () { return Ue }; const Xe = function () { if (this._edges = new wt(), this._nodes = null, this._edgeEndList = new wt(), arguments.length === 0) this._nodes = new ke(new Ue()); else if (arguments.length === 1) { const t = arguments[0]; this._nodes = new ke(t) } }; Xe.prototype.printEdges = function (t) { t.println('Edges:'); for (let e = 0; e < this._edges.size(); e++) { t.println('edge ' + e + ':'); const n = this._edges.get(e); n.print(t), n.eiList.print(t) } }, Xe.prototype.find = function (t) { return this._nodes.find(t) }, Xe.prototype.addNode = function () { if (arguments[0] instanceof je) { const t = arguments[0]; return this._nodes.addNode(t) } if (arguments[0] instanceof I) { const e = arguments[0]; return this._nodes.addNode(e) } }, Xe.prototype.getNodeIterator = function () { return this._nodes.iterator() }, Xe.prototype.linkResultDirectedEdges = function () { for (let t = this._nodes.iterator(); t.hasNext();)t.next().getEdges().linkResultDirectedEdges() }, Xe.prototype.debugPrintln = function (t) { X.out.println(t) }, Xe.prototype.isBoundaryNode = function (t, e) { const n = this._nodes.find(e); if (n === null) return !1; const r = n.getLabel(); return r !== null && r.getLocation(t) === C.BOUNDARY }, Xe.prototype.linkAllDirectedEdges = function () { for (let t = this._nodes.iterator(); t.hasNext();)t.next().getEdges().linkAllDirectedEdges() }, Xe.prototype.matchInSameDirection = function (t, e, n, r) { return !!t.equals(n) && at.computeOrientation(t, e, r) === at.COLLINEAR && Ge.quadrant(t, e) === Ge.quadrant(n, r) }, Xe.prototype.getEdgeEnds = function () { return this._edgeEndList }, Xe.prototype.debugPrint = function (t) { X.out.print(t) }, Xe.prototype.getEdgeIterator = function () { return this._edges.iterator() }, Xe.prototype.findEdgeInSameDirection = function (t, e) { for (let n = 0; n < this._edges.size(); n++) { const r = this._edges.get(n); const i = r.getCoordinates(); if (this.matchInSameDirection(t, e, i[0], i[1])) return r; if (this.matchInSameDirection(t, e, i[i.length - 1], i[i.length - 2])) return r } return null }, Xe.prototype.insertEdge = function (t) { this._edges.add(t) }, Xe.prototype.findEdgeEnd = function (t) { for (let e = this.getEdgeEnds().iterator(); e.hasNext();) { const n = e.next(); if (n.getEdge() === t) return n } return null }, Xe.prototype.addEdges = function (t) { for (let e = t.iterator(); e.hasNext();) { const n = e.next(); this._edges.add(n); const r = new ze(n, !0); const i = new ze(n, !1); r.setSym(i), i.setSym(r), this.add(r), this.add(i) } }, Xe.prototype.add = function (t) { this._nodes.add(t), this._edgeEndList.add(t) }, Xe.prototype.getNodes = function () { return this._nodes.values() }, Xe.prototype.findEdge = function (t, e) { for (let n = 0; n < this._edges.size(); n++) { const r = this._edges.get(n); const i = r.getCoordinates(); if (t.equals(i[0]) && e.equals(i[1])) return r } return null }, Xe.prototype.interfaces_ = function () { return [] }, Xe.prototype.getClass = function () { return Xe }, Xe.linkResultDirectedEdges = function (t) { for (let e = t.iterator(); e.hasNext();)e.next().getEdges().linkResultDirectedEdges() }; const Ye = function () { this._geometryFactory = null, this._shellList = new wt(); const t = arguments[0]; this._geometryFactory = t }; Ye.prototype.sortShellsAndHoles = function (t, e, n) { for (let r = t.iterator(); r.hasNext();) { const i = r.next(); i.isHole() ? n.add(i) : e.add(i) } }, Ye.prototype.computePolygons = function (t) { for (var e = new wt(), n = t.iterator(); n.hasNext();) { const r = n.next().toPolygon(this._geometryFactory); e.add(r) } return e }, Ye.prototype.placeFreeHoles = function (t, e) { for (let n = e.iterator(); n.hasNext();) { const r = n.next(); if (r.getShell() === null) { const i = this.findEdgeRingContaining(r, t); if (i === null) throw new Ce('unable to assign hole to a shell', r.getCoordinate(0)); r.setShell(i) } } }, Ye.prototype.buildMinimalEdgeRings = function (t, e, n) { for (var r = new wt(), i = t.iterator(); i.hasNext();) { const o = i.next(); if (o.getMaxNodeDegree() > 2) { o.linkDirectedEdgesForMinimalEdgeRings(); const s = o.buildMinimalRings(); const a = this.findShell(s); a !== null ? (this.placePolygonHoles(a, s), e.add(a)) : n.addAll(s) } else r.add(o) } return r }, Ye.prototype.containsPoint = function (t) { for (let e = this._shellList.iterator(); e.hasNext();) if (e.next().containsPoint(t)) return !0; return !1 }, Ye.prototype.buildMaximalEdgeRings = function (t) { for (var e = new wt(), n = t.iterator(); n.hasNext();) { const r = n.next(); if (r.isInResult() && r.getLabel().isArea() && r.getEdgeRing() === null) { const i = new De(r, this._geometryFactory); e.add(i), i.setInResult() } } return e }, Ye.prototype.placePolygonHoles = function (t, e) { for (let n = e.iterator(); n.hasNext();) { const r = n.next(); r.isHole() && r.setShell(t) } }, Ye.prototype.getPolygons = function () { return this.computePolygons(this._shellList) }, Ye.prototype.findEdgeRingContaining = function (t, e) { for (var n = t.getLinearRing(), r = n.getEnvelopeInternal(), i = n.getCoordinateN(0), o = null, s = null, a = e.iterator(); a.hasNext();) { const u = a.next(); const l = u.getLinearRing(); const c = l.getEnvelopeInternal(); o !== null && (s = o.getLinearRing().getEnvelopeInternal()); let f = !1; c.contains(r) && at.isPointInRing(i, l.getCoordinates()) && (f = !0), f && (o === null || s.contains(c)) && (o = u) } return o }, Ye.prototype.findShell = function (t) { for (var e = 0, n = null, r = t.iterator(); r.hasNext();) { const i = r.next(); i.isHole() || (n = i, e++) } return et.isTrue(e <= 1, 'found two shells in MinimalEdgeRing list'), n }, Ye.prototype.add = function () { if (arguments.length === 1) { const t = arguments[0]; this.add(t.getEdgeEnds(), t.getNodes()) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; Xe.linkResultDirectedEdges(n); const r = this.buildMaximalEdgeRings(e); const i = new wt(); const o = this.buildMinimalEdgeRings(r, this._shellList, i); this.sortShellsAndHoles(o, this._shellList, i), this.placeFreeHoles(this._shellList, i) } }, Ye.prototype.interfaces_ = function () { return [] }, Ye.prototype.getClass = function () { return Ye }; const Ve = function () {}; Ve.prototype.getBounds = function () {}, Ve.prototype.interfaces_ = function () { return [] }, Ve.prototype.getClass = function () { return Ve }; const We = function () { this._bounds = null, this._item = null; const t = arguments[0]; const e = arguments[1]; this._bounds = t, this._item = e }; We.prototype.getItem = function () { return this._item }, We.prototype.getBounds = function () { return this._bounds }, We.prototype.interfaces_ = function () { return [Ve, e] }, We.prototype.getClass = function () { return We }; const He = function () { this._size = null, this._items = null, this._size = 0, this._items = new wt(), this._items.add(null) }; He.prototype.poll = function () { if (this.isEmpty()) return null; const t = this._items.get(1); return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t }, He.prototype.size = function () { return this._size }, He.prototype.reorder = function (t) { for (var e = null, n = this._items.get(t); 2 * t <= this._size && ((e = 2 * t) !== this._size && this._items.get(e + 1).compareTo(this._items.get(e)) < 0 && e++, this._items.get(e).compareTo(n) < 0); t = e) this._items.set(t, this._items.get(e)); this._items.set(t, n) }, He.prototype.clear = function () { this._size = 0, this._items.clear() }, He.prototype.isEmpty = function () { return this._size === 0 }, He.prototype.add = function (t) { this._items.add(null), this._size += 1; let e = this._size; for (this._items.set(0, t); t.compareTo(this._items.get(Math.trunc(e / 2))) < 0; e /= 2) this._items.set(e, this._items.get(Math.trunc(e / 2))); this._items.set(e, t) }, He.prototype.interfaces_ = function () { return [] }, He.prototype.getClass = function () { return He }; const Je = function () {}; Je.prototype.visitItem = function (t) {}, Je.prototype.interfaces_ = function () { return [] }, Je.prototype.getClass = function () { return Je }; const Ze = function () {}; Ze.prototype.insert = function (t, e) {}, Ze.prototype.remove = function (t, e) {}, Ze.prototype.query = function () {}, Ze.prototype.interfaces_ = function () { return [] }, Ze.prototype.getClass = function () { return Ze }; const Ke = function () { if (this._childBoundables = new wt(), this._bounds = null, this._level = null, arguments.length === 0);else if (arguments.length === 1) { const t = arguments[0]; this._level = t } }; const Qe = { serialVersionUID: { configurable: !0 } }; Ke.prototype.getLevel = function () { return this._level }, Ke.prototype.size = function () { return this._childBoundables.size() }, Ke.prototype.getChildBoundables = function () { return this._childBoundables }, Ke.prototype.addChildBoundable = function (t) { et.isTrue(this._bounds === null), this._childBoundables.add(t) }, Ke.prototype.isEmpty = function () { return this._childBoundables.isEmpty() }, Ke.prototype.getBounds = function () { return this._bounds === null && (this._bounds = this.computeBounds()), this._bounds }, Ke.prototype.interfaces_ = function () { return [Ve, e] }, Ke.prototype.getClass = function () { return Ke }, Qe.serialVersionUID.get = function () { return 0x5a1e55ec41369800 }, Object.defineProperties(Ke, Qe); const $e = function () {}; $e.reverseOrder = function () { return { compare: function (t, e) { return e.compareTo(t) } } }, $e.min = function (t) { return $e.sort(t), t.get(0) }, $e.sort = function (t, e) { const n = t.toArray(); e ? jt.sort(n, e) : jt.sort(n); for (let r = t.iterator(), i = 0, o = n.length; i < o; i++)r.next(), r.set(n[i]) }, $e.singletonList = function (t) { const e = new wt(); return e.add(t), e }; const tn = function () { this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null; const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; this._boundable1 = t, this._boundable2 = e, this._itemDistance = n, this._distance = this.distance() }; tn.prototype.expandToQueue = function (t, e) { const n = tn.isComposite(this._boundable1); const r = tn.isComposite(this._boundable2); if (n && r) return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t, e), null) : (this.expand(this._boundable2, this._boundable1, t, e), null); if (n) return this.expand(this._boundable1, this._boundable2, t, e), null; if (r) return this.expand(this._boundable2, this._boundable1, t, e), null; throw new _('neither boundable is composite') }, tn.prototype.isLeaves = function () { return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2)) }, tn.prototype.compareTo = function (t) { const e = t; return this._distance < e._distance ? -1 : this._distance > e._distance ? 1 : 0 }, tn.prototype.expand = function (t, e, n, r) { for (let i = t.getChildBoundables().iterator(); i.hasNext();) { const o = i.next(); const s = new tn(o, e, this._itemDistance); s.getDistance() < r && n.add(s) } }, tn.prototype.getBoundable = function (t) { return t === 0 ? this._boundable1 : this._boundable2 }, tn.prototype.getDistance = function () { return this._distance }, tn.prototype.distance = function () { return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds()) }, tn.prototype.interfaces_ = function () { return [b] }, tn.prototype.getClass = function () { return tn }, tn.area = function (t) { return t.getBounds().getArea() }, tn.isComposite = function (t) { return t instanceof Ke }; const en = function t () { if (this._root = null, this._built = !1, this._itemBoundables = new wt(), this._nodeCapacity = null, arguments.length === 0) { const e = t.DEFAULT_NODE_CAPACITY; this._nodeCapacity = e } else if (arguments.length === 1) { const n = arguments[0]; et.isTrue(n > 1, 'Node capacity must be greater than 1'), this._nodeCapacity = n } }; const nn = { IntersectsOp: { configurable: !0 }, serialVersionUID: { configurable: !0 }, DEFAULT_NODE_CAPACITY: { configurable: !0 } }; en.prototype.getNodeCapacity = function () { return this._nodeCapacity }, en.prototype.lastNode = function (t) { return t.get(t.size() - 1) }, en.prototype.size = function () { if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.size(this._root)); if (arguments.length === 1) { for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) { const n = e.next(); n instanceof Ke ? t += this.size(n) : n instanceof We && (t += 1) } return t } }, en.prototype.removeItem = function (t, e) { for (var n = null, r = t.getChildBoundables().iterator(); r.hasNext();) { const i = r.next(); i instanceof We && i.getItem() === e && (n = i) } return n !== null && (t.getChildBoundables().remove(n), !0) }, en.prototype.itemsTree = function () { if (arguments.length === 0) { this.build(); const t = this.itemsTree(this._root); return t === null ? new wt() : t } if (arguments.length === 1) { for (var e = arguments[0], n = new wt(), r = e.getChildBoundables().iterator(); r.hasNext();) { const i = r.next(); if (i instanceof Ke) { const o = this.itemsTree(i); o !== null && n.add(o) } else i instanceof We ? n.add(i.getItem()) : et.shouldNeverReachHere() } return n.size() <= 0 ? null : n } }, en.prototype.insert = function (t, e) { et.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.'), this._itemBoundables.add(new We(t, e)) }, en.prototype.boundablesAtLevel = function () { if (arguments.length === 1) { const t = arguments[0]; const e = new wt(); return this.boundablesAtLevel(t, this._root, e), e } if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; if (et.isTrue(n > -2), r.getLevel() === n) return i.add(r), null; for (let o = r.getChildBoundables().iterator(); o.hasNext();) { const s = o.next(); s instanceof Ke ? this.boundablesAtLevel(n, s, i) : (et.isTrue(s instanceof We), n === -1 && i.add(s)) } return null } }, en.prototype.query = function () { if (arguments.length === 1) { const t = arguments[0]; this.build(); const e = new wt(); return this.isEmpty() || this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.query(t, this._root, e), e } if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; if (this.build(), this.isEmpty()) return null; this.getIntersectsOp().intersects(this._root.getBounds(), n) && this.query(n, this._root, r) } else if (arguments.length === 3) if (O(arguments[2], Je) && arguments[0] instanceof Object && arguments[1] instanceof Ke) for (let i = arguments[0], o = arguments[2], s = arguments[1].getChildBoundables(), a = 0; a < s.size(); a++) { const u = s.get(a); this.getIntersectsOp().intersects(u.getBounds(), i) && (u instanceof Ke ? this.query(i, u, o) : u instanceof We ? o.visitItem(u.getItem()) : et.shouldNeverReachHere()) } else if (O(arguments[2], Et) && arguments[0] instanceof Object && arguments[1] instanceof Ke) for (let l = arguments[0], c = arguments[2], f = arguments[1].getChildBoundables(), h = 0; h < f.size(); h++) { const p = f.get(h); this.getIntersectsOp().intersects(p.getBounds(), l) && (p instanceof Ke ? this.query(l, p, c) : p instanceof We ? c.add(p.getItem()) : et.shouldNeverReachHere()) } }, en.prototype.build = function () { if (this._built) return null; this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = !0 }, en.prototype.getRoot = function () { return this.build(), this._root }, en.prototype.remove = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t) && this.remove(t, this._root, e) } if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; let o = this.removeItem(r, i); if (o) return !0; for (var s = null, a = r.getChildBoundables().iterator(); a.hasNext();) { const u = a.next(); if (this.getIntersectsOp().intersects(u.getBounds(), n) && u instanceof Ke && (o = this.remove(n, u, i))) { s = u; break } } return s !== null && s.getChildBoundables().isEmpty() && r.getChildBoundables().remove(s), o } }, en.prototype.createHigherLevels = function (t, e) { et.isTrue(!t.isEmpty()); const n = this.createParentBoundables(t, e + 1); return n.size() === 1 ? n.get(0) : this.createHigherLevels(n, e + 1) }, en.prototype.depth = function () { if (arguments.length === 0) return this.isEmpty() ? 0 : (this.build(), this.depth(this._root)); if (arguments.length === 1) { for (var t = 0, e = arguments[0].getChildBoundables().iterator(); e.hasNext();) { const n = e.next(); if (n instanceof Ke) { const r = this.depth(n); r > t && (t = r) } } return t + 1 } }, en.prototype.createParentBoundables = function (t, e) { et.isTrue(!t.isEmpty()); const n = new wt(); n.add(this.createNode(e)); const r = new wt(t); $e.sort(r, this.getComparator()); for (let i = r.iterator(); i.hasNext();) { const o = i.next(); this.lastNode(n).getChildBoundables().size() === this.getNodeCapacity() && n.add(this.createNode(e)), this.lastNode(n).addChildBoundable(o) } return n }, en.prototype.isEmpty = function () { return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty() }, en.prototype.interfaces_ = function () { return [e] }, en.prototype.getClass = function () { return en }, en.compareDoubles = function (t, e) { return t > e ? 1 : t < e ? -1 : 0 }, nn.IntersectsOp.get = function () { return rn }, nn.serialVersionUID.get = function () { return -0x35ef64c82d4c5400 }, nn.DEFAULT_NODE_CAPACITY.get = function () { return 10 }, Object.defineProperties(en, nn); var rn = function () {}; const on = function () {}; on.prototype.distance = function (t, e) {}, on.prototype.interfaces_ = function () { return [] }, on.prototype.getClass = function () { return on }; const sn = (function (t) { function n (e) { e = e || n.DEFAULT_NODE_CAPACITY, t.call(this, e) }t && (n.__proto__ = t), (n.prototype = Object.create(t && t.prototype)).constructor = n; const r = { STRtreeNode: { configurable: !0 }, serialVersionUID: { configurable: !0 }, xComparator: { configurable: !0 }, yComparator: { configurable: !0 }, intersectsOp: { configurable: !0 }, DEFAULT_NODE_CAPACITY: { configurable: !0 } }; return n.prototype.createParentBoundablesFromVerticalSlices = function (t, e) { et.isTrue(t.length > 0); for (var n = new wt(), r = 0; r < t.length; r++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[r], e)); return n }, n.prototype.createNode = function (t) { return new an(t) }, n.prototype.size = function () { return arguments.length === 0 ? t.prototype.size.call(this) : t.prototype.size.apply(this, arguments) }, n.prototype.insert = function () { if (arguments.length !== 2) return t.prototype.insert.apply(this, arguments); const e = arguments[0]; const n = arguments[1]; if (e.isNull()) return null; t.prototype.insert.call(this, e, n) }, n.prototype.getIntersectsOp = function () { return n.intersectsOp }, n.prototype.verticalSlices = function (t, e) { for (var n = Math.trunc(Math.ceil(t.size() / e)), r = new Array(e).fill(null), i = t.iterator(), o = 0; o < e; o++) { r[o] = new wt(); for (let s = 0; i.hasNext() && s < n;) { const a = i.next(); r[o].add(a), s++ } } return r }, n.prototype.query = function () { if (arguments.length === 1) { const e = arguments[0]; return t.prototype.query.call(this, e) } if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; t.prototype.query.call(this, n, r) } else if (arguments.length === 3) if (O(arguments[2], Je) && arguments[0] instanceof Object && arguments[1] instanceof Ke) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; t.prototype.query.call(this, i, o, s) } else if (O(arguments[2], Et) && arguments[0] instanceof Object && arguments[1] instanceof Ke) { const a = arguments[0]; const u = arguments[1]; const l = arguments[2]; t.prototype.query.call(this, a, u, l) } }, n.prototype.getComparator = function () { return n.yComparator }, n.prototype.createParentBoundablesFromVerticalSlice = function (e, n) { return t.prototype.createParentBoundables.call(this, e, n) }, n.prototype.remove = function () { if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return t.prototype.remove.call(this, e, n) } return t.prototype.remove.apply(this, arguments) }, n.prototype.depth = function () { return arguments.length === 0 ? t.prototype.depth.call(this) : t.prototype.depth.apply(this, arguments) }, n.prototype.createParentBoundables = function (t, e) { et.isTrue(!t.isEmpty()); const r = Math.trunc(Math.ceil(t.size() / this.getNodeCapacity())); const i = new wt(t); $e.sort(i, n.xComparator); const o = this.verticalSlices(i, Math.trunc(Math.ceil(Math.sqrt(r)))); return this.createParentBoundablesFromVerticalSlices(o, e) }, n.prototype.nearestNeighbour = function () { if (arguments.length === 1) { if (O(arguments[0], on)) { const t = arguments[0]; const e = new tn(this.getRoot(), this.getRoot(), t); return this.nearestNeighbour(e) } if (arguments[0] instanceof tn) { const r = arguments[0]; return this.nearestNeighbour(r, m.POSITIVE_INFINITY) } } else if (arguments.length === 2) { if (arguments[0] instanceof n && O(arguments[1], on)) { const i = arguments[0]; const o = arguments[1]; const s = new tn(this.getRoot(), i.getRoot(), o); return this.nearestNeighbour(s) } if (arguments[0] instanceof tn && typeof arguments[1] === 'number') { const a = arguments[0]; let u = arguments[1]; let l = null; const c = new He(); for (c.add(a); !c.isEmpty() && u > 0;) { const f = c.poll(); const h = f.getDistance(); if (h >= u) break; f.isLeaves() ? (u = h, l = f) : f.expandToQueue(c, u) } return [l.getBoundable(0).getItem(), l.getBoundable(1).getItem()] } } else if (arguments.length === 3) { const p = arguments[2]; const g = new We(arguments[0], arguments[1]); const d = new tn(this.getRoot(), g, p); return this.nearestNeighbour(d)[0] } }, n.prototype.interfaces_ = function () { return [Ze, e] }, n.prototype.getClass = function () { return n }, n.centreX = function (t) { return n.avg(t.getMinX(), t.getMaxX()) }, n.avg = function (t, e) { return (t + e) / 2 }, n.centreY = function (t) { return n.avg(t.getMinY(), t.getMaxY()) }, r.STRtreeNode.get = function () { return an }, r.serialVersionUID.get = function () { return 0x39920f7d5f261e0 }, r.xComparator.get = function () { return { interfaces_: function () { return [w] }, compare: function (e, r) { return t.compareDoubles(n.centreX(e.getBounds()), n.centreX(r.getBounds())) } } }, r.yComparator.get = function () { return { interfaces_: function () { return [w] }, compare: function (e, r) { return t.compareDoubles(n.centreY(e.getBounds()), n.centreY(r.getBounds())) } } }, r.intersectsOp.get = function () { return { interfaces_: function () { return [t.IntersectsOp] }, intersects: function (t, e) { return t.intersects(e) } } }, r.DEFAULT_NODE_CAPACITY.get = function () { return 10 }, Object.defineProperties(n, r), n }(en)); var an = (function (t) { function e () { const e = arguments[0]; t.call(this, e) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.computeBounds = function () { for (var t = null, e = this.getChildBoundables().iterator(); e.hasNext();) { const n = e.next(); t === null ? t = new V(n.getBounds()) : t.expandToInclude(n.getBounds()) } return t }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Ke)); const un = function () {}; un.prototype.interfaces_ = function () { return [] }, un.prototype.getClass = function () { return un }, un.relativeSign = function (t, e) { return t < e ? -1 : t > e ? 1 : 0 }, un.compare = function (t, e, n) { if (e.equals2D(n)) return 0; const r = un.relativeSign(e.x, n.x); const i = un.relativeSign(e.y, n.y); switch (t) { case 0:return un.compareValue(r, i); case 1:return un.compareValue(i, r); case 2:return un.compareValue(i, -r); case 3:return un.compareValue(-r, i); case 4:return un.compareValue(-r, -i); case 5:return un.compareValue(-i, -r); case 6:return un.compareValue(-i, r); case 7:return un.compareValue(r, -i) } return et.shouldNeverReachHere('invalid octant value'), 0 }, un.compareValue = function (t, e) { return t < 0 ? -1 : t > 0 ? 1 : e < 0 ? -1 : e > 0 ? 1 : 0 }; const ln = function () { this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null; const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; const r = arguments[3]; this._segString = t, this.coord = new I(e), this.segmentIndex = n, this._segmentOctant = r, this._isInterior = !e.equals2D(t.getCoordinate(n)) }; ln.prototype.getCoordinate = function () { return this.coord }, ln.prototype.print = function (t) { t.print(this.coord), t.print(' seg # = ' + this.segmentIndex) }, ln.prototype.compareTo = function (t) { const e = t; return this.segmentIndex < e.segmentIndex ? -1 : this.segmentIndex > e.segmentIndex ? 1 : this.coord.equals2D(e.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e.coord) }, ln.prototype.isEndPoint = function (t) { return this.segmentIndex === 0 && !this._isInterior || this.segmentIndex === t }, ln.prototype.isInterior = function () { return this._isInterior }, ln.prototype.interfaces_ = function () { return [b] }, ln.prototype.getClass = function () { return ln }; const cn = function () { this._nodeMap = new f(), this._edge = null; const t = arguments[0]; this._edge = t }; cn.prototype.getSplitCoordinates = function () { const t = new St(); this.addEndpoints(); for (let e = this.iterator(), n = e.next(); e.hasNext();) { const r = e.next(); this.addEdgeCoordinates(n, r, t), n = r } return t.toCoordinateArray() }, cn.prototype.addCollapsedNodes = function () { const t = new wt(); this.findCollapsesFromInsertedNodes(t), this.findCollapsesFromExistingVertices(t); for (let e = t.iterator(); e.hasNext();) { const n = e.next().intValue(); this.add(this._edge.getCoordinate(n), n) } }, cn.prototype.print = function (t) { t.println('Intersections:'); for (let e = this.iterator(); e.hasNext();)e.next().print(t) }, cn.prototype.findCollapsesFromExistingVertices = function (t) { for (let e = 0; e < this._edge.size() - 2; e++) { const n = this._edge.getCoordinate(e); const r = this._edge.getCoordinate(e + 2); n.equals2D(r) && t.add(new T(e + 1)) } }, cn.prototype.addEdgeCoordinates = function (t, e, n) { const r = this._edge.getCoordinate(e.segmentIndex); const i = e.isInterior() || !e.coord.equals2D(r); n.add(new I(t.coord), !1); for (let o = t.segmentIndex + 1; o <= e.segmentIndex; o++)n.add(this._edge.getCoordinate(o)); i && n.add(new I(e.coord)) }, cn.prototype.iterator = function () { return this._nodeMap.values().iterator() }, cn.prototype.addSplitEdges = function (t) { this.addEndpoints(), this.addCollapsedNodes(); for (let e = this.iterator(), n = e.next(); e.hasNext();) { const r = e.next(); const i = this.createSplitEdge(n, r); t.add(i), n = r } }, cn.prototype.findCollapseIndex = function (t, e, n) { if (!t.coord.equals2D(e.coord)) return !1; let r = e.segmentIndex - t.segmentIndex; return e.isInterior() || r--, r === 1 && (n[0] = t.segmentIndex + 1, !0) }, cn.prototype.findCollapsesFromInsertedNodes = function (t) { for (let e = new Array(1).fill(null), n = this.iterator(), r = n.next(); n.hasNext();) { const i = n.next(); this.findCollapseIndex(r, i, e) && t.add(new T(e[0])), r = i } }, cn.prototype.getEdge = function () { return this._edge }, cn.prototype.addEndpoints = function () { const t = this._edge.size() - 1; this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t), t) }, cn.prototype.createSplitEdge = function (t, e) { let n = e.segmentIndex - t.segmentIndex + 2; const r = this._edge.getCoordinate(e.segmentIndex); const i = e.isInterior() || !e.coord.equals2D(r); i || n--; const o = new Array(n).fill(null); let s = 0; o[s++] = new I(t.coord); for (let a = t.segmentIndex + 1; a <= e.segmentIndex; a++)o[s++] = this._edge.getCoordinate(a); return i && (o[s] = new I(e.coord)), new gn(o, this._edge.getData()) }, cn.prototype.add = function (t, e) { const n = new ln(this._edge, t, e, this._edge.getSegmentOctant(e)); const r = this._nodeMap.get(n); return r !== null ? (et.isTrue(r.coord.equals2D(t), 'Found equal nodes with different coordinates'), r) : (this._nodeMap.put(n, n), n) }, cn.prototype.checkSplitEdgesCorrectness = function (t) { const e = this._edge.getCoordinates(); const n = t.get(0).getCoordinate(0); if (!n.equals2D(e[0])) throw new $('bad split edge start point at ' + n); const r = t.get(t.size() - 1).getCoordinates(); const i = r[r.length - 1]; if (!i.equals2D(e[e.length - 1])) throw new $('bad split edge end point at ' + i) }, cn.prototype.interfaces_ = function () { return [] }, cn.prototype.getClass = function () { return cn }; const fn = function () {}; fn.prototype.interfaces_ = function () { return [] }, fn.prototype.getClass = function () { return fn }, fn.octant = function () { if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') { const t = arguments[0]; const e = arguments[1]; if (t === 0 && e === 0) throw new _('Cannot compute the octant for point ( ' + t + ', ' + e + ' )'); const n = Math.abs(t); const r = Math.abs(e); return t >= 0 ? e >= 0 ? n >= r ? 0 : 1 : n >= r ? 7 : 6 : e >= 0 ? n >= r ? 3 : 2 : n >= r ? 4 : 5 } if (arguments[0] instanceof I && arguments[1] instanceof I) { const i = arguments[0]; const o = arguments[1]; const s = o.x - i.x; const a = o.y - i.y; if (s === 0 && a === 0) throw new _('Cannot compute the octant for two identical points ' + i); return fn.octant(s, a) } }; const hn = function () {}; hn.prototype.getCoordinates = function () {}, hn.prototype.size = function () {}, hn.prototype.getCoordinate = function (t) {}, hn.prototype.isClosed = function () {}, hn.prototype.setData = function (t) {}, hn.prototype.getData = function () {}, hn.prototype.interfaces_ = function () { return [] }, hn.prototype.getClass = function () { return hn }; const pn = function () {}; pn.prototype.addIntersection = function (t, e) {}, pn.prototype.interfaces_ = function () { return [hn] }, pn.prototype.getClass = function () { return pn }; var gn = function () { this._nodeList = new cn(this), this._pts = null, this._data = null; const t = arguments[0]; const e = arguments[1]; this._pts = t, this._data = e }; gn.prototype.getCoordinates = function () { return this._pts }, gn.prototype.size = function () { return this._pts.length }, gn.prototype.getCoordinate = function (t) { return this._pts[t] }, gn.prototype.isClosed = function () { return this._pts[0].equals(this._pts[this._pts.length - 1]) }, gn.prototype.getSegmentOctant = function (t) { return t === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t), this.getCoordinate(t + 1)) }, gn.prototype.setData = function (t) { this._data = t }, gn.prototype.safeOctant = function (t, e) { return t.equals2D(e) ? 0 : fn.octant(t, e) }, gn.prototype.getData = function () { return this._data }, gn.prototype.addIntersection = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; this.addIntersectionNode(t, e) } else if (arguments.length === 4) { const n = arguments[1]; const r = arguments[3]; const i = new I(arguments[0].getIntersection(r)); this.addIntersection(i, n) } }, gn.prototype.toString = function () { return Q.toLineString(new ue(this._pts)) }, gn.prototype.getNodeList = function () { return this._nodeList }, gn.prototype.addIntersectionNode = function (t, e) { let n = e; const r = n + 1; if (r < this._pts.length) { const i = this._pts[r]; t.equals2D(i) && (n = r) } return this._nodeList.add(t, n) }, gn.prototype.addIntersections = function (t, e, n) { for (let r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r) }, gn.prototype.interfaces_ = function () { return [pn] }, gn.prototype.getClass = function () { return gn }, gn.getNodedSubstrings = function () { if (arguments.length === 1) { const t = arguments[0]; const e = new wt(); return gn.getNodedSubstrings(t, e), e } if (arguments.length === 2) for (let n = arguments[1], r = arguments[0].iterator(); r.hasNext();)r.next().getNodeList().addSplitEdges(n) }; const dn = function () { if (this.p0 = null, this.p1 = null, arguments.length === 0) this.p0 = new I(), this.p1 = new I(); else if (arguments.length === 1) { const t = arguments[0]; this.p0 = new I(t.p0), this.p1 = new I(t.p1) } else if (arguments.length === 2) this.p0 = arguments[0], this.p1 = arguments[1]; else if (arguments.length === 4) { const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; const i = arguments[3]; this.p0 = new I(e, n), this.p1 = new I(r, i) } }; const yn = { serialVersionUID: { configurable: !0 } }; dn.prototype.minX = function () { return Math.min(this.p0.x, this.p1.x) }, dn.prototype.orientationIndex = function () { if (arguments[0] instanceof dn) { const t = arguments[0]; const e = at.orientationIndex(this.p0, this.p1, t.p0); const n = at.orientationIndex(this.p0, this.p1, t.p1); return e >= 0 && n >= 0 || e <= 0 && n <= 0 ? Math.max(e, n) : 0 } if (arguments[0] instanceof I) { const r = arguments[0]; return at.orientationIndex(this.p0, this.p1, r) } }, dn.prototype.toGeometry = function (t) { return t.createLineString([this.p0, this.p1]) }, dn.prototype.isVertical = function () { return this.p0.x === this.p1.x }, dn.prototype.equals = function (t) { if (!(t instanceof dn)) return !1; const e = t; return this.p0.equals(e.p0) && this.p1.equals(e.p1) }, dn.prototype.intersection = function (t) { const e = new it(); return e.computeIntersection(this.p0, this.p1, t.p0, t.p1), e.hasIntersection() ? e.getIntersection(0) : null }, dn.prototype.project = function () { if (arguments[0] instanceof I) { const t = arguments[0]; if (t.equals(this.p0) || t.equals(this.p1)) return new I(t); const e = this.projectionFactor(t); const n = new I(); return n.x = this.p0.x + e * (this.p1.x - this.p0.x), n.y = this.p0.y + e * (this.p1.y - this.p0.y), n } if (arguments[0] instanceof dn) { const r = arguments[0]; const i = this.projectionFactor(r.p0); const o = this.projectionFactor(r.p1); if (i >= 1 && o >= 1) return null; if (i <= 0 && o <= 0) return null; let s = this.project(r.p0); i < 0 && (s = this.p0), i > 1 && (s = this.p1); let a = this.project(r.p1); return o < 0 && (a = this.p0), o > 1 && (a = this.p1), new dn(s, a) } }, dn.prototype.normalize = function () { this.p1.compareTo(this.p0) < 0 && this.reverse() }, dn.prototype.angle = function () { return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x) }, dn.prototype.getCoordinate = function (t) { return t === 0 ? this.p0 : this.p1 }, dn.prototype.distancePerpendicular = function (t) { return at.distancePointLinePerpendicular(t, this.p0, this.p1) }, dn.prototype.minY = function () { return Math.min(this.p0.y, this.p1.y) }, dn.prototype.midPoint = function () { return dn.midPoint(this.p0, this.p1) }, dn.prototype.projectionFactor = function (t) { if (t.equals(this.p0)) return 0; if (t.equals(this.p1)) return 1; const e = this.p1.x - this.p0.x; const n = this.p1.y - this.p0.y; const r = e * e + n * n; return r <= 0 ? m.NaN : ((t.x - this.p0.x) * e + (t.y - this.p0.y) * n) / r }, dn.prototype.closestPoints = function (t) { const e = this.intersection(t); if (e !== null) return [e, e]; const n = new Array(2).fill(null); let r = m.MAX_VALUE; let i = null; const o = this.closestPoint(t.p0); r = o.distance(t.p0), n[0] = o, n[1] = t.p0; const s = this.closestPoint(t.p1); (i = s.distance(t.p1)) < r && (r = i, n[0] = s, n[1] = t.p1); const a = t.closestPoint(this.p0); (i = a.distance(this.p0)) < r && (r = i, n[0] = this.p0, n[1] = a); const u = t.closestPoint(this.p1); return (i = u.distance(this.p1)) < r && (r = i, n[0] = this.p1, n[1] = u), n }, dn.prototype.closestPoint = function (t) { const e = this.projectionFactor(t); return e > 0 && e < 1 ? this.project(t) : this.p0.distance(t) < this.p1.distance(t) ? this.p0 : this.p1 }, dn.prototype.maxX = function () { return Math.max(this.p0.x, this.p1.x) }, dn.prototype.getLength = function () { return this.p0.distance(this.p1) }, dn.prototype.compareTo = function (t) { const e = t; const n = this.p0.compareTo(e.p0); return n !== 0 ? n : this.p1.compareTo(e.p1) }, dn.prototype.reverse = function () { const t = this.p0; this.p0 = this.p1, this.p1 = t }, dn.prototype.equalsTopo = function (t) { return this.p0.equals(t.p0) && (this.p1.equals(t.p1) || this.p0.equals(t.p1)) && this.p1.equals(t.p0) }, dn.prototype.lineIntersection = function (t) { try { return Y.intersection(this.p0, this.p1, t.p0, t.p1) } catch (t) { if (!(t instanceof U)) throw t } return null }, dn.prototype.maxY = function () { return Math.max(this.p0.y, this.p1.y) }, dn.prototype.pointAlongOffset = function (t, e) { const n = this.p0.x + t * (this.p1.x - this.p0.x); const r = this.p0.y + t * (this.p1.y - this.p0.y); const i = this.p1.x - this.p0.x; const o = this.p1.y - this.p0.y; const s = Math.sqrt(i * i + o * o); let a = 0; let u = 0; if (e !== 0) { if (s <= 0) throw new Error('Cannot compute offset from zero-length line segment'); a = e * i / s, u = e * o / s } return new I(n - u, r + a) }, dn.prototype.setCoordinates = function () { if (arguments.length === 1) { const t = arguments[0]; this.setCoordinates(t.p0, t.p1) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; this.p0.x = e.x, this.p0.y = e.y, this.p1.x = n.x, this.p1.y = n.y } }, dn.prototype.segmentFraction = function (t) { let e = this.projectionFactor(t); return e < 0 ? e = 0 : (e > 1 || m.isNaN(e)) && (e = 1), e }, dn.prototype.toString = function () { return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')' }, dn.prototype.isHorizontal = function () { return this.p0.y === this.p1.y }, dn.prototype.distance = function () { if (arguments[0] instanceof dn) { const t = arguments[0]; return at.distanceLineLine(this.p0, this.p1, t.p0, t.p1) } if (arguments[0] instanceof I) { const e = arguments[0]; return at.distancePointLine(e, this.p0, this.p1) } }, dn.prototype.pointAlong = function (t) { const e = new I(); return e.x = this.p0.x + t * (this.p1.x - this.p0.x), e.y = this.p0.y + t * (this.p1.y - this.p0.y), e }, dn.prototype.hashCode = function () { let t = m.doubleToLongBits(this.p0.x); t ^= 31 * m.doubleToLongBits(this.p0.y); const e = Math.trunc(t) ^ Math.trunc(t >> 32); let n = m.doubleToLongBits(this.p1.x); return n ^= 31 * m.doubleToLongBits(this.p1.y), e ^ Math.trunc(n) ^ Math.trunc(n >> 32) }, dn.prototype.interfaces_ = function () { return [b, e] }, dn.prototype.getClass = function () { return dn }, dn.midPoint = function (t, e) { return new I((t.x + e.x) / 2, (t.y + e.y) / 2) }, yn.serialVersionUID.get = function () { return 0x2d2172135f411c00 }, Object.defineProperties(dn, yn); const vn = function () { this.tempEnv1 = new V(), this.tempEnv2 = new V(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn() }; vn.prototype.overlap = function () { if (arguments.length === 2);else if (arguments.length === 4) { const t = arguments[1]; const e = arguments[2]; const n = arguments[3]; arguments[0].getLineSegment(t, this._overlapSeg1), e.getLineSegment(n, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2) } }, vn.prototype.interfaces_ = function () { return [] }, vn.prototype.getClass = function () { return vn }; const _n = function () { this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null; const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; const r = arguments[3]; this._pts = t, this._start = e, this._end = n, this._context = r }; _n.prototype.getLineSegment = function (t, e) { e.p0 = this._pts[t], e.p1 = this._pts[t + 1] }, _n.prototype.computeSelect = function (t, e, n, r) { const i = this._pts[e]; const o = this._pts[n]; if (r.tempEnv1.init(i, o), n - e == 1) return r.select(this, e), null; if (!t.intersects(r.tempEnv1)) return null; const s = Math.trunc((e + n) / 2); e < s && this.computeSelect(t, e, s, r), s < n && this.computeSelect(t, s, n, r) }, _n.prototype.getCoordinates = function () { for (var t = new Array(this._end - this._start + 1).fill(null), e = 0, n = this._start; n <= this._end; n++)t[e++] = this._pts[n]; return t }, _n.prototype.computeOverlaps = function (t, e) { this.computeOverlapsInternal(this._start, this._end, t, t._start, t._end, e) }, _n.prototype.setId = function (t) { this._id = t }, _n.prototype.select = function (t, e) { this.computeSelect(t, this._start, this._end, e) }, _n.prototype.getEnvelope = function () { if (this._env === null) { const t = this._pts[this._start]; const e = this._pts[this._end]; this._env = new V(t, e) } return this._env }, _n.prototype.getEndIndex = function () { return this._end }, _n.prototype.getStartIndex = function () { return this._start }, _n.prototype.getContext = function () { return this._context }, _n.prototype.getId = function () { return this._id }, _n.prototype.computeOverlapsInternal = function (t, e, n, r, i, o) { const s = this._pts[t]; const a = this._pts[e]; const u = n._pts[r]; const l = n._pts[i]; if (e - t == 1 && i - r == 1) return o.overlap(this, t, n, r), null; if (o.tempEnv1.init(s, a), o.tempEnv2.init(u, l), !o.tempEnv1.intersects(o.tempEnv2)) return null; const c = Math.trunc((t + e) / 2); const f = Math.trunc((r + i) / 2); t < c && (r < f && this.computeOverlapsInternal(t, c, n, r, f, o), f < i && this.computeOverlapsInternal(t, c, n, f, i, o)), c < e && (r < f && this.computeOverlapsInternal(c, e, n, r, f, o), f < i && this.computeOverlapsInternal(c, e, n, f, i, o)) }, _n.prototype.interfaces_ = function () { return [] }, _n.prototype.getClass = function () { return _n }; const mn = function () {}; mn.prototype.interfaces_ = function () { return [] }, mn.prototype.getClass = function () { return mn }, mn.getChainStartIndices = function (t) { let e = 0; const n = new wt(); n.add(new T(e)); do { const r = mn.findChainEnd(t, e); n.add(new T(r)), e = r } while (e < t.length - 1); return mn.toIntArray(n) }, mn.findChainEnd = function (t, e) { for (var n = e; n < t.length - 1 && t[n].equals2D(t[n + 1]);)n++; if (n >= t.length - 1) return t.length - 1; for (var r = Ge.quadrant(t[n], t[n + 1]), i = e + 1; i < t.length && (t[i - 1].equals2D(t[i]) || Ge.quadrant(t[i - 1], t[i]) === r);)i++; return i - 1 }, mn.getChains = function () { if (arguments.length === 1) { const t = arguments[0]; return mn.getChains(t, null) } if (arguments.length === 2) { for (var e = arguments[0], n = arguments[1], r = new wt(), i = mn.getChainStartIndices(e), o = 0; o < i.length - 1; o++) { const s = new _n(e, i[o], i[o + 1], n); r.add(s) } return r } }, mn.toIntArray = function (t) { for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)e[n] = t.get(n).intValue(); return e }; const xn = function () {}; xn.prototype.computeNodes = function (t) {}, xn.prototype.getNodedSubstrings = function () {}, xn.prototype.interfaces_ = function () { return [] }, xn.prototype.getClass = function () { return xn }; const bn = function () { if (this._segInt = null, arguments.length === 0);else if (arguments.length === 1) { const t = arguments[0]; this.setSegmentIntersector(t) } }; bn.prototype.setSegmentIntersector = function (t) { this._segInt = t }, bn.prototype.interfaces_ = function () { return [xn] }, bn.prototype.getClass = function () { return bn }; const En = (function (t) { function e (e) { e ? t.call(this, e) : t.call(this), this._monoChains = new wt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0 }t && (e.__proto__ = t), (e.prototype = Object.create(t && t.prototype)).constructor = e; const n = { SegmentOverlapAction: { configurable: !0 } }; return e.prototype.getMonotoneChains = function () { return this._monoChains }, e.prototype.getNodedSubstrings = function () { return gn.getNodedSubstrings(this._nodedSegStrings) }, e.prototype.getIndex = function () { return this._index }, e.prototype.add = function (t) { for (let e = mn.getChains(t.getCoordinates(), t).iterator(); e.hasNext();) { const n = e.next(); n.setId(this._idCounter++), this._index.insert(n.getEnvelope(), n), this._monoChains.add(n) } }, e.prototype.computeNodes = function (t) { this._nodedSegStrings = t; for (let e = t.iterator(); e.hasNext();) this.add(e.next()); this.intersectChains() }, e.prototype.intersectChains = function () { for (let t = new wn(this._segInt), e = this._monoChains.iterator(); e.hasNext();) for (let n = e.next(), r = this._index.query(n.getEnvelope()).iterator(); r.hasNext();) { const i = r.next(); if (i.getId() > n.getId() && (n.computeOverlaps(i, t), this._nOverlaps++), this._segInt.isDone()) return null } }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, n.SegmentOverlapAction.get = function () { return wn }, Object.defineProperties(e, n), e }(bn)); var wn = (function (t) { function e () { t.call(this), this._si = null; const e = arguments[0]; this._si = e } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.overlap = function () { if (arguments.length !== 4) return t.prototype.overlap.apply(this, arguments); const e = arguments[1]; const n = arguments[2]; const r = arguments[3]; const i = arguments[0].getContext(); const o = n.getContext(); this._si.processIntersections(i, e, o, r) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(vn)); const In = function t () { if (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t.CAP_ROUND, this._joinStyle = t.JOIN_ROUND, this._mitreLimit = t.DEFAULT_MITRE_LIMIT, this._isSingleSided = !1, this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR, arguments.length === 0);else if (arguments.length === 1) { const e = arguments[0]; this.setQuadrantSegments(e) } else if (arguments.length === 2) { const n = arguments[0]; const r = arguments[1]; this.setQuadrantSegments(n), this.setEndCapStyle(r) } else if (arguments.length === 4) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; const a = arguments[3]; this.setQuadrantSegments(i), this.setEndCapStyle(o), this.setJoinStyle(s), this.setMitreLimit(a) } }; const Sn = { CAP_ROUND: { configurable: !0 }, CAP_FLAT: { configurable: !0 }, CAP_SQUARE: { configurable: !0 }, JOIN_ROUND: { configurable: !0 }, JOIN_MITRE: { configurable: !0 }, JOIN_BEVEL: { configurable: !0 }, DEFAULT_QUADRANT_SEGMENTS: { configurable: !0 }, DEFAULT_MITRE_LIMIT: { configurable: !0 }, DEFAULT_SIMPLIFY_FACTOR: { configurable: !0 } }; In.prototype.getEndCapStyle = function () { return this._endCapStyle }, In.prototype.isSingleSided = function () { return this._isSingleSided }, In.prototype.setQuadrantSegments = function (t) { this._quadrantSegments = t, this._quadrantSegments === 0 && (this._joinStyle = In.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = In.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t <= 0 && (this._quadrantSegments = 1), this._joinStyle !== In.JOIN_ROUND && (this._quadrantSegments = In.DEFAULT_QUADRANT_SEGMENTS) }, In.prototype.getJoinStyle = function () { return this._joinStyle }, In.prototype.setJoinStyle = function (t) { this._joinStyle = t }, In.prototype.setSimplifyFactor = function (t) { this._simplifyFactor = t < 0 ? 0 : t }, In.prototype.getSimplifyFactor = function () { return this._simplifyFactor }, In.prototype.getQuadrantSegments = function () { return this._quadrantSegments }, In.prototype.setEndCapStyle = function (t) { this._endCapStyle = t }, In.prototype.getMitreLimit = function () { return this._mitreLimit }, In.prototype.setMitreLimit = function (t) { this._mitreLimit = t }, In.prototype.setSingleSided = function (t) { this._isSingleSided = t }, In.prototype.interfaces_ = function () { return [] }, In.prototype.getClass = function () { return In }, In.bufferDistanceError = function (t) { const e = Math.PI / 2 / t; return 1 - Math.cos(e / 2) }, Sn.CAP_ROUND.get = function () { return 1 }, Sn.CAP_FLAT.get = function () { return 2 }, Sn.CAP_SQUARE.get = function () { return 3 }, Sn.JOIN_ROUND.get = function () { return 1 }, Sn.JOIN_MITRE.get = function () { return 2 }, Sn.JOIN_BEVEL.get = function () { return 3 }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function () { return 8 }, Sn.DEFAULT_MITRE_LIMIT.get = function () { return 5 }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function () { return 0.01 }, Object.defineProperties(In, Sn); const Nn = function (t) { this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t || null }; const Pn = { INIT: { configurable: !0 }, DELETE: { configurable: !0 }, KEEP: { configurable: !0 }, NUM_PTS_TO_CHECK: { configurable: !0 } }; Nn.prototype.isDeletable = function (t, e, n, r) { const i = this._inputLine[t]; const o = this._inputLine[e]; const s = this._inputLine[n]; return !!this.isConcave(i, o, s) && !!this.isShallow(i, o, s, r) && this.isShallowSampled(i, o, t, n, r) }, Nn.prototype.deleteShallowConcavities = function () { for (var t = 1, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e), r = !1; n < this._inputLine.length;) { let i = !1; this.isDeletable(t, e, n, this._distanceTol) && (this._isDeleted[e] = Nn.DELETE, i = !0, r = !0), t = i ? n : e, e = this.findNextNonDeletedIndex(t), n = this.findNextNonDeletedIndex(e) } return r }, Nn.prototype.isShallowConcavity = function (t, e, n, r) { return at.computeOrientation(t, e, n) === this._angleOrientation && at.distancePointLine(e, t, n) < r }, Nn.prototype.isShallowSampled = function (t, e, n, r, i) { let o = Math.trunc((r - n) / Nn.NUM_PTS_TO_CHECK); o <= 0 && (o = 1); for (let s = n; s < r; s += o) if (!this.isShallow(t, e, this._inputLine[s], i)) return !1; return !0 }, Nn.prototype.isConcave = function (t, e, n) { return at.computeOrientation(t, e, n) === this._angleOrientation }, Nn.prototype.simplify = function (t) { this._distanceTol = Math.abs(t), t < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null); let e = !1; do { e = this.deleteShallowConcavities() } while (e); return this.collapseLine() }, Nn.prototype.findNextNonDeletedIndex = function (t) { for (var e = t + 1; e < this._inputLine.length && this._isDeleted[e] === Nn.DELETE;)e++; return e }, Nn.prototype.isShallow = function (t, e, n, r) { return at.distancePointLine(e, t, n) < r }, Nn.prototype.collapseLine = function () { for (var t = new St(), e = 0; e < this._inputLine.length; e++) this._isDeleted[e] !== Nn.DELETE && t.add(this._inputLine[e]); return t.toCoordinateArray() }, Nn.prototype.interfaces_ = function () { return [] }, Nn.prototype.getClass = function () { return Nn }, Nn.simplify = function (t, e) { return new Nn(t).simplify(e) }, Pn.INIT.get = function () { return 0 }, Pn.DELETE.get = function () { return 1 }, Pn.KEEP.get = function () { return 1 }, Pn.NUM_PTS_TO_CHECK.get = function () { return 10 }, Object.defineProperties(Nn, Pn); const Cn = function () { this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new wt() }; const Mn = { COORDINATE_ARRAY_TYPE: { configurable: !0 } }; Cn.prototype.getCoordinates = function () { return this._ptList.toArray(Cn.COORDINATE_ARRAY_TYPE) }, Cn.prototype.setPrecisionModel = function (t) { this._precisionModel = t }, Cn.prototype.addPt = function (t) { const e = new I(t); if (this._precisionModel.makePrecise(e), this.isRedundant(e)) return null; this._ptList.add(e) }, Cn.prototype.revere = function () {}, Cn.prototype.addPts = function (t, e) { if (e) for (let n = 0; n < t.length; n++) this.addPt(t[n]); else for (let r = t.length - 1; r >= 0; r--) this.addPt(t[r]) }, Cn.prototype.isRedundant = function (t) { if (this._ptList.size() < 1) return !1; const e = this._ptList.get(this._ptList.size() - 1); return t.distance(e) < this._minimimVertexDistance }, Cn.prototype.toString = function () { return (new ve()).createLineString(this.getCoordinates()).toString() }, Cn.prototype.closeRing = function () { if (this._ptList.size() < 1) return null; const t = new I(this._ptList.get(0)); const e = this._ptList.get(this._ptList.size() - 1); if (t.equals(e)) return null; this._ptList.add(t) }, Cn.prototype.setMinimumVertexDistance = function (t) { this._minimimVertexDistance = t }, Cn.prototype.interfaces_ = function () { return [] }, Cn.prototype.getClass = function () { return Cn }, Mn.COORDINATE_ARRAY_TYPE.get = function () { return new Array(0).fill(null) }, Object.defineProperties(Cn, Mn); const On = function () {}; const Ln = { PI_TIMES_2: { configurable: !0 }, PI_OVER_2: { configurable: !0 }, PI_OVER_4: { configurable: !0 }, COUNTERCLOCKWISE: { configurable: !0 }, CLOCKWISE: { configurable: !0 }, NONE: { configurable: !0 } }; On.prototype.interfaces_ = function () { return [] }, On.prototype.getClass = function () { return On }, On.toDegrees = function (t) { return 180 * t / Math.PI }, On.normalize = function (t) { for (;t > Math.PI;)t -= On.PI_TIMES_2; for (;t <= -Math.PI;)t += On.PI_TIMES_2; return t }, On.angle = function () { if (arguments.length === 1) { const t = arguments[0]; return Math.atan2(t.y, t.x) } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; const r = n.x - e.x; const i = n.y - e.y; return Math.atan2(i, r) } }, On.isAcute = function (t, e, n) { const r = t.x - e.x; const i = t.y - e.y; return r * (n.x - e.x) + i * (n.y - e.y) > 0 }, On.isObtuse = function (t, e, n) { const r = t.x - e.x; const i = t.y - e.y; return r * (n.x - e.x) + i * (n.y - e.y) < 0 }, On.interiorAngle = function (t, e, n) { const r = On.angle(e, t); const i = On.angle(e, n); return Math.abs(i - r) }, On.normalizePositive = function (t) { if (t < 0) { for (;t < 0;)t += On.PI_TIMES_2; t >= On.PI_TIMES_2 && (t = 0) } else { for (;t >= On.PI_TIMES_2;)t -= On.PI_TIMES_2; t < 0 && (t = 0) } return t }, On.angleBetween = function (t, e, n) { const r = On.angle(e, t); const i = On.angle(e, n); return On.diff(r, i) }, On.diff = function (t, e) { let n = null; return (n = t < e ? e - t : t - e) > Math.PI && (n = 2 * Math.PI - n), n }, On.toRadians = function (t) { return t * Math.PI / 180 }, On.getTurn = function (t, e) { const n = Math.sin(e - t); return n > 0 ? On.COUNTERCLOCKWISE : n < 0 ? On.CLOCKWISE : On.NONE }, On.angleBetweenOriented = function (t, e, n) { const r = On.angle(e, t); const i = On.angle(e, n) - r; return i <= -Math.PI ? i + On.PI_TIMES_2 : i > Math.PI ? i - On.PI_TIMES_2 : i }, Ln.PI_TIMES_2.get = function () { return 2 * Math.PI }, Ln.PI_OVER_2.get = function () { return Math.PI / 2 }, Ln.PI_OVER_4.get = function () { return Math.PI / 4 }, Ln.COUNTERCLOCKWISE.get = function () { return at.COUNTERCLOCKWISE }, Ln.CLOCKWISE.get = function () { return at.CLOCKWISE }, Ln.NONE.get = function () { return at.COLLINEAR }, Object.defineProperties(On, Ln); const Rn = function t () { this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = !1; const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; this._precisionModel = e, this._bufParams = n, this._li = new it(), this._filletAngleQuantum = Math.PI / 2 / n.getQuadrantSegments(), n.getQuadrantSegments() >= 8 && n.getJoinStyle() === In.JOIN_ROUND && (this._closingSegLengthFactor = t.MAX_CLOSING_SEG_LEN_FACTOR), this.init(r) }; const An = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: !0 }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: !0 }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: !0 }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: !0 } }; Rn.prototype.addNextSegment = function (t, e) { if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2)) return null; const n = at.computeOrientation(this._s0, this._s1, this._s2); const r = n === at.CLOCKWISE && this._side === Se.LEFT || n === at.COUNTERCLOCKWISE && this._side === Se.RIGHT; n === 0 ? this.addCollinear(e) : r ? this.addOutsideTurn(n, e) : this.addInsideTurn(n, e) }, Rn.prototype.addLineEndCap = function (t, e) { const n = new dn(t, e); const r = new dn(); this.computeOffsetSegment(n, Se.LEFT, this._distance, r); const i = new dn(); this.computeOffsetSegment(n, Se.RIGHT, this._distance, i); const o = e.x - t.x; const s = e.y - t.y; const a = Math.atan2(s, o); switch (this._bufParams.getEndCapStyle()) { case In.CAP_ROUND:this._segList.addPt(r.p1), this.addFilletArc(e, a + Math.PI / 2, a - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(i.p1); break; case In.CAP_FLAT:this._segList.addPt(r.p1), this._segList.addPt(i.p1); break; case In.CAP_SQUARE:var u = new I(); u.x = Math.abs(this._distance) * Math.cos(a), u.y = Math.abs(this._distance) * Math.sin(a); var l = new I(r.p1.x + u.x, r.p1.y + u.y); var c = new I(i.p1.x + u.x, i.p1.y + u.y); this._segList.addPt(l), this._segList.addPt(c) } }, Rn.prototype.getCoordinates = function () { return this._segList.getCoordinates() }, Rn.prototype.addMitreJoin = function (t, e, n, r) { let i = !0; let o = null; try { o = Y.intersection(e.p0, e.p1, n.p0, n.p1), (r <= 0 ? 1 : o.distance(t) / Math.abs(r)) > this._bufParams.getMitreLimit() && (i = !1) } catch (t) { if (!(t instanceof U)) throw t; o = new I(0, 0), i = !1 }i ? this._segList.addPt(o) : this.addLimitedMitreJoin(e, n, r, this._bufParams.getMitreLimit()) }, Rn.prototype.addFilletCorner = function (t, e, n, r, i) { const o = e.x - t.x; const s = e.y - t.y; let a = Math.atan2(s, o); const u = n.x - t.x; const l = n.y - t.y; const c = Math.atan2(l, u); r === at.CLOCKWISE ? a <= c && (a += 2 * Math.PI) : a >= c && (a -= 2 * Math.PI), this._segList.addPt(e), this.addFilletArc(t, a, c, r, i), this._segList.addPt(n) }, Rn.prototype.addOutsideTurn = function (t, e) { if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Rn.OFFSET_SEGMENT_SEPARATION_FACTOR) return this._segList.addPt(this._offset0.p1), null; this._bufParams.getJoinStyle() === In.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === In.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t, this._distance), this._segList.addPt(this._offset1.p0)) }, Rn.prototype.createSquare = function (t) { this._segList.addPt(new I(t.x + this._distance, t.y + this._distance)), this._segList.addPt(new I(t.x + this._distance, t.y - this._distance)), this._segList.addPt(new I(t.x - this._distance, t.y - this._distance)), this._segList.addPt(new I(t.x - this._distance, t.y + this._distance)), this._segList.closeRing() }, Rn.prototype.addSegments = function (t, e) { this._segList.addPts(t, e) }, Rn.prototype.addFirstSegment = function () { this._segList.addPt(this._offset1.p0) }, Rn.prototype.addLastSegment = function () { this._segList.addPt(this._offset1.p1) }, Rn.prototype.initSideSegments = function (t, e, n) { this._s1 = t, this._s2 = e, this._side = n, this._seg1.setCoordinates(t, e), this.computeOffsetSegment(this._seg1, n, this._distance, this._offset1) }, Rn.prototype.addLimitedMitreJoin = function (t, e, n, r) { const i = this._seg0.p1; const o = On.angle(i, this._seg0.p0); const s = On.angleBetweenOriented(this._seg0.p0, i, this._seg1.p1) / 2; const a = On.normalize(o + s); const u = On.normalize(a + Math.PI); const l = r * n; const c = n - l * Math.abs(Math.sin(s)); const f = i.x + l * Math.cos(u); const h = i.y + l * Math.sin(u); const p = new I(f, h); const g = new dn(i, p); const d = g.pointAlongOffset(1, c); const y = g.pointAlongOffset(1, -c); this._side === Se.LEFT ? (this._segList.addPt(d), this._segList.addPt(y)) : (this._segList.addPt(y), this._segList.addPt(d)) }, Rn.prototype.computeOffsetSegment = function (t, e, n, r) { const i = e === Se.LEFT ? 1 : -1; const o = t.p1.x - t.p0.x; const s = t.p1.y - t.p0.y; const a = Math.sqrt(o * o + s * s); const u = i * n * o / a; const l = i * n * s / a; r.p0.x = t.p0.x - l, r.p0.y = t.p0.y + u, r.p1.x = t.p1.x - l, r.p1.y = t.p1.y + u }, Rn.prototype.addFilletArc = function (t, e, n, r, i) { const o = r === at.CLOCKWISE ? -1 : 1; const s = Math.abs(e - n); const a = Math.trunc(s / this._filletAngleQuantum + 0.5); if (a < 1) return null; for (let u = s / a, l = 0, c = new I(); l < s;) { const f = e + o * l; c.x = t.x + i * Math.cos(f), c.y = t.y + i * Math.sin(f), this._segList.addPt(c), l += u } }, Rn.prototype.addInsideTurn = function (t, e) { if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection()) this._segList.addPt(this._li.getIntersection(0)); else if (this._hasNarrowConcaveAngle = !0, this._offset0.p1.distance(this._offset1.p0) < this._distance * Rn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) this._segList.addPt(this._offset0.p1); else { if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) { const n = new I((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1)); this._segList.addPt(n); const r = new I((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1)); this._segList.addPt(r) } else this._segList.addPt(this._s1); this._segList.addPt(this._offset1.p0) } }, Rn.prototype.createCircle = function (t) { const e = new I(t.x + this._distance, t.y); this._segList.addPt(e), this.addFilletArc(t, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing() }, Rn.prototype.addBevelJoin = function (t, e) { this._segList.addPt(t.p1), this._segList.addPt(e.p0) }, Rn.prototype.init = function (t) { this._distance = t, this._maxCurveSegmentError = t * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new Cn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t * Rn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR) }, Rn.prototype.addCollinear = function (t) { this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2), this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === In.JOIN_BEVEL || this._bufParams.getJoinStyle() === In.JOIN_MITRE ? (t && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance)) }, Rn.prototype.closeRing = function () { this._segList.closeRing() }, Rn.prototype.hasNarrowConcaveAngle = function () { return this._hasNarrowConcaveAngle }, Rn.prototype.interfaces_ = function () { return [] }, Rn.prototype.getClass = function () { return Rn }, An.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () { return 0.001 }, An.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 0.001 }, An.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1e-6 }, An.MAX_CLOSING_SEG_LEN_FACTOR.get = function () { return 80 }, Object.defineProperties(Rn, An); const Tn = function () { this._distance = 0, this._precisionModel = null, this._bufParams = null; const t = arguments[0]; const e = arguments[1]; this._precisionModel = t, this._bufParams = e }; Tn.prototype.getOffsetCurve = function (t, e) { if (this._distance = e, e === 0) return null; const n = e < 0; const r = Math.abs(e); const i = this.getSegGen(r); t.length <= 1 ? this.computePointCurve(t[0], i) : this.computeOffsetCurve(t, n, i); const o = i.getCoordinates(); return n && Nt.reverse(o), o }, Tn.prototype.computeSingleSidedBufferCurve = function (t, e, n) { const r = this.simplifyTolerance(this._distance); if (e) { n.addSegments(t, !0); const i = Nn.simplify(t, -r); const o = i.length - 1; n.initSideSegments(i[o], i[o - 1], Se.LEFT), n.addFirstSegment(); for (let s = o - 2; s >= 0; s--)n.addNextSegment(i[s], !0) } else { n.addSegments(t, !1); const a = Nn.simplify(t, r); const u = a.length - 1; n.initSideSegments(a[0], a[1], Se.LEFT), n.addFirstSegment(); for (let l = 2; l <= u; l++)n.addNextSegment(a[l], !0) }n.addLastSegment(), n.closeRing() }, Tn.prototype.computeRingBufferCurve = function (t, e, n) { let r = this.simplifyTolerance(this._distance); e === Se.RIGHT && (r = -r); const i = Nn.simplify(t, r); const o = i.length - 1; n.initSideSegments(i[o - 1], i[0], e); for (let s = 1; s <= o; s++) { const a = s !== 1; n.addNextSegment(i[s], a) }n.closeRing() }, Tn.prototype.computeLineBufferCurve = function (t, e) { const n = this.simplifyTolerance(this._distance); const r = Nn.simplify(t, n); const i = r.length - 1; e.initSideSegments(r[0], r[1], Se.LEFT); for (let o = 2; o <= i; o++)e.addNextSegment(r[o], !0); e.addLastSegment(), e.addLineEndCap(r[i - 1], r[i]); const s = Nn.simplify(t, -n); const a = s.length - 1; e.initSideSegments(s[a], s[a - 1], Se.LEFT); for (let u = a - 2; u >= 0; u--)e.addNextSegment(s[u], !0); e.addLastSegment(), e.addLineEndCap(s[1], s[0]), e.closeRing() }, Tn.prototype.computePointCurve = function (t, e) { switch (this._bufParams.getEndCapStyle()) { case In.CAP_ROUND:e.createCircle(t); break; case In.CAP_SQUARE:e.createSquare(t) } }, Tn.prototype.getLineCurve = function (t, e) { if (this._distance = e, e < 0 && !this._bufParams.isSingleSided()) return null; if (e === 0) return null; const n = Math.abs(e); const r = this.getSegGen(n); if (t.length <= 1) this.computePointCurve(t[0], r); else if (this._bufParams.isSingleSided()) { const i = e < 0; this.computeSingleSidedBufferCurve(t, i, r) } else this.computeLineBufferCurve(t, r); return r.getCoordinates() }, Tn.prototype.getBufferParameters = function () { return this._bufParams }, Tn.prototype.simplifyTolerance = function (t) { return t * this._bufParams.getSimplifyFactor() }, Tn.prototype.getRingCurve = function (t, e, n) { if (this._distance = n, t.length <= 2) return this.getLineCurve(t, n); if (n === 0) return Tn.copyCoordinates(t); const r = this.getSegGen(n); return this.computeRingBufferCurve(t, e, r), r.getCoordinates() }, Tn.prototype.computeOffsetCurve = function (t, e, n) { const r = this.simplifyTolerance(this._distance); if (e) { const i = Nn.simplify(t, -r); const o = i.length - 1; n.initSideSegments(i[o], i[o - 1], Se.LEFT), n.addFirstSegment(); for (let s = o - 2; s >= 0; s--)n.addNextSegment(i[s], !0) } else { const a = Nn.simplify(t, r); const u = a.length - 1; n.initSideSegments(a[0], a[1], Se.LEFT), n.addFirstSegment(); for (let l = 2; l <= u; l++)n.addNextSegment(a[l], !0) }n.addLastSegment() }, Tn.prototype.getSegGen = function (t) { return new Rn(this._precisionModel, this._bufParams, t) }, Tn.prototype.interfaces_ = function () { return [] }, Tn.prototype.getClass = function () { return Tn }, Tn.copyCoordinates = function (t) { for (var e = new Array(t.length).fill(null), n = 0; n < e.length; n++)e[n] = new I(t[n]); return e }; const Dn = function () { this._subgraphs = null, this._seg = new dn(), this._cga = new at(); const t = arguments[0]; this._subgraphs = t }; const Fn = { DepthSegment: { configurable: !0 } }; Dn.prototype.findStabbedSegments = function () { if (arguments.length === 1) { for (var t = arguments[0], e = new wt(), n = this._subgraphs.iterator(); n.hasNext();) { const r = n.next(); const i = r.getEnvelope(); t.y < i.getMinY() || t.y > i.getMaxY() || this.findStabbedSegments(t, r.getDirectedEdges(), e) } return e } if (arguments.length === 3) if (O(arguments[2], Et) && arguments[0] instanceof I && arguments[1] instanceof ze) { for (let o = arguments[0], s = arguments[1], a = arguments[2], u = s.getEdge().getCoordinates(), l = 0; l < u.length - 1; l++) if (this._seg.p0 = u[l], this._seg.p1 = u[l + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse(), !(Math.max(this._seg.p0.x, this._seg.p1.x) < o.x || this._seg.isHorizontal() || o.y < this._seg.p0.y || o.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o) === at.RIGHT)) { let c = s.getDepth(Se.LEFT); this._seg.p0.equals(u[l]) || (c = s.getDepth(Se.RIGHT)); const f = new jn(this._seg, c); a.add(f) } } else if (O(arguments[2], Et) && arguments[0] instanceof I && O(arguments[1], Et)) for (let h = arguments[0], p = arguments[2], g = arguments[1].iterator(); g.hasNext();) { const d = g.next(); d.isForward() && this.findStabbedSegments(h, d, p) } }, Dn.prototype.getDepth = function (t) { const e = this.findStabbedSegments(t); return e.size() === 0 ? 0 : $e.min(e)._leftDepth }, Dn.prototype.interfaces_ = function () { return [] }, Dn.prototype.getClass = function () { return Dn }, Fn.DepthSegment.get = function () { return jn }, Object.defineProperties(Dn, Fn); var jn = function () { this._upwardSeg = null, this._leftDepth = null; const t = arguments[0]; const e = arguments[1]; this._upwardSeg = new dn(t), this._leftDepth = e }; jn.prototype.compareTo = function (t) { const e = t; if (this._upwardSeg.minX() >= e._upwardSeg.maxX()) return 1; if (this._upwardSeg.maxX() <= e._upwardSeg.minX()) return -1; let n = this._upwardSeg.orientationIndex(e._upwardSeg); return n !== 0 || (n = -1 * e._upwardSeg.orientationIndex(this._upwardSeg)) != 0 ? n : this._upwardSeg.compareTo(e._upwardSeg) }, jn.prototype.compareX = function (t, e) { const n = t.p0.compareTo(e.p0); return n !== 0 ? n : t.p1.compareTo(e.p1) }, jn.prototype.toString = function () { return this._upwardSeg.toString() }, jn.prototype.interfaces_ = function () { return [b] }, jn.prototype.getClass = function () { return jn }; const kn = function (t, e, n) { this.p0 = t || null, this.p1 = e || null, this.p2 = n || null }; kn.prototype.area = function () { return kn.area(this.p0, this.p1, this.p2) }, kn.prototype.signedArea = function () { return kn.signedArea(this.p0, this.p1, this.p2) }, kn.prototype.interpolateZ = function (t) { if (t === null) throw new _('Supplied point is null.'); return kn.interpolateZ(t, this.p0, this.p1, this.p2) }, kn.prototype.longestSideLength = function () { return kn.longestSideLength(this.p0, this.p1, this.p2) }, kn.prototype.isAcute = function () { return kn.isAcute(this.p0, this.p1, this.p2) }, kn.prototype.circumcentre = function () { return kn.circumcentre(this.p0, this.p1, this.p2) }, kn.prototype.area3D = function () { return kn.area3D(this.p0, this.p1, this.p2) }, kn.prototype.centroid = function () { return kn.centroid(this.p0, this.p1, this.p2) }, kn.prototype.inCentre = function () { return kn.inCentre(this.p0, this.p1, this.p2) }, kn.prototype.interfaces_ = function () { return [] }, kn.prototype.getClass = function () { return kn }, kn.area = function (t, e, n) { return Math.abs(((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2) }, kn.signedArea = function (t, e, n) { return ((n.x - t.x) * (e.y - t.y) - (e.x - t.x) * (n.y - t.y)) / 2 }, kn.det = function (t, e, n, r) { return t * r - e * n }, kn.interpolateZ = function (t, e, n, r) { const i = e.x; const o = e.y; const s = n.x - i; const a = r.x - i; const u = n.y - o; const l = r.y - o; const c = s * l - a * u; const f = t.x - i; const h = t.y - o; const p = (l * f - a * h) / c; const g = (-u * f + s * h) / c; return e.z + p * (n.z - e.z) + g * (r.z - e.z) }, kn.longestSideLength = function (t, e, n) { const r = t.distance(e); const i = e.distance(n); const o = n.distance(t); let s = r; return i > s && (s = i), o > s && (s = o), s }, kn.isAcute = function (t, e, n) { return !!On.isAcute(t, e, n) && !!On.isAcute(e, n, t) && !!On.isAcute(n, t, e) }, kn.circumcentre = function (t, e, n) { const r = n.x; const i = n.y; const o = t.x - r; const s = t.y - i; const a = e.x - r; const u = e.y - i; const l = 2 * kn.det(o, s, a, u); const c = kn.det(s, o * o + s * s, u, a * a + u * u); const f = kn.det(o, o * o + s * s, a, a * a + u * u); return new I(r - c / l, i + f / l) }, kn.perpendicularBisector = function (t, e) { const n = e.x - t.x; const r = e.y - t.y; const i = new Y(t.x + n / 2, t.y + r / 2, 1); const o = new Y(t.x - r + n / 2, t.y + n + r / 2, 1); return new Y(i, o) }, kn.angleBisector = function (t, e, n) { const r = e.distance(t); const i = r / (r + e.distance(n)); const o = n.x - t.x; const s = n.y - t.y; return new I(t.x + i * o, t.y + i * s) }, kn.area3D = function (t, e, n) { const r = e.x - t.x; const i = e.y - t.y; const o = e.z - t.z; const s = n.x - t.x; const a = n.y - t.y; const u = n.z - t.z; const l = i * u - o * a; const c = o * s - r * u; const f = r * a - i * s; const h = l * l + c * c + f * f; return Math.sqrt(h) / 2 }, kn.centroid = function (t, e, n) { const r = (t.x + e.x + n.x) / 3; const i = (t.y + e.y + n.y) / 3; return new I(r, i) }, kn.inCentre = function (t, e, n) { const r = e.distance(n); const i = t.distance(n); const o = t.distance(e); const s = r + i + o; const a = (r * t.x + i * e.x + o * n.x) / s; const u = (r * t.y + i * e.y + o * n.y) / s; return new I(a, u) }; const Gn = function () { this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new wt(); const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; this._inputGeom = t, this._distance = e, this._curveBuilder = n }; Gn.prototype.addPoint = function (t) { if (this._distance <= 0) return null; const e = t.getCoordinates(); const n = this._curveBuilder.getLineCurve(e, this._distance); this.addCurve(n, C.EXTERIOR, C.INTERIOR) }, Gn.prototype.addPolygon = function (t) { let e = this._distance; let n = Se.LEFT; this._distance < 0 && (e = -this._distance, n = Se.RIGHT); const r = t.getExteriorRing(); const i = Nt.removeRepeatedPoints(r.getCoordinates()); if (this._distance < 0 && this.isErodedCompletely(r, this._distance)) return null; if (this._distance <= 0 && i.length < 3) return null; this.addPolygonRing(i, e, n, C.EXTERIOR, C.INTERIOR); for (let o = 0; o < t.getNumInteriorRing(); o++) { const s = t.getInteriorRingN(o); const a = Nt.removeRepeatedPoints(s.getCoordinates()); this._distance > 0 && this.isErodedCompletely(s, -this._distance) || this.addPolygonRing(a, e, Se.opposite(n), C.INTERIOR, C.EXTERIOR) } }, Gn.prototype.isTriangleErodedCompletely = function (t, e) { const n = new kn(t[0], t[1], t[2]); const r = n.inCentre(); return at.distancePointLine(r, n.p0, n.p1) < Math.abs(e) }, Gn.prototype.addLineString = function (t) { if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided()) return null; const e = Nt.removeRepeatedPoints(t.getCoordinates()); const n = this._curveBuilder.getLineCurve(e, this._distance); this.addCurve(n, C.EXTERIOR, C.INTERIOR) }, Gn.prototype.addCurve = function (t, e, n) { if (t === null || t.length < 2) return null; const r = new gn(t, new Re(0, C.BOUNDARY, e, n)); this._curveList.add(r) }, Gn.prototype.getCurves = function () { return this.add(this._inputGeom), this._curveList }, Gn.prototype.addPolygonRing = function (t, e, n, r, i) { if (e === 0 && t.length < ee.MINIMUM_VALID_SIZE) return null; let o = r; let s = i; t.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t) && (o = i, s = r, n = Se.opposite(n)); const a = this._curveBuilder.getRingCurve(t, n, e); this.addCurve(a, o, s) }, Gn.prototype.add = function (t) { if (t.isEmpty()) return null; t instanceof $t ? this.addPolygon(t) : t instanceof Jt ? this.addLineString(t) : t instanceof Kt ? this.addPoint(t) : (t instanceof te || t instanceof Ut || t instanceof ne || t instanceof zt) && this.addCollection(t) }, Gn.prototype.isErodedCompletely = function (t, e) { const n = t.getCoordinates(); if (n.length < 4) return e < 0; if (n.length === 4) return this.isTriangleErodedCompletely(n, e); const r = t.getEnvelopeInternal(); const i = Math.min(r.getHeight(), r.getWidth()); return e < 0 && 2 * Math.abs(e) > i }, Gn.prototype.addCollection = function (t) { for (let e = 0; e < t.getNumGeometries(); e++) { const n = t.getGeometryN(e); this.add(n) } }, Gn.prototype.interfaces_ = function () { return [] }, Gn.prototype.getClass = function () { return Gn }; const qn = function () {}; qn.prototype.locate = function (t) {}, qn.prototype.interfaces_ = function () { return [] }, qn.prototype.getClass = function () { return qn }; const Bn = function () { this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null; const t = arguments[0]; this._parent = t, this._atStart = !0, this._index = 0, this._max = t.getNumGeometries() }; Bn.prototype.next = function () { if (this._atStart) return this._atStart = !1, Bn.isAtomic(this._parent) && this._index++, this._parent; if (this._subcollectionIterator !== null) { if (this._subcollectionIterator.hasNext()) return this._subcollectionIterator.next(); this._subcollectionIterator = null } if (this._index >= this._max) throw new r(); const t = this._parent.getGeometryN(this._index++); return t instanceof zt ? (this._subcollectionIterator = new Bn(t), this._subcollectionIterator.next()) : t }, Bn.prototype.remove = function () { throw new Error(this.getClass().getName()) }, Bn.prototype.hasNext = function () { if (this._atStart) return !0; if (this._subcollectionIterator !== null) { if (this._subcollectionIterator.hasNext()) return !0; this._subcollectionIterator = null } return !(this._index >= this._max) }, Bn.prototype.interfaces_ = function () { return [bt] }, Bn.prototype.getClass = function () { return Bn }, Bn.isAtomic = function (t) { return !(t instanceof zt) }; const zn = function () { this._geom = null; const t = arguments[0]; this._geom = t }; zn.prototype.locate = function (t) { return zn.locate(t, this._geom) }, zn.prototype.interfaces_ = function () { return [qn] }, zn.prototype.getClass = function () { return zn }, zn.isPointInRing = function (t, e) { return !!e.getEnvelopeInternal().intersects(t) && at.isPointInRing(t, e.getCoordinates()) }, zn.containsPointInPolygon = function (t, e) { if (e.isEmpty()) return !1; const n = e.getExteriorRing(); if (!zn.isPointInRing(t, n)) return !1; for (let r = 0; r < e.getNumInteriorRing(); r++) { const i = e.getInteriorRingN(r); if (zn.isPointInRing(t, i)) return !1 } return !0 }, zn.containsPoint = function (t, e) { if (e instanceof $t) return zn.containsPointInPolygon(t, e); if (e instanceof zt) for (let n = new Bn(e); n.hasNext();) { const r = n.next(); if (r !== e && zn.containsPoint(t, r)) return !0 } return !1 }, zn.locate = function (t, e) { return e.isEmpty() ? C.EXTERIOR : zn.containsPoint(t, e) ? C.INTERIOR : C.EXTERIOR }; const Un = function () { this._edgeMap = new f(), this._edgeList = null, this._ptInAreaLocation = [C.NONE, C.NONE] }; Un.prototype.getNextCW = function (t) { this.getEdges(); const e = this._edgeList.indexOf(t); let n = e - 1; return e === 0 && (n = this._edgeList.size() - 1), this._edgeList.get(n) }, Un.prototype.propagateSideLabels = function (t) { for (var e = C.NONE, n = this.iterator(); n.hasNext();) { const r = n.next().getLabel(); r.isArea(t) && r.getLocation(t, Se.LEFT) !== C.NONE && (e = r.getLocation(t, Se.LEFT)) } if (e === C.NONE) return null; for (let i = e, o = this.iterator(); o.hasNext();) { const s = o.next(); const a = s.getLabel(); if (a.getLocation(t, Se.ON) === C.NONE && a.setLocation(t, Se.ON, i), a.isArea(t)) { const u = a.getLocation(t, Se.LEFT); const l = a.getLocation(t, Se.RIGHT); if (l !== C.NONE) { if (l !== i) throw new Ce('side location conflict', s.getCoordinate()); u === C.NONE && et.shouldNeverReachHere('found single null side (at ' + s.getCoordinate() + ')'), i = u } else et.isTrue(a.getLocation(t, Se.LEFT) === C.NONE, 'found single null side'), a.setLocation(t, Se.RIGHT, i), a.setLocation(t, Se.LEFT, i) } } }, Un.prototype.getCoordinate = function () { const t = this.iterator(); return t.hasNext() ? t.next().getCoordinate() : null }, Un.prototype.print = function (t) { X.out.println('EdgeEndStar:   ' + this.getCoordinate()); for (let e = this.iterator(); e.hasNext();)e.next().print(t) }, Un.prototype.isAreaLabelsConsistent = function (t) { return this.computeEdgeEndLabels(t.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0) }, Un.prototype.checkAreaLabelsConsistent = function (t) { const e = this.getEdges(); if (e.size() <= 0) return !0; const n = e.size() - 1; const r = e.get(n).getLabel().getLocation(t, Se.LEFT); et.isTrue(r !== C.NONE, 'Found unlabelled area edge'); for (let i = r, o = this.iterator(); o.hasNext();) { const s = o.next().getLabel(); et.isTrue(s.isArea(t), 'Found non-area edge'); const a = s.getLocation(t, Se.LEFT); const u = s.getLocation(t, Se.RIGHT); if (a === u) return !1; if (u !== i) return !1; i = a } return !0 }, Un.prototype.findIndex = function (t) { this.iterator(); for (let e = 0; e < this._edgeList.size(); e++) if (this._edgeList.get(e) === t) return e; return -1 }, Un.prototype.iterator = function () { return this.getEdges().iterator() }, Un.prototype.getEdges = function () { return this._edgeList === null && (this._edgeList = new wt(this._edgeMap.values())), this._edgeList }, Un.prototype.getLocation = function (t, e, n) { return this._ptInAreaLocation[t] === C.NONE && (this._ptInAreaLocation[t] = zn.locate(e, n[t].getGeometry())), this._ptInAreaLocation[t] }, Un.prototype.toString = function () { const t = new A(); t.append('EdgeEndStar:   ' + this.getCoordinate()), t.append('\n'); for (let e = this.iterator(); e.hasNext();) { const n = e.next(); t.append(n), t.append('\n') } return t.toString() }, Un.prototype.computeEdgeEndLabels = function (t) { for (let e = this.iterator(); e.hasNext();)e.next().computeLabel(t) }, Un.prototype.computeLabelling = function (t) { this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1); for (var e = [!1, !1], n = this.iterator(); n.hasNext();) for (let r = n.next().getLabel(), i = 0; i < 2; i++)r.isLine(i) && r.getLocation(i) === C.BOUNDARY && (e[i] = !0); for (let o = this.iterator(); o.hasNext();) for (let s = o.next(), a = s.getLabel(), u = 0; u < 2; u++) if (a.isAnyNull(u)) { let l = C.NONE; if (e[u])l = C.EXTERIOR; else { const c = s.getCoordinate(); l = this.getLocation(u, c, t) }a.setAllLocationsIfNull(u, l) } }, Un.prototype.getDegree = function () { return this._edgeMap.size() }, Un.prototype.insertEdgeEnd = function (t, e) { this._edgeMap.put(t, e), this._edgeList = null }, Un.prototype.interfaces_ = function () { return [] }, Un.prototype.getClass = function () { return Un }; const Xn = (function (t) { function e () { t.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2 } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.linkResultDirectedEdges = function () { this.getResultAreaEdges(); for (var t = null, e = null, n = this._SCANNING_FOR_INCOMING, r = 0; r < this._resultAreaEdgeList.size(); r++) { const i = this._resultAreaEdgeList.get(r); const o = i.getSym(); if (i.getLabel().isArea()) switch (t === null && i.isInResult() && (t = i), n) { case this._SCANNING_FOR_INCOMING:if (!o.isInResult()) continue; e = o, n = this._LINKING_TO_OUTGOING; break; case this._LINKING_TO_OUTGOING:if (!i.isInResult()) continue; e.setNext(i), n = this._SCANNING_FOR_INCOMING } } if (n === this._LINKING_TO_OUTGOING) { if (t === null) throw new Ce('no outgoing dirEdge found', this.getCoordinate()); et.isTrue(t.isInResult(), 'unable to link last incoming dirEdge'), e.setNext(t) } }, e.prototype.insert = function (t) { const e = t; this.insertEdgeEnd(e, e) }, e.prototype.getRightmostEdge = function () { const t = this.getEdges(); const e = t.size(); if (e < 1) return null; const n = t.get(0); if (e === 1) return n; const r = t.get(e - 1); const i = n.getQuadrant(); const o = r.getQuadrant(); return Ge.isNorthern(i) && Ge.isNorthern(o) ? n : Ge.isNorthern(i) || Ge.isNorthern(o) ? n.getDy() !== 0 ? n : r.getDy() !== 0 ? r : (et.shouldNeverReachHere('found two horizontal edges incident on node'), null) : r }, e.prototype.print = function (t) { X.out.println('DirectedEdgeStar: ' + this.getCoordinate()); for (let e = this.iterator(); e.hasNext();) { const n = e.next(); t.print('out '), n.print(t), t.println(), t.print('in '), n.getSym().print(t), t.println() } }, e.prototype.getResultAreaEdges = function () { if (this._resultAreaEdgeList !== null) return this._resultAreaEdgeList; this._resultAreaEdgeList = new wt(); for (let t = this.iterator(); t.hasNext();) { const e = t.next(); (e.isInResult() || e.getSym().isInResult()) && this._resultAreaEdgeList.add(e) } return this._resultAreaEdgeList }, e.prototype.updateLabelling = function (t) { for (let e = this.iterator(); e.hasNext();) { const n = e.next().getLabel(); n.setAllLocationsIfNull(0, t.getLocation(0)), n.setAllLocationsIfNull(1, t.getLocation(1)) } }, e.prototype.linkAllDirectedEdges = function () { this.getEdges(); for (var t = null, e = null, n = this._edgeList.size() - 1; n >= 0; n--) { const r = this._edgeList.get(n); const i = r.getSym(); e === null && (e = i), t !== null && i.setNext(t), t = r }e.setNext(t) }, e.prototype.computeDepths = function () { if (arguments.length === 1) { const t = arguments[0]; const e = this.findIndex(t); const n = t.getDepth(Se.LEFT); const r = t.getDepth(Se.RIGHT); const i = this.computeDepths(e + 1, this._edgeList.size(), n); if (this.computeDepths(0, e, i) !== r) throw new Ce('depth mismatch at ' + t.getCoordinate()) } else if (arguments.length === 3) { for (var o = arguments[1], s = arguments[2], a = arguments[0]; a < o; a++) { const u = this._edgeList.get(a); u.setEdgeDepths(Se.RIGHT, s), s = u.getDepth(Se.LEFT) } return s } }, e.prototype.mergeSymLabels = function () { for (let t = this.iterator(); t.hasNext();) { const e = t.next(); e.getLabel().merge(e.getSym().getLabel()) } }, e.prototype.linkMinimalDirectedEdges = function (t) { for (var e = null, n = null, r = this._SCANNING_FOR_INCOMING, i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) { const o = this._resultAreaEdgeList.get(i); const s = o.getSym(); switch (e === null && o.getEdgeRing() === t && (e = o), r) { case this._SCANNING_FOR_INCOMING:if (s.getEdgeRing() !== t) continue; n = s, r = this._LINKING_TO_OUTGOING; break; case this._LINKING_TO_OUTGOING:if (o.getEdgeRing() !== t) continue; n.setNextMin(o), r = this._SCANNING_FOR_INCOMING } }r === this._LINKING_TO_OUTGOING && (et.isTrue(e !== null, 'found null for first outgoing dirEdge'), et.isTrue(e.getEdgeRing() === t, 'unable to link last incoming dirEdge'), n.setNextMin(e)) }, e.prototype.getOutgoingDegree = function () { if (arguments.length === 0) { for (var t = 0, e = this.iterator(); e.hasNext();)e.next().isInResult() && t++; return t } if (arguments.length === 1) { for (var n = arguments[0], r = 0, i = this.iterator(); i.hasNext();)i.next().getEdgeRing() === n && r++; return r } }, e.prototype.getLabel = function () { return this._label }, e.prototype.findCoveredLineEdges = function () { for (var t = C.NONE, e = this.iterator(); e.hasNext();) { const n = e.next(); const r = n.getSym(); if (!n.isLineEdge()) { if (n.isInResult()) { t = C.INTERIOR; break } if (r.isInResult()) { t = C.EXTERIOR; break } } } if (t === C.NONE) return null; for (let i = t, o = this.iterator(); o.hasNext();) { const s = o.next(); const a = s.getSym(); s.isLineEdge() ? s.getEdge().setCovered(i === C.INTERIOR) : (s.isInResult() && (i = C.EXTERIOR), a.isInResult() && (i = C.INTERIOR)) } }, e.prototype.computeLabelling = function (e) { t.prototype.computeLabelling.call(this, e), this._label = new Re(C.NONE); for (let n = this.iterator(); n.hasNext();) for (let r = n.next().getEdge().getLabel(), i = 0; i < 2; i++) { const o = r.getLocation(i); o !== C.INTERIOR && o !== C.BOUNDARY || this._label.setLocation(i, C.INTERIOR) } }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Un)); const Yn = (function (t) { function e () { t.apply(this, arguments) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.createNode = function (t) { return new je(t, new Xn()) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Ue)); const Vn = function t () { this._pts = null, this._orientation = null; const e = arguments[0]; this._pts = e, this._orientation = t.orientation(e) }; Vn.prototype.compareTo = function (t) { const e = t; return Vn.compareOriented(this._pts, this._orientation, e._pts, e._orientation) }, Vn.prototype.interfaces_ = function () { return [b] }, Vn.prototype.getClass = function () { return Vn }, Vn.orientation = function (t) { return Nt.increasingDirection(t) === 1 }, Vn.compareOriented = function (t, e, n, r) { for (let i = e ? 1 : -1, o = r ? 1 : -1, s = e ? t.length : -1, a = r ? n.length : -1, u = e ? 0 : t.length - 1, l = r ? 0 : n.length - 1; ;) { const c = t[u].compareTo(n[l]); if (c !== 0) return c; const f = (u += i) === s; const h = (l += o) === a; if (f && !h) return -1; if (!f && h) return 1; if (f && h) return 0 } }; const Wn = function () { this._edges = new wt(), this._ocaMap = new f() }; Wn.prototype.print = function (t) { t.print('MULTILINESTRING ( '); for (let e = 0; e < this._edges.size(); e++) { const n = this._edges.get(e); e > 0 && t.print(','), t.print('('); for (let r = n.getCoordinates(), i = 0; i < r.length; i++)i > 0 && t.print(','), t.print(r[i].x + ' ' + r[i].y); t.println(')') }t.print(')  ') }, Wn.prototype.addAll = function (t) { for (let e = t.iterator(); e.hasNext();) this.add(e.next()) }, Wn.prototype.findEdgeIndex = function (t) { for (let e = 0; e < this._edges.size(); e++) if (this._edges.get(e).equals(t)) return e; return -1 }, Wn.prototype.iterator = function () { return this._edges.iterator() }, Wn.prototype.getEdges = function () { return this._edges }, Wn.prototype.get = function (t) { return this._edges.get(t) }, Wn.prototype.findEqualEdge = function (t) { const e = new Vn(t.getCoordinates()); return this._ocaMap.get(e) }, Wn.prototype.add = function (t) { this._edges.add(t); const e = new Vn(t.getCoordinates()); this._ocaMap.put(e, t) }, Wn.prototype.interfaces_ = function () { return [] }, Wn.prototype.getClass = function () { return Wn }; const Hn = function () {}; Hn.prototype.processIntersections = function (t, e, n, r) {}, Hn.prototype.isDone = function () {}, Hn.prototype.interfaces_ = function () { return [] }, Hn.prototype.getClass = function () { return Hn }; const Jn = function () { this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._hasInterior = !1, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0; const t = arguments[0]; this._li = t }; Jn.prototype.isTrivialIntersection = function (t, e, n, r) { if (t === n && this._li.getIntersectionNum() === 1) { if (Jn.isAdjacentSegments(e, r)) return !0; if (t.isClosed()) { const i = t.size() - 1; if (e === 0 && r === i || r === 0 && e === i) return !0 } } return !1 }, Jn.prototype.getProperIntersectionPoint = function () { return this._properIntersectionPoint }, Jn.prototype.hasProperInteriorIntersection = function () { return this._hasProperInterior }, Jn.prototype.getLineIntersector = function () { return this._li }, Jn.prototype.hasProperIntersection = function () { return this._hasProper }, Jn.prototype.processIntersections = function (t, e, n, r) { if (t === n && e === r) return null; this.numTests++; const i = t.getCoordinates()[e]; const o = t.getCoordinates()[e + 1]; const s = n.getCoordinates()[r]; const a = n.getCoordinates()[r + 1]; this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = !0), this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = !0, this._hasProperInterior = !0))) }, Jn.prototype.hasIntersection = function () { return this._hasIntersection }, Jn.prototype.isDone = function () { return !1 }, Jn.prototype.hasInteriorIntersection = function () { return this._hasInterior }, Jn.prototype.interfaces_ = function () { return [Hn] }, Jn.prototype.getClass = function () { return Jn }, Jn.isAdjacentSegments = function (t, e) { return Math.abs(t - e) === 1 }; const Zn = function () { this.coord = null, this.segmentIndex = null, this.dist = null; const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; this.coord = new I(t), this.segmentIndex = e, this.dist = n }; Zn.prototype.getSegmentIndex = function () { return this.segmentIndex }, Zn.prototype.getCoordinate = function () { return this.coord }, Zn.prototype.print = function (t) { t.print(this.coord), t.print(' seg # = ' + this.segmentIndex), t.println(' dist = ' + this.dist) }, Zn.prototype.compareTo = function (t) { const e = t; return this.compare(e.segmentIndex, e.dist) }, Zn.prototype.isEndPoint = function (t) { return this.segmentIndex === 0 && this.dist === 0 || this.segmentIndex === t }, Zn.prototype.toString = function () { return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist }, Zn.prototype.getDistance = function () { return this.dist }, Zn.prototype.compare = function (t, e) { return this.segmentIndex < t ? -1 : this.segmentIndex > t ? 1 : this.dist < e ? -1 : this.dist > e ? 1 : 0 }, Zn.prototype.interfaces_ = function () { return [b] }, Zn.prototype.getClass = function () { return Zn }; const Kn = function () { this._nodeMap = new f(), this.edge = null; const t = arguments[0]; this.edge = t }; Kn.prototype.print = function (t) { t.println('Intersections:'); for (let e = this.iterator(); e.hasNext();)e.next().print(t) }, Kn.prototype.iterator = function () { return this._nodeMap.values().iterator() }, Kn.prototype.addSplitEdges = function (t) { this.addEndpoints(); for (let e = this.iterator(), n = e.next(); e.hasNext();) { const r = e.next(); const i = this.createSplitEdge(n, r); t.add(i), n = r } }, Kn.prototype.addEndpoints = function () { const t = this.edge.pts.length - 1; this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t], t, 0) }, Kn.prototype.createSplitEdge = function (t, e) { let n = e.segmentIndex - t.segmentIndex + 2; const r = this.edge.pts[e.segmentIndex]; const i = e.dist > 0 || !e.coord.equals2D(r); i || n--; const o = new Array(n).fill(null); let s = 0; o[s++] = new I(t.coord); for (let a = t.segmentIndex + 1; a <= e.segmentIndex; a++)o[s++] = this.edge.pts[a]; return i && (o[s] = e.coord), new nr(o, new Re(this.edge._label)) }, Kn.prototype.add = function (t, e, n) { const r = new Zn(t, e, n); const i = this._nodeMap.get(r); return i !== null ? i : (this._nodeMap.put(r, r), r) }, Kn.prototype.isIntersection = function (t) { for (let e = this.iterator(); e.hasNext();) if (e.next().coord.equals(t)) return !0; return !1 }, Kn.prototype.interfaces_ = function () { return [] }, Kn.prototype.getClass = function () { return Kn }; const Qn = function () {}; Qn.prototype.getChainStartIndices = function (t) { let e = 0; const n = new wt(); n.add(new T(e)); do { const r = this.findChainEnd(t, e); n.add(new T(r)), e = r } while (e < t.length - 1); return Qn.toIntArray(n) }, Qn.prototype.findChainEnd = function (t, e) { for (var n = Ge.quadrant(t[e], t[e + 1]), r = e + 1; r < t.length && Ge.quadrant(t[r - 1], t[r]) === n;)r++; return r - 1 }, Qn.prototype.interfaces_ = function () { return [] }, Qn.prototype.getClass = function () { return Qn }, Qn.toIntArray = function (t) { for (var e = new Array(t.size()).fill(null), n = 0; n < e.length; n++)e[n] = t.get(n).intValue(); return e }; const $n = function () { this.e = null, this.pts = null, this.startIndex = null, this.env1 = new V(), this.env2 = new V(); const t = arguments[0]; this.e = t, this.pts = t.getCoordinates(); const e = new Qn(); this.startIndex = e.getChainStartIndices(this.pts) }; $n.prototype.getCoordinates = function () { return this.pts }, $n.prototype.getMaxX = function (t) { const e = this.pts[this.startIndex[t]].x; const n = this.pts[this.startIndex[t + 1]].x; return e > n ? e : n }, $n.prototype.getMinX = function (t) { const e = this.pts[this.startIndex[t]].x; const n = this.pts[this.startIndex[t + 1]].x; return e < n ? e : n }, $n.prototype.computeIntersectsForChain = function () { if (arguments.length === 4) { const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; const r = arguments[3]; this.computeIntersectsForChain(this.startIndex[t], this.startIndex[t + 1], e, e.startIndex[n], e.startIndex[n + 1], r) } else if (arguments.length === 6) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; const a = arguments[3]; const u = arguments[4]; const l = arguments[5]; const c = this.pts[i]; const f = this.pts[o]; const h = s.pts[a]; const p = s.pts[u]; if (o - i == 1 && u - a == 1) return l.addIntersections(this.e, i, s.e, a), null; if (this.env1.init(c, f), this.env2.init(h, p), !this.env1.intersects(this.env2)) return null; const g = Math.trunc((i + o) / 2); const d = Math.trunc((a + u) / 2); i < g && (a < d && this.computeIntersectsForChain(i, g, s, a, d, l), d < u && this.computeIntersectsForChain(i, g, s, d, u, l)), g < o && (a < d && this.computeIntersectsForChain(g, o, s, a, d, l), d < u && this.computeIntersectsForChain(g, o, s, d, u, l)) } }, $n.prototype.getStartIndexes = function () { return this.startIndex }, $n.prototype.computeIntersects = function (t, e) { for (let n = 0; n < this.startIndex.length - 1; n++) for (let r = 0; r < t.startIndex.length - 1; r++) this.computeIntersectsForChain(n, t, r, e) }, $n.prototype.interfaces_ = function () { return [] }, $n.prototype.getClass = function () { return $n }; const tr = function t () { this._depth = Array(2).fill().map(function () { return Array(3) }); for (let e = 0; e < 2; e++) for (let n = 0; n < 3; n++) this._depth[e][n] = t.NULL_VALUE }; const er = { NULL_VALUE: { configurable: !0 } }; tr.prototype.getDepth = function (t, e) { return this._depth[t][e] }, tr.prototype.setDepth = function (t, e, n) { this._depth[t][e] = n }, tr.prototype.isNull = function () { if (arguments.length === 0) { for (let t = 0; t < 2; t++) for (let e = 0; e < 3; e++) if (this._depth[t][e] !== tr.NULL_VALUE) return !1; return !0 } if (arguments.length === 1) { const n = arguments[0]; return this._depth[n][1] === tr.NULL_VALUE } if (arguments.length === 2) { const r = arguments[0]; const i = arguments[1]; return this._depth[r][i] === tr.NULL_VALUE } }, tr.prototype.normalize = function () { for (let t = 0; t < 2; t++) if (!this.isNull(t)) { let e = this._depth[t][1]; this._depth[t][2] < e && (e = this._depth[t][2]), e < 0 && (e = 0); for (let n = 1; n < 3; n++) { let r = 0; this._depth[t][n] > e && (r = 1), this._depth[t][n] = r } } }, tr.prototype.getDelta = function (t) { return this._depth[t][Se.RIGHT] - this._depth[t][Se.LEFT] }, tr.prototype.getLocation = function (t, e) { return this._depth[t][e] <= 0 ? C.EXTERIOR : C.INTERIOR }, tr.prototype.toString = function () { return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2] }, tr.prototype.add = function () { if (arguments.length === 1) for (let t = arguments[0], e = 0; e < 2; e++) for (let n = 1; n < 3; n++) { const r = t.getLocation(e, n); r !== C.EXTERIOR && r !== C.INTERIOR || (this.isNull(e, n) ? this._depth[e][n] = tr.depthAtLocation(r) : this._depth[e][n] += tr.depthAtLocation(r)) } else if (arguments.length === 3) { const i = arguments[0]; const o = arguments[1]; arguments[2] === C.INTERIOR && this._depth[i][o]++ } }, tr.prototype.interfaces_ = function () { return [] }, tr.prototype.getClass = function () { return tr }, tr.depthAtLocation = function (t) { return t === C.EXTERIOR ? 0 : t === C.INTERIOR ? 1 : tr.NULL_VALUE }, er.NULL_VALUE.get = function () { return -1 }, Object.defineProperties(tr, er); var nr = (function (t) { function e () { if (t.call(this), this.pts = null, this._env = null, this.eiList = new Kn(this), this._name = null, this._mce = null, this._isIsolated = !0, this._depth = new tr(), this._depthDelta = 0, arguments.length === 1) { const n = arguments[0]; e.call(this, n, null) } else if (arguments.length === 2) { const r = arguments[0]; const i = arguments[1]; this.pts = r, this._label = i } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.getDepth = function () { return this._depth }, e.prototype.getCollapsedEdge = function () { const t = new Array(2).fill(null); return t[0] = this.pts[0], t[1] = this.pts[1], new e(t, Re.toLineLabel(this._label)) }, e.prototype.isIsolated = function () { return this._isIsolated }, e.prototype.getCoordinates = function () { return this.pts }, e.prototype.setIsolated = function (t) { this._isIsolated = t }, e.prototype.setName = function (t) { this._name = t }, e.prototype.equals = function (t) { if (!(t instanceof e)) return !1; const n = t; if (this.pts.length !== n.pts.length) return !1; for (let r = !0, i = !0, o = this.pts.length, s = 0; s < this.pts.length; s++) if (this.pts[s].equals2D(n.pts[s]) || (r = !1), this.pts[s].equals2D(n.pts[--o]) || (i = !1), !r && !i) return !1; return !0 }, e.prototype.getCoordinate = function () { if (arguments.length === 0) return this.pts.length > 0 ? this.pts[0] : null; if (arguments.length === 1) { const t = arguments[0]; return this.pts[t] } }, e.prototype.print = function (t) { t.print('edge ' + this._name + ': '), t.print('LINESTRING ('); for (let e = 0; e < this.pts.length; e++)e > 0 && t.print(','), t.print(this.pts[e].x + ' ' + this.pts[e].y); t.print(')  ' + this._label + ' ' + this._depthDelta) }, e.prototype.computeIM = function (t) { e.updateIM(this._label, t) }, e.prototype.isCollapsed = function () { return !!this._label.isArea() && this.pts.length === 3 && !!this.pts[0].equals(this.pts[2]) }, e.prototype.isClosed = function () { return this.pts[0].equals(this.pts[this.pts.length - 1]) }, e.prototype.getMaximumSegmentIndex = function () { return this.pts.length - 1 }, e.prototype.getDepthDelta = function () { return this._depthDelta }, e.prototype.getNumPoints = function () { return this.pts.length }, e.prototype.printReverse = function (t) { t.print('edge ' + this._name + ': '); for (let e = this.pts.length - 1; e >= 0; e--)t.print(this.pts[e] + ' '); t.println('') }, e.prototype.getMonotoneChainEdge = function () { return this._mce === null && (this._mce = new $n(this)), this._mce }, e.prototype.getEnvelope = function () { if (this._env === null) { this._env = new V(); for (let t = 0; t < this.pts.length; t++) this._env.expandToInclude(this.pts[t]) } return this._env }, e.prototype.addIntersection = function (t, e, n, r) { const i = new I(t.getIntersection(r)); let o = e; let s = t.getEdgeDistance(n, r); const a = o + 1; if (a < this.pts.length) { const u = this.pts[a]; i.equals2D(u) && (o = a, s = 0) } this.eiList.add(i, o, s) }, e.prototype.toString = function () { const t = new A(); t.append('edge ' + this._name + ': '), t.append('LINESTRING ('); for (let e = 0; e < this.pts.length; e++)e > 0 && t.append(','), t.append(this.pts[e].x + ' ' + this.pts[e].y); return t.append(')  ' + this._label + ' ' + this._depthDelta), t.toString() }, e.prototype.isPointwiseEqual = function (t) { if (this.pts.length !== t.pts.length) return !1; for (let e = 0; e < this.pts.length; e++) if (!this.pts[e].equals2D(t.pts[e])) return !1; return !0 }, e.prototype.setDepthDelta = function (t) { this._depthDelta = t }, e.prototype.getEdgeIntersectionList = function () { return this.eiList }, e.prototype.addIntersections = function (t, e, n) { for (let r = 0; r < t.getIntersectionNum(); r++) this.addIntersection(t, e, n, r) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e.updateIM = function () { if (arguments.length !== 2) return t.prototype.updateIM.apply(this, arguments); const e = arguments[0]; const n = arguments[1]; n.setAtLeastIfValid(e.getLocation(0, Se.ON), e.getLocation(1, Se.ON), 1), e.isArea() && (n.setAtLeastIfValid(e.getLocation(0, Se.LEFT), e.getLocation(1, Se.LEFT), 2), n.setAtLeastIfValid(e.getLocation(0, Se.RIGHT), e.getLocation(1, Se.RIGHT), 2)) }, e }(Fe)); const rr = function (t) { this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Wn(), this._bufParams = t || null }; rr.prototype.setWorkingPrecisionModel = function (t) { this._workingPrecisionModel = t }, rr.prototype.insertUniqueEdge = function (t) { const e = this._edgeList.findEqualEdge(t); if (e !== null) { const n = e.getLabel(); let r = t.getLabel(); e.isPointwiseEqual(t) || (r = new Re(t.getLabel())).flip(), n.merge(r); const i = rr.depthDelta(r); const o = e.getDepthDelta() + i; e.setDepthDelta(o) } else this._edgeList.add(t), t.setDepthDelta(rr.depthDelta(t.getLabel())) }, rr.prototype.buildSubgraphs = function (t, e) { for (let n = new wt(), r = t.iterator(); r.hasNext();) { const i = r.next(); const o = i.getRightmostCoordinate(); const s = new Dn(n).getDepth(o); i.computeDepth(s), i.findResultEdges(), n.add(i), e.add(i.getDirectedEdges(), i.getNodes()) } }, rr.prototype.createSubgraphs = function (t) { for (var e = new wt(), n = t.getNodes().iterator(); n.hasNext();) { const r = n.next(); if (!r.isVisited()) { const i = new Oe(); i.create(r), e.add(i) } } return $e.sort(e, $e.reverseOrder()), e }, rr.prototype.createEmptyResultGeometry = function () { return this._geomFact.createPolygon() }, rr.prototype.getNoder = function (t) { if (this._workingNoder !== null) return this._workingNoder; const e = new En(); const n = new it(); return n.setPrecisionModel(t), e.setSegmentIntersector(new Jn(n)), e }, rr.prototype.buffer = function (t, e) { let n = this._workingPrecisionModel; n === null && (n = t.getPrecisionModel()), this._geomFact = t.getFactory(); const r = new Tn(n, this._bufParams); const i = new Gn(t, e, r).getCurves(); if (i.size() <= 0) return this.createEmptyResultGeometry(); this.computeNodedEdges(i, n), this._graph = new Xe(new Yn()), this._graph.addEdges(this._edgeList.getEdges()); const o = this.createSubgraphs(this._graph); const s = new Ye(this._geomFact); this.buildSubgraphs(o, s); const a = s.getPolygons(); return a.size() <= 0 ? this.createEmptyResultGeometry() : this._geomFact.buildGeometry(a) }, rr.prototype.computeNodedEdges = function (t, e) { const n = this.getNoder(e); n.computeNodes(t); for (let r = n.getNodedSubstrings().iterator(); r.hasNext();) { const i = r.next(); const o = i.getCoordinates(); if (o.length !== 2 || !o[0].equals2D(o[1])) { const s = i.getData(); const a = new nr(i.getCoordinates(), new Re(s)); this.insertUniqueEdge(a) } } }, rr.prototype.setNoder = function (t) { this._workingNoder = t }, rr.prototype.interfaces_ = function () { return [] }, rr.prototype.getClass = function () { return rr }, rr.depthDelta = function (t) { const e = t.getLocation(0, Se.LEFT); const n = t.getLocation(0, Se.RIGHT); return e === C.INTERIOR && n === C.EXTERIOR ? 1 : e === C.EXTERIOR && n === C.INTERIOR ? -1 : 0 }, rr.convertSegStrings = function (t) { for (var e = new ve(), n = new wt(); t.hasNext();) { const r = t.next(); const i = e.createLineString(r.getCoordinates()); n.add(i) } return e.buildGeometry(n) }; const ir = function () { if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = !1, arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; this._noder = t, this._scaleFactor = e, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision() } else if (arguments.length === 4) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; const o = arguments[3]; this._noder = n, this._scaleFactor = r, this._offsetX = i, this._offsetY = o, this._isScaled = !this.isIntegerPrecision() } }; ir.prototype.rescale = function () { if (O(arguments[0], xt)) for (let t = arguments[0].iterator(); t.hasNext();) { const e = t.next(); this.rescale(e.getCoordinates()) } else if (arguments[0] instanceof Array) { for (var n = arguments[0], r = 0; r < n.length; r++)n[r].x = n[r].x / this._scaleFactor + this._offsetX, n[r].y = n[r].y / this._scaleFactor + this._offsetY; n.length === 2 && n[0].equals2D(n[1]) && X.out.println(n) } }, ir.prototype.scale = function () { if (O(arguments[0], xt)) { for (var t = arguments[0], e = new wt(), n = t.iterator(); n.hasNext();) { const r = n.next(); e.add(new gn(this.scale(r.getCoordinates()), r.getData())) } return e } if (arguments[0] instanceof Array) { for (var i = arguments[0], o = new Array(i.length).fill(null), s = 0; s < i.length; s++)o[s] = new I(Math.round((i[s].x - this._offsetX) * this._scaleFactor), Math.round((i[s].y - this._offsetY) * this._scaleFactor), i[s].z); return Nt.removeRepeatedPoints(o) } }, ir.prototype.isIntegerPrecision = function () { return this._scaleFactor === 1 }, ir.prototype.getNodedSubstrings = function () { const t = this._noder.getNodedSubstrings(); return this._isScaled && this.rescale(t), t }, ir.prototype.computeNodes = function (t) { let e = t; this._isScaled && (e = this.scale(t)), this._noder.computeNodes(e) }, ir.prototype.interfaces_ = function () { return [xn] }, ir.prototype.getClass = function () { return ir }; const or = function () { this._li = new it(), this._segStrings = null; const t = arguments[0]; this._segStrings = t }; const sr = { fact: { configurable: !0 } }; or.prototype.checkEndPtVertexIntersections = function () { if (arguments.length === 0) for (let t = this._segStrings.iterator(); t.hasNext();) { const e = t.next().getCoordinates(); this.checkEndPtVertexIntersections(e[0], this._segStrings), this.checkEndPtVertexIntersections(e[e.length - 1], this._segStrings) } else if (arguments.length === 2) for (let n = arguments[0], r = arguments[1].iterator(); r.hasNext();) for (let i = r.next().getCoordinates(), o = 1; o < i.length - 1; o++) if (i[o].equals(n)) throw new $('found endpt/interior pt intersection at index ' + o + ' :pt ' + n) }, or.prototype.checkInteriorIntersections = function () { if (arguments.length === 0) for (let t = this._segStrings.iterator(); t.hasNext();) for (let e = t.next(), n = this._segStrings.iterator(); n.hasNext();) { const r = n.next(); this.checkInteriorIntersections(e, r) } else if (arguments.length === 2) for (let i = arguments[0], o = arguments[1], s = i.getCoordinates(), a = o.getCoordinates(), u = 0; u < s.length - 1; u++) for (let l = 0; l < a.length - 1; l++) this.checkInteriorIntersections(i, u, o, l); else if (arguments.length === 4) { const c = arguments[0]; const f = arguments[1]; const h = arguments[2]; const p = arguments[3]; if (c === h && f === p) return null; const g = c.getCoordinates()[f]; const d = c.getCoordinates()[f + 1]; const y = h.getCoordinates()[p]; const v = h.getCoordinates()[p + 1]; if (this._li.computeIntersection(g, d, y, v), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g, d) || this.hasInteriorIntersection(this._li, y, v))) throw new $('found non-noded intersection at ' + g + '-' + d + ' and ' + y + '-' + v) } }, or.prototype.checkValid = function () { this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses() }, or.prototype.checkCollapses = function () { if (arguments.length === 0) for (let t = this._segStrings.iterator(); t.hasNext();) { const e = t.next(); this.checkCollapses(e) } else if (arguments.length === 1) for (let n = arguments[0].getCoordinates(), r = 0; r < n.length - 2; r++) this.checkCollapse(n[r], n[r + 1], n[r + 2]) }, or.prototype.hasInteriorIntersection = function (t, e, n) { for (let r = 0; r < t.getIntersectionNum(); r++) { const i = t.getIntersection(r); if (!i.equals(e) && !i.equals(n)) return !0 } return !1 }, or.prototype.checkCollapse = function (t, e, n) { if (t.equals(n)) throw new $('found non-noded collapse at ' + or.fact.createLineString([t, e, n])) }, or.prototype.interfaces_ = function () { return [] }, or.prototype.getClass = function () { return or }, sr.fact.get = function () { return new ve() }, Object.defineProperties(or, sr); const ar = function () { this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null; const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; if (this._originalPt = t, this._pt = t, this._scaleFactor = e, this._li = n, e <= 0) throw new _('Scale factor must be non-zero'); e !== 1 && (this._pt = new I(this.scale(t.x), this.scale(t.y)), this._p0Scaled = new I(), this._p1Scaled = new I()), this.initCorners(this._pt) }; const ur = { SAFE_ENV_EXPANSION_FACTOR: { configurable: !0 } }; ar.prototype.intersectsScaled = function (t, e) { const n = Math.min(t.x, e.x); const r = Math.max(t.x, e.x); const i = Math.min(t.y, e.y); const o = Math.max(t.y, e.y); const s = this._maxx < n || this._minx > r || this._maxy < i || this._miny > o; if (s) return !1; const a = this.intersectsToleranceSquare(t, e); return et.isTrue(!(s && a), 'Found bad envelope test'), a }, ar.prototype.initCorners = function (t) { this._minx = t.x - 0.5, this._maxx = t.x + 0.5, this._miny = t.y - 0.5, this._maxy = t.y + 0.5, this._corner[0] = new I(this._maxx, this._maxy), this._corner[1] = new I(this._minx, this._maxy), this._corner[2] = new I(this._minx, this._miny), this._corner[3] = new I(this._maxx, this._miny) }, ar.prototype.intersects = function (t, e) { return this._scaleFactor === 1 ? this.intersectsScaled(t, e) : (this.copyScaled(t, this._p0Scaled), this.copyScaled(e, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled)) }, ar.prototype.scale = function (t) { return Math.round(t * this._scaleFactor) }, ar.prototype.getCoordinate = function () { return this._originalPt }, ar.prototype.copyScaled = function (t, e) { e.x = this.scale(t.x), e.y = this.scale(t.y) }, ar.prototype.getSafeEnvelope = function () { if (this._safeEnv === null) { const t = ar.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor; this._safeEnv = new V(this._originalPt.x - t, this._originalPt.x + t, this._originalPt.y - t, this._originalPt.y + t) } return this._safeEnv }, ar.prototype.intersectsPixelClosure = function (t, e) { return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.hasIntersection() || (this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.hasIntersection())))) }, ar.prototype.intersectsToleranceSquare = function (t, e) { let n = !1; let r = !1; return this._li.computeIntersection(t, e, this._corner[0], this._corner[1]), !!(this._li.isProper() || (this._li.computeIntersection(t, e, this._corner[1], this._corner[2]), this._li.isProper() || (this._li.hasIntersection() && (n = !0), this._li.computeIntersection(t, e, this._corner[2], this._corner[3]), this._li.isProper() || (this._li.hasIntersection() && (r = !0), this._li.computeIntersection(t, e, this._corner[3], this._corner[0]), this._li.isProper() || n && r || t.equals(this._pt) || e.equals(this._pt))))) }, ar.prototype.addSnappedNode = function (t, e) { const n = t.getCoordinate(e); const r = t.getCoordinate(e + 1); return !!this.intersects(n, r) && (t.addIntersection(this.getCoordinate(), e), !0) }, ar.prototype.interfaces_ = function () { return [] }, ar.prototype.getClass = function () { return ar }, ur.SAFE_ENV_EXPANSION_FACTOR.get = function () { return 0.75 }, Object.defineProperties(ar, ur); const lr = function () { this.tempEnv1 = new V(), this.selectedSegment = new dn() }; lr.prototype.select = function () { if (arguments.length === 1);else if (arguments.length === 2) { const t = arguments[1]; arguments[0].getLineSegment(t, this.selectedSegment), this.select(this.selectedSegment) } }, lr.prototype.interfaces_ = function () { return [] }, lr.prototype.getClass = function () { return lr }; const cr = function () { this._index = null; const t = arguments[0]; this._index = t }; const fr = { HotPixelSnapAction: { configurable: !0 } }; cr.prototype.snap = function () { if (arguments.length === 1) { const t = arguments[0]; return this.snap(t, null, -1) } if (arguments.length === 3) { const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; const i = e.getSafeEnvelope(); const o = new hr(e, n, r); return this._index.query(i, { interfaces_: function () { return [Je] }, visitItem: function (t) { t.select(i, o) } }), o.isNodeAdded() } }, cr.prototype.interfaces_ = function () { return [] }, cr.prototype.getClass = function () { return cr }, fr.HotPixelSnapAction.get = function () { return hr }, Object.defineProperties(cr, fr); var hr = (function (t) { function e () { t.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = !1; const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; this._hotPixel = e, this._parentEdge = n, this._hotPixelVertexIndex = r } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.isNodeAdded = function () { return this._isNodeAdded }, e.prototype.select = function () { if (arguments.length !== 2) return t.prototype.select.apply(this, arguments); const e = arguments[1]; const n = arguments[0].getContext(); if (this._parentEdge !== null && n === this._parentEdge && e === this._hotPixelVertexIndex) return null; this._isNodeAdded = this._hotPixel.addSnappedNode(n, e) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(lr)); const pr = function () { this._li = null, this._interiorIntersections = null; const t = arguments[0]; this._li = t, this._interiorIntersections = new wt() }; pr.prototype.processIntersections = function (t, e, n, r) { if (t === n && e === r) return null; const i = t.getCoordinates()[e]; const o = t.getCoordinates()[e + 1]; const s = n.getCoordinates()[r]; const a = n.getCoordinates()[r + 1]; if (this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection()) { for (let u = 0; u < this._li.getIntersectionNum(); u++) this._interiorIntersections.add(this._li.getIntersection(u)); t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1) } }, pr.prototype.isDone = function () { return !1 }, pr.prototype.getInteriorIntersections = function () { return this._interiorIntersections }, pr.prototype.interfaces_ = function () { return [Hn] }, pr.prototype.getClass = function () { return pr }; const gr = function () { this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null; const t = arguments[0]; this._pm = t, this._li = new it(), this._li.setPrecisionModel(t), this._scaleFactor = t.getScale() }; gr.prototype.checkCorrectness = function (t) { const e = gn.getNodedSubstrings(t); const n = new or(e); try { n.checkValid() } catch (t) { if (!(t instanceof z)) throw t; t.printStackTrace() } }, gr.prototype.getNodedSubstrings = function () { return gn.getNodedSubstrings(this._nodedSegStrings) }, gr.prototype.snapRound = function (t, e) { const n = this.findInteriorIntersections(t, e); this.computeIntersectionSnaps(n), this.computeVertexSnaps(t) }, gr.prototype.findInteriorIntersections = function (t, e) { const n = new pr(e); return this._noder.setSegmentIntersector(n), this._noder.computeNodes(t), n.getInteriorIntersections() }, gr.prototype.computeVertexSnaps = function () { if (O(arguments[0], xt)) for (let t = arguments[0].iterator(); t.hasNext();) { const e = t.next(); this.computeVertexSnaps(e) } else if (arguments[0] instanceof gn) for (let n = arguments[0], r = n.getCoordinates(), i = 0; i < r.length; i++) { const o = new ar(r[i], this._scaleFactor, this._li); this._pointSnapper.snap(o, n, i) && n.addIntersection(r[i], i) } }, gr.prototype.computeNodes = function (t) { this._nodedSegStrings = t, this._noder = new En(), this._pointSnapper = new cr(this._noder.getIndex()), this.snapRound(t, this._li) }, gr.prototype.computeIntersectionSnaps = function (t) { for (let e = t.iterator(); e.hasNext();) { const n = e.next(); const r = new ar(n, this._scaleFactor, this._li); this._pointSnapper.snap(r) } }, gr.prototype.interfaces_ = function () { return [xn] }, gr.prototype.getClass = function () { return gr }; const dr = function () { if (this._argGeom = null, this._distance = null, this._bufParams = new In(), this._resultGeometry = null, this._saveException = null, arguments.length === 1) { const t = arguments[0]; this._argGeom = t } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; this._argGeom = e, this._bufParams = n } }; const yr = { CAP_ROUND: { configurable: !0 }, CAP_BUTT: { configurable: !0 }, CAP_FLAT: { configurable: !0 }, CAP_SQUARE: { configurable: !0 }, MAX_PRECISION_DIGITS: { configurable: !0 } }; dr.prototype.bufferFixedPrecision = function (t) { const e = new ir(new gr(new pe(1)), t.getScale()); const n = new rr(this._bufParams); n.setWorkingPrecisionModel(t), n.setNoder(e), this._resultGeometry = n.buffer(this._argGeom, this._distance) }, dr.prototype.bufferReducedPrecision = function () { const t = this; if (arguments.length === 0) { for (let e = dr.MAX_PRECISION_DIGITS; e >= 0; e--) { try { t.bufferReducedPrecision(e) } catch (e) { if (!(e instanceof Ce)) throw e; t._saveException = e } if (t._resultGeometry !== null) return null } throw this._saveException } if (arguments.length === 1) { const n = arguments[0]; const r = dr.precisionScaleFactor(this._argGeom, this._distance, n); const i = new pe(r); this.bufferFixedPrecision(i) } }, dr.prototype.computeGeometry = function () { if (this.bufferOriginalPrecision(), this._resultGeometry !== null) return null; const t = this._argGeom.getFactory().getPrecisionModel(); t.getType() === pe.FIXED ? this.bufferFixedPrecision(t) : this.bufferReducedPrecision() }, dr.prototype.setQuadrantSegments = function (t) { this._bufParams.setQuadrantSegments(t) }, dr.prototype.bufferOriginalPrecision = function () { try { const t = new rr(this._bufParams); this._resultGeometry = t.buffer(this._argGeom, this._distance) } catch (t) { if (!(t instanceof $)) throw t; this._saveException = t } }, dr.prototype.getResultGeometry = function (t) { return this._distance = t, this.computeGeometry(), this._resultGeometry }, dr.prototype.setEndCapStyle = function (t) { this._bufParams.setEndCapStyle(t) }, dr.prototype.interfaces_ = function () { return [] }, dr.prototype.getClass = function () { return dr }, dr.bufferOp = function () { if (arguments.length === 2) { const t = arguments[1]; return new dr(arguments[0]).getResultGeometry(t) } if (arguments.length === 3) { if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && typeof arguments[1] === 'number') { const e = arguments[1]; const n = arguments[2]; const r = new dr(arguments[0]); return r.setQuadrantSegments(n), r.getResultGeometry(e) } if (arguments[2] instanceof In && arguments[0] instanceof ct && typeof arguments[1] === 'number') { const i = arguments[1]; return new dr(arguments[0], arguments[2]).getResultGeometry(i) } } else if (arguments.length === 4) { const o = arguments[1]; const s = arguments[2]; const a = arguments[3]; const u = new dr(arguments[0]); return u.setQuadrantSegments(s), u.setEndCapStyle(a), u.getResultGeometry(o) } }, dr.precisionScaleFactor = function (t, e, n) { const r = t.getEnvelopeInternal(); const i = L.max(Math.abs(r.getMaxX()), Math.abs(r.getMaxY()), Math.abs(r.getMinX()), Math.abs(r.getMinY())) + 2 * (e > 0 ? e : 0); const o = n - Math.trunc(Math.log(i) / Math.log(10) + 1); return Math.pow(10, o) }, yr.CAP_ROUND.get = function () { return In.CAP_ROUND }, yr.CAP_BUTT.get = function () { return In.CAP_FLAT }, yr.CAP_FLAT.get = function () { return In.CAP_FLAT }, yr.CAP_SQUARE.get = function () { return In.CAP_SQUARE }, yr.MAX_PRECISION_DIGITS.get = function () { return 12 }, Object.defineProperties(dr, yr); const vr = function () { this._pt = [new I(), new I()], this._distance = m.NaN, this._isNull = !0 }; vr.prototype.getCoordinates = function () { return this._pt }, vr.prototype.getCoordinate = function (t) { return this._pt[t] }, vr.prototype.setMinimum = function () { if (arguments.length === 1) { const t = arguments[0]; this.setMinimum(t._pt[0], t._pt[1]) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (this._isNull) return this.initialize(e, n), null; const r = e.distance(n); r < this._distance && this.initialize(e, n, r) } }, vr.prototype.initialize = function () { if (arguments.length === 0) this._isNull = !0; else if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1 } else if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(r), this._distance = i, this._isNull = !1 } }, vr.prototype.getDistance = function () { return this._distance }, vr.prototype.setMaximum = function () { if (arguments.length === 1) { const t = arguments[0]; this.setMaximum(t._pt[0], t._pt[1]) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (this._isNull) return this.initialize(e, n), null; const r = e.distance(n); r > this._distance && this.initialize(e, n, r) } }, vr.prototype.interfaces_ = function () { return [] }, vr.prototype.getClass = function () { return vr }; const _r = function () {}; _r.prototype.interfaces_ = function () { return [] }, _r.prototype.getClass = function () { return _r }, _r.computeDistance = function () { if (arguments[2] instanceof vr && arguments[0] instanceof Jt && arguments[1] instanceof I) for (let t = arguments[1], e = arguments[2], n = arguments[0].getCoordinates(), r = new dn(), i = 0; i < n.length - 1; i++) { r.setCoordinates(n[i], n[i + 1]); const o = r.closestPoint(t); e.setMinimum(o, t) } else if (arguments[2] instanceof vr && arguments[0] instanceof $t && arguments[1] instanceof I) { const s = arguments[0]; const a = arguments[1]; const u = arguments[2]; _r.computeDistance(s.getExteriorRing(), a, u); for (let l = 0; l < s.getNumInteriorRing(); l++)_r.computeDistance(s.getInteriorRingN(l), a, u) } else if (arguments[2] instanceof vr && arguments[0] instanceof ct && arguments[1] instanceof I) { const c = arguments[0]; const f = arguments[1]; const h = arguments[2]; if (c instanceof Jt)_r.computeDistance(c, f, h); else if (c instanceof $t)_r.computeDistance(c, f, h); else if (c instanceof zt) for (let p = c, g = 0; g < p.getNumGeometries(); g++) { const d = p.getGeometryN(g); _r.computeDistance(d, f, h) } else h.setMinimum(c.getCoordinate(), f) } else if (arguments[2] instanceof vr && arguments[0] instanceof dn && arguments[1] instanceof I) { const y = arguments[1]; const v = arguments[2]; const _ = arguments[0].closestPoint(y); v.setMinimum(_, y) } }; const mr = function (t) { this._maxPtDist = new vr(), this._inputGeom = t || null }; const xr = { MaxPointDistanceFilter: { configurable: !0 }, MaxMidpointDistanceFilter: { configurable: !0 } }; mr.prototype.computeMaxMidpointDistance = function (t) { const e = new Er(this._inputGeom); t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance()) }, mr.prototype.computeMaxVertexDistance = function (t) { const e = new br(this._inputGeom); t.apply(e), this._maxPtDist.setMaximum(e.getMaxPointDistance()) }, mr.prototype.findDistance = function (t) { return this.computeMaxVertexDistance(t), this.computeMaxMidpointDistance(t), this._maxPtDist.getDistance() }, mr.prototype.getDistancePoints = function () { return this._maxPtDist }, mr.prototype.interfaces_ = function () { return [] }, mr.prototype.getClass = function () { return mr }, xr.MaxPointDistanceFilter.get = function () { return br }, xr.MaxMidpointDistanceFilter.get = function () { return Er }, Object.defineProperties(mr, xr); var br = function (t) { this._maxPtDist = new vr(), this._minPtDist = new vr(), this._geom = t || null }; br.prototype.filter = function (t) { this._minPtDist.initialize(), _r.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist) }, br.prototype.getMaxPointDistance = function () { return this._maxPtDist }, br.prototype.interfaces_ = function () { return [pt] }, br.prototype.getClass = function () { return br }; var Er = function (t) { this._maxPtDist = new vr(), this._minPtDist = new vr(), this._geom = t || null }; Er.prototype.filter = function (t, e) { if (e === 0) return null; const n = t.getCoordinate(e - 1); const r = t.getCoordinate(e); const i = new I((n.x + r.x) / 2, (n.y + r.y) / 2); this._minPtDist.initialize(), _r.computeDistance(this._geom, i, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist) }, Er.prototype.isDone = function () { return !1 }, Er.prototype.isGeometryChanged = function () { return !1 }, Er.prototype.getMaxPointDistance = function () { return this._maxPtDist }, Er.prototype.interfaces_ = function () { return [Bt] }, Er.prototype.getClass = function () { return Er }; const wr = function (t) { this._comps = t || null }; wr.prototype.filter = function (t) { t instanceof $t && this._comps.add(t) }, wr.prototype.interfaces_ = function () { return [qt] }, wr.prototype.getClass = function () { return wr }, wr.getPolygons = function () { if (arguments.length === 1) { const t = arguments[0]; return wr.getPolygons(t, new wt()) } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return e instanceof $t ? n.add(e) : e instanceof zt && e.apply(new wr(n)), n } }; const Ir = function () { if (this._lines = null, this._isForcedToLineString = !1, arguments.length === 1) { const t = arguments[0]; this._lines = t } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; this._lines = e, this._isForcedToLineString = n } }; Ir.prototype.filter = function (t) { if (this._isForcedToLineString && t instanceof ee) { const e = t.getFactory().createLineString(t.getCoordinateSequence()); return this._lines.add(e), null }t instanceof Jt && this._lines.add(t) }, Ir.prototype.setForceToLineString = function (t) { this._isForcedToLineString = t }, Ir.prototype.interfaces_ = function () { return [lt] }, Ir.prototype.getClass = function () { return Ir }, Ir.getGeometry = function () { if (arguments.length === 1) { const t = arguments[0]; return t.getFactory().buildGeometry(Ir.getLines(t)) } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return e.getFactory().buildGeometry(Ir.getLines(e, n)) } }, Ir.getLines = function () { if (arguments.length === 1) { const t = arguments[0]; return Ir.getLines(t, !1) } if (arguments.length === 2) { if (O(arguments[0], xt) && O(arguments[1], xt)) { for (var e = arguments[1], n = arguments[0].iterator(); n.hasNext();) { const r = n.next(); Ir.getLines(r, e) } return e } if (arguments[0] instanceof ct && typeof arguments[1] === 'boolean') { const i = arguments[0]; const o = arguments[1]; const s = new wt(); return i.apply(new Ir(s, o)), s } if (arguments[0] instanceof ct && O(arguments[1], xt)) { const a = arguments[0]; const u = arguments[1]; return a instanceof Jt ? u.add(a) : a.apply(new Ir(u)), u } } else if (arguments.length === 3) { if (typeof arguments[2] === 'boolean' && O(arguments[0], xt) && O(arguments[1], xt)) { for (var l = arguments[1], c = arguments[2], f = arguments[0].iterator(); f.hasNext();) { const h = f.next(); Ir.getLines(h, l, c) } return l } if (typeof arguments[2] === 'boolean' && arguments[0] instanceof ct && O(arguments[1], xt)) { const p = arguments[1]; const g = arguments[2]; return arguments[0].apply(new Ir(p, g)), p } } }; const Sr = function () { if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, arguments.length === 0);else if (arguments.length === 1) { const t = arguments[0]; if (t === null) throw new _('Rule must be non-null'); this._boundaryRule = t } }; Sr.prototype.locateInternal = function () { if (arguments[0] instanceof I && arguments[1] instanceof $t) { const t = arguments[0]; const e = arguments[1]; if (e.isEmpty()) return C.EXTERIOR; const n = e.getExteriorRing(); const r = this.locateInPolygonRing(t, n); if (r === C.EXTERIOR) return C.EXTERIOR; if (r === C.BOUNDARY) return C.BOUNDARY; for (let i = 0; i < e.getNumInteriorRing(); i++) { const o = e.getInteriorRingN(i); const s = this.locateInPolygonRing(t, o); if (s === C.INTERIOR) return C.EXTERIOR; if (s === C.BOUNDARY) return C.BOUNDARY } return C.INTERIOR } if (arguments[0] instanceof I && arguments[1] instanceof Jt) { const a = arguments[0]; const u = arguments[1]; if (!u.getEnvelopeInternal().intersects(a)) return C.EXTERIOR; const l = u.getCoordinates(); return u.isClosed() || !a.equals(l[0]) && !a.equals(l[l.length - 1]) ? at.isOnLine(a, l) ? C.INTERIOR : C.EXTERIOR : C.BOUNDARY } if (arguments[0] instanceof I && arguments[1] instanceof Kt) { const c = arguments[0]; return arguments[1].getCoordinate().equals2D(c) ? C.INTERIOR : C.EXTERIOR } }, Sr.prototype.locateInPolygonRing = function (t, e) { return e.getEnvelopeInternal().intersects(t) ? at.locatePointInRing(t, e.getCoordinates()) : C.EXTERIOR }, Sr.prototype.intersects = function (t, e) { return this.locate(t, e) !== C.EXTERIOR }, Sr.prototype.updateLocationInfo = function (t) { t === C.INTERIOR && (this._isIn = !0), t === C.BOUNDARY && this._numBoundaries++ }, Sr.prototype.computeLocation = function (t, e) { if (e instanceof Kt && this.updateLocationInfo(this.locateInternal(t, e)), e instanceof Jt) this.updateLocationInfo(this.locateInternal(t, e)); else if (e instanceof $t) this.updateLocationInfo(this.locateInternal(t, e)); else if (e instanceof Ut) for (let n = e, r = 0; r < n.getNumGeometries(); r++) { const i = n.getGeometryN(r); this.updateLocationInfo(this.locateInternal(t, i)) } else if (e instanceof ne) for (let o = e, s = 0; s < o.getNumGeometries(); s++) { const a = o.getGeometryN(s); this.updateLocationInfo(this.locateInternal(t, a)) } else if (e instanceof zt) for (let u = new Bn(e); u.hasNext();) { const l = u.next(); l !== e && this.computeLocation(t, l) } }, Sr.prototype.locate = function (t, e) { return e.isEmpty() ? C.EXTERIOR : e instanceof Jt || e instanceof $t ? this.locateInternal(t, e) : (this._isIn = !1, this._numBoundaries = 0, this.computeLocation(t, e), this._boundaryRule.isInBoundary(this._numBoundaries) ? C.BOUNDARY : this._numBoundaries > 0 || this._isIn ? C.INTERIOR : C.EXTERIOR) }, Sr.prototype.interfaces_ = function () { return [] }, Sr.prototype.getClass = function () { return Sr }; const Nr = function t () { if (this._component = null, this._segIndex = null, this._pt = null, arguments.length === 2)t.call(this, arguments[0], t.INSIDE_AREA, arguments[1]); else if (arguments.length === 3) { const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; this._component = e, this._segIndex = n, this._pt = r } }; const Pr = { INSIDE_AREA: { configurable: !0 } }; Nr.prototype.isInsideArea = function () { return this._segIndex === Nr.INSIDE_AREA }, Nr.prototype.getCoordinate = function () { return this._pt }, Nr.prototype.getGeometryComponent = function () { return this._component }, Nr.prototype.getSegmentIndex = function () { return this._segIndex }, Nr.prototype.interfaces_ = function () { return [] }, Nr.prototype.getClass = function () { return Nr }, Pr.INSIDE_AREA.get = function () { return -1 }, Object.defineProperties(Nr, Pr); const Cr = function (t) { this._pts = t || null }; Cr.prototype.filter = function (t) { t instanceof Kt && this._pts.add(t) }, Cr.prototype.interfaces_ = function () { return [qt] }, Cr.prototype.getClass = function () { return Cr }, Cr.getPoints = function () { if (arguments.length === 1) { const t = arguments[0]; return t instanceof Kt ? $e.singletonList(t) : Cr.getPoints(t, new wt()) } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return e instanceof Kt ? n.add(e) : e instanceof zt && e.apply(new Cr(n)), n } }; const Mr = function () { this._locations = null; const t = arguments[0]; this._locations = t }; Mr.prototype.filter = function (t) { (t instanceof Kt || t instanceof Jt || t instanceof $t) && this._locations.add(new Nr(t, 0, t.getCoordinate())) }, Mr.prototype.interfaces_ = function () { return [qt] }, Mr.prototype.getClass = function () { return Mr }, Mr.getLocations = function (t) { const e = new wt(); return t.apply(new Mr(e)), e }; const Or = function () { if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Sr(), this._minDistanceLocation = null, this._minDistance = m.MAX_VALUE, arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; this._geom = [t, e], this._terminateDistance = 0 } else if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; this._geom = new Array(2).fill(null), this._geom[0] = n, this._geom[1] = r, this._terminateDistance = i } }; Or.prototype.computeContainmentDistance = function () { if (arguments.length === 0) { const t = new Array(2).fill(null); if (this.computeContainmentDistance(0, t), this._minDistance <= this._terminateDistance) return null; this.computeContainmentDistance(1, t) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; const r = 1 - e; const i = wr.getPolygons(this._geom[e]); if (i.size() > 0) { const o = Mr.getLocations(this._geom[r]); if (this.computeContainmentDistance(o, i, n), this._minDistance <= this._terminateDistance) return this._minDistanceLocation[r] = n[0], this._minDistanceLocation[e] = n[1], null } } else if (arguments.length === 3) if (arguments[2] instanceof Array && O(arguments[0], Et) && O(arguments[1], Et)) { for (let s = arguments[0], a = arguments[1], u = arguments[2], l = 0; l < s.size(); l++) for (let c = s.get(l), f = 0; f < a.size(); f++) if (this.computeContainmentDistance(c, a.get(f), u), this._minDistance <= this._terminateDistance) return null } else if (arguments[2] instanceof Array && arguments[0] instanceof Nr && arguments[1] instanceof $t) { const h = arguments[0]; const p = arguments[1]; const g = arguments[2]; const d = h.getCoordinate(); if (C.EXTERIOR !== this._ptLocator.locate(d, p)) return this._minDistance = 0, g[0] = h, g[1] = new Nr(p, d), null } }, Or.prototype.computeMinDistanceLinesPoints = function (t, e, n) { for (let r = 0; r < t.size(); r++) for (let i = t.get(r), o = 0; o < e.size(); o++) { const s = e.get(o); if (this.computeMinDistance(i, s, n), this._minDistance <= this._terminateDistance) return null } }, Or.prototype.computeFacetDistance = function () { const t = new Array(2).fill(null); const e = Ir.getLines(this._geom[0]); const n = Ir.getLines(this._geom[1]); const r = Cr.getPoints(this._geom[0]); const i = Cr.getPoints(this._geom[1]); return this.computeMinDistanceLines(e, n, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(e, i, t), this.updateMinDistance(t, !1), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistanceLinesPoints(n, r, t), this.updateMinDistance(t, !0), this._minDistance <= this._terminateDistance ? null : (t[0] = null, t[1] = null, this.computeMinDistancePoints(r, i, t), void this.updateMinDistance(t, !1)))) }, Or.prototype.nearestLocations = function () { return this.computeMinDistance(), this._minDistanceLocation }, Or.prototype.updateMinDistance = function (t, e) { if (t[0] === null) return null; e ? (this._minDistanceLocation[0] = t[1], this._minDistanceLocation[1] = t[0]) : (this._minDistanceLocation[0] = t[0], this._minDistanceLocation[1] = t[1]) }, Or.prototype.nearestPoints = function () { return this.computeMinDistance(), [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()] }, Or.prototype.computeMinDistance = function () { if (arguments.length === 0) { if (this._minDistanceLocation !== null) return null; if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance) return null; this.computeFacetDistance() } else if (arguments.length === 3) if (arguments[2] instanceof Array && arguments[0] instanceof Jt && arguments[1] instanceof Kt) { const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; if (t.getEnvelopeInternal().distance(e.getEnvelopeInternal()) > this._minDistance) return null; for (let r = t.getCoordinates(), i = e.getCoordinate(), o = 0; o < r.length - 1; o++) { const s = at.distancePointLine(i, r[o], r[o + 1]); if (s < this._minDistance) { this._minDistance = s; const a = new dn(r[o], r[o + 1]).closestPoint(i); n[0] = new Nr(t, o, a), n[1] = new Nr(e, 0, i) } if (this._minDistance <= this._terminateDistance) return null } } else if (arguments[2] instanceof Array && arguments[0] instanceof Jt && arguments[1] instanceof Jt) { const u = arguments[0]; const l = arguments[1]; const c = arguments[2]; if (u.getEnvelopeInternal().distance(l.getEnvelopeInternal()) > this._minDistance) return null; for (let f = u.getCoordinates(), h = l.getCoordinates(), p = 0; p < f.length - 1; p++) for (let g = 0; g < h.length - 1; g++) { const d = at.distanceLineLine(f[p], f[p + 1], h[g], h[g + 1]); if (d < this._minDistance) { this._minDistance = d; const y = new dn(f[p], f[p + 1]); const v = new dn(h[g], h[g + 1]); const _ = y.closestPoints(v); c[0] = new Nr(u, p, _[0]), c[1] = new Nr(l, g, _[1]) } if (this._minDistance <= this._terminateDistance) return null } } }, Or.prototype.computeMinDistancePoints = function (t, e, n) { for (let r = 0; r < t.size(); r++) for (let i = t.get(r), o = 0; o < e.size(); o++) { const s = e.get(o); const a = i.getCoordinate().distance(s.getCoordinate()); if (a < this._minDistance && (this._minDistance = a, n[0] = new Nr(i, 0, i.getCoordinate()), n[1] = new Nr(s, 0, s.getCoordinate())), this._minDistance <= this._terminateDistance) return null } }, Or.prototype.distance = function () { if (this._geom[0] === null || this._geom[1] === null) throw new _('null geometries are not supported'); return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance) }, Or.prototype.computeMinDistanceLines = function (t, e, n) { for (let r = 0; r < t.size(); r++) for (let i = t.get(r), o = 0; o < e.size(); o++) { const s = e.get(o); if (this.computeMinDistance(i, s, n), this._minDistance <= this._terminateDistance) return null } }, Or.prototype.interfaces_ = function () { return [] }, Or.prototype.getClass = function () { return Or }, Or.distance = function (t, e) { return new Or(t, e).distance() }, Or.isWithinDistance = function (t, e, n) { return new Or(t, e, n).distance() <= n }, Or.nearestPoints = function (t, e) { return new Or(t, e).nearestPoints() }; const Lr = function () { this._pt = [new I(), new I()], this._distance = m.NaN, this._isNull = !0 }; Lr.prototype.getCoordinates = function () { return this._pt }, Lr.prototype.getCoordinate = function (t) { return this._pt[t] }, Lr.prototype.setMinimum = function () { if (arguments.length === 1) { const t = arguments[0]; this.setMinimum(t._pt[0], t._pt[1]) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (this._isNull) return this.initialize(e, n), null; const r = e.distance(n); r < this._distance && this.initialize(e, n, r) } }, Lr.prototype.initialize = function () { if (arguments.length === 0) this._isNull = !0; else if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; this._pt[0].setCoordinate(t), this._pt[1].setCoordinate(e), this._distance = t.distance(e), this._isNull = !1 } else if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; this._pt[0].setCoordinate(n), this._pt[1].setCoordinate(r), this._distance = i, this._isNull = !1 } }, Lr.prototype.toString = function () { return Q.toLineString(this._pt[0], this._pt[1]) }, Lr.prototype.getDistance = function () { return this._distance }, Lr.prototype.setMaximum = function () { if (arguments.length === 1) { const t = arguments[0]; this.setMaximum(t._pt[0], t._pt[1]) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; if (this._isNull) return this.initialize(e, n), null; const r = e.distance(n); r > this._distance && this.initialize(e, n, r) } }, Lr.prototype.interfaces_ = function () { return [] }, Lr.prototype.getClass = function () { return Lr }; const Rr = function () {}; Rr.prototype.interfaces_ = function () { return [] }, Rr.prototype.getClass = function () { return Rr }, Rr.computeDistance = function () { if (arguments[2] instanceof Lr && arguments[0] instanceof Jt && arguments[1] instanceof I) for (let t = arguments[0], e = arguments[1], n = arguments[2], r = new dn(), i = t.getCoordinates(), o = 0; o < i.length - 1; o++) { r.setCoordinates(i[o], i[o + 1]); const s = r.closestPoint(e); n.setMinimum(s, e) } else if (arguments[2] instanceof Lr && arguments[0] instanceof $t && arguments[1] instanceof I) { const a = arguments[0]; const u = arguments[1]; const l = arguments[2]; Rr.computeDistance(a.getExteriorRing(), u, l); for (let c = 0; c < a.getNumInteriorRing(); c++)Rr.computeDistance(a.getInteriorRingN(c), u, l) } else if (arguments[2] instanceof Lr && arguments[0] instanceof ct && arguments[1] instanceof I) { const f = arguments[0]; const h = arguments[1]; const p = arguments[2]; if (f instanceof Jt)Rr.computeDistance(f, h, p); else if (f instanceof $t)Rr.computeDistance(f, h, p); else if (f instanceof zt) for (let g = f, d = 0; d < g.getNumGeometries(); d++) { const y = g.getGeometryN(d); Rr.computeDistance(y, h, p) } else p.setMinimum(f.getCoordinate(), h) } else if (arguments[2] instanceof Lr && arguments[0] instanceof dn && arguments[1] instanceof I) { const v = arguments[1]; const _ = arguments[2]; const m = arguments[0].closestPoint(v); _.setMinimum(m, v) } }; const Ar = function () { this._g0 = null, this._g1 = null, this._ptDist = new Lr(), this._densifyFrac = 0; const t = arguments[0]; const e = arguments[1]; this._g0 = t, this._g1 = e }; const Tr = { MaxPointDistanceFilter: { configurable: !0 }, MaxDensifiedByFractionDistanceFilter: { configurable: !0 } }; Ar.prototype.getCoordinates = function () { return this._ptDist.getCoordinates() }, Ar.prototype.setDensifyFraction = function (t) { if (t > 1 || t <= 0) throw new _('Fraction is not in range (0.0 - 1.0]'); this._densifyFrac = t }, Ar.prototype.compute = function (t, e) { this.computeOrientedDistance(t, e, this._ptDist), this.computeOrientedDistance(e, t, this._ptDist) }, Ar.prototype.distance = function () { return this.compute(this._g0, this._g1), this._ptDist.getDistance() }, Ar.prototype.computeOrientedDistance = function (t, e, n) { const r = new Dr(e); if (t.apply(r), n.setMaximum(r.getMaxPointDistance()), this._densifyFrac > 0) { const i = new Fr(e, this._densifyFrac); t.apply(i), n.setMaximum(i.getMaxPointDistance()) } }, Ar.prototype.orientedDistance = function () { return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance() }, Ar.prototype.interfaces_ = function () { return [] }, Ar.prototype.getClass = function () { return Ar }, Ar.distance = function () { if (arguments.length === 2) return new Ar(arguments[0], arguments[1]).distance(); if (arguments.length === 3) { const t = arguments[2]; const e = new Ar(arguments[0], arguments[1]); return e.setDensifyFraction(t), e.distance() } }, Tr.MaxPointDistanceFilter.get = function () { return Dr }, Tr.MaxDensifiedByFractionDistanceFilter.get = function () { return Fr }, Object.defineProperties(Ar, Tr); var Dr = function () { this._maxPtDist = new Lr(), this._minPtDist = new Lr(), this._euclideanDist = new Rr(), this._geom = null; const t = arguments[0]; this._geom = t }; Dr.prototype.filter = function (t) { this._minPtDist.initialize(), Rr.computeDistance(this._geom, t, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist) }, Dr.prototype.getMaxPointDistance = function () { return this._maxPtDist }, Dr.prototype.interfaces_ = function () { return [pt] }, Dr.prototype.getClass = function () { return Dr }; var Fr = function () { this._maxPtDist = new Lr(), this._minPtDist = new Lr(), this._geom = null, this._numSubSegs = 0; const t = arguments[0]; const e = arguments[1]; this._geom = t, this._numSubSegs = Math.trunc(Math.round(1 / e)) }; Fr.prototype.filter = function (t, e) { if (e === 0) return null; for (let n = t.getCoordinate(e - 1), r = t.getCoordinate(e), i = (r.x - n.x) / this._numSubSegs, o = (r.y - n.y) / this._numSubSegs, s = 0; s < this._numSubSegs; s++) { const a = n.x + s * i; const u = n.y + s * o; const l = new I(a, u); this._minPtDist.initialize(), Rr.computeDistance(this._geom, l, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist) } }, Fr.prototype.isDone = function () { return !1 }, Fr.prototype.isGeometryChanged = function () { return !1 }, Fr.prototype.getMaxPointDistance = function () { return this._maxPtDist }, Fr.prototype.interfaces_ = function () { return [Bt] }, Fr.prototype.getClass = function () { return Fr }; const jr = function (t, e, n) { this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = !0, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._bufDistance = e || null, this._result = n || null }; const kr = { VERBOSE: { configurable: !0 }, MAX_DISTANCE_DIFF_FRAC: { configurable: !0 } }; jr.prototype.checkMaximumDistance = function (t, e, n) { const r = new Ar(e, t); if (r.setDensifyFraction(0.25), this._maxDistanceFound = r.orientedDistance(), this._maxDistanceFound > n) { this._isValid = !1; const i = r.getCoordinates(); this._errorLocation = i[1], this._errorIndicator = t.getFactory().createLineString(i), this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + Q.toLineString(i[0], i[1]) + ')' } }, jr.prototype.isValid = function () { const t = Math.abs(this._bufDistance); const e = jr.MAX_DISTANCE_DIFF_FRAC * t; return this._minValidDistance = t - e, this._maxValidDistance = t + e, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), jr.VERBOSE && X.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid) }, jr.prototype.checkNegativeValid = function () { if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt)) return null; const t = this.getPolygonLines(this._input); if (this.checkMinimumDistance(t, this._result, this._minValidDistance), !this._isValid) return null; this.checkMaximumDistance(t, this._result, this._maxValidDistance) }, jr.prototype.getErrorIndicator = function () { return this._errorIndicator }, jr.prototype.checkMinimumDistance = function (t, e, n) { const r = new Or(t, e, n); if (this._minDistanceFound = r.distance(), this._minDistanceFound < n) { this._isValid = !1; const i = r.nearestPoints(); this._errorLocation = r.nearestPoints()[1], this._errorIndicator = t.getFactory().createLineString(i), this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + Q.toLineString(i[0], i[1]) + ' )' } }, jr.prototype.checkPositiveValid = function () { const t = this._result.getBoundary(); if (this.checkMinimumDistance(this._input, t, this._minValidDistance), !this._isValid) return null; this.checkMaximumDistance(this._input, t, this._maxValidDistance) }, jr.prototype.getErrorLocation = function () { return this._errorLocation }, jr.prototype.getPolygonLines = function (t) { for (var e = new wt(), n = new Ir(e), r = wr.getPolygons(t).iterator(); r.hasNext();)r.next().apply(n); return t.getFactory().buildGeometry(e) }, jr.prototype.getErrorMessage = function () { return this._errMsg }, jr.prototype.interfaces_ = function () { return [] }, jr.prototype.getClass = function () { return jr }, kr.VERBOSE.get = function () { return !1 }, kr.MAX_DISTANCE_DIFF_FRAC.get = function () { return 0.012 }, Object.defineProperties(jr, kr); const Gr = function (t, e, n) { this._isValid = !0, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t || null, this._distance = e || null, this._result = n || null }; const qr = { VERBOSE: { configurable: !0 }, MAX_ENV_DIFF_FRAC: { configurable: !0 } }; Gr.prototype.isValid = function () { return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid }, Gr.prototype.checkEnvelope = function () { if (this._distance < 0) return null; let t = this._distance * Gr.MAX_ENV_DIFF_FRAC; t === 0 && (t = 0.001); const e = new V(this._input.getEnvelopeInternal()); e.expandBy(this._distance); const n = new V(this._result.getEnvelopeInternal()); n.expandBy(t), n.contains(e) || (this._isValid = !1, this._errorMsg = 'Buffer envelope is incorrect', this._errorIndicator = this._input.getFactory().toGeometry(n)), this.report('Envelope') }, Gr.prototype.checkDistance = function () { const t = new jr(this._input, this._distance, this._result); t.isValid() || (this._isValid = !1, this._errorMsg = t.getErrorMessage(), this._errorLocation = t.getErrorLocation(), this._errorIndicator = t.getErrorIndicator()), this.report('Distance') }, Gr.prototype.checkArea = function () { const t = this._input.getArea(); const e = this._result.getArea(); this._distance > 0 && t > e && (this._isValid = !1, this._errorMsg = 'Area of positive buffer is smaller than input', this._errorIndicator = this._result), this._distance < 0 && t < e && (this._isValid = !1, this._errorMsg = 'Area of negative buffer is larger than input', this._errorIndicator = this._result), this.report('Area') }, Gr.prototype.checkPolygonal = function () { this._result instanceof $t || this._result instanceof ne || (this._isValid = !1), this._errorMsg = 'Result is not polygonal', this._errorIndicator = this._result, this.report('Polygonal') }, Gr.prototype.getErrorIndicator = function () { return this._errorIndicator }, Gr.prototype.getErrorLocation = function () { return this._errorLocation }, Gr.prototype.checkExpectedEmpty = function () { return this._input.getDimension() >= 2 || this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = !1, this._errorMsg = 'Result is non-empty', this._errorIndicator = this._result), void this.report('ExpectedEmpty')) }, Gr.prototype.report = function (t) { if (!Gr.VERBOSE) return null; X.out.println('Check ' + t + ': ' + (this._isValid ? 'passed' : 'FAILED')) }, Gr.prototype.getErrorMessage = function () { return this._errorMsg }, Gr.prototype.interfaces_ = function () { return [] }, Gr.prototype.getClass = function () { return Gr }, Gr.isValidMsg = function (t, e, n) { const r = new Gr(t, e, n); return r.isValid() ? null : r.getErrorMessage() }, Gr.isValid = function (t, e, n) { return !!new Gr(t, e, n).isValid() }, qr.VERBOSE.get = function () { return !1 }, qr.MAX_ENV_DIFF_FRAC.get = function () { return 0.012 }, Object.defineProperties(Gr, qr); const Br = function () { this._pts = null, this._data = null; const t = arguments[0]; const e = arguments[1]; this._pts = t, this._data = e }; Br.prototype.getCoordinates = function () { return this._pts }, Br.prototype.size = function () { return this._pts.length }, Br.prototype.getCoordinate = function (t) { return this._pts[t] }, Br.prototype.isClosed = function () { return this._pts[0].equals(this._pts[this._pts.length - 1]) }, Br.prototype.getSegmentOctant = function (t) { return t === this._pts.length - 1 ? -1 : fn.octant(this.getCoordinate(t), this.getCoordinate(t + 1)) }, Br.prototype.setData = function (t) { this._data = t }, Br.prototype.getData = function () { return this._data }, Br.prototype.toString = function () { return Q.toLineString(new ue(this._pts)) }, Br.prototype.interfaces_ = function () { return [hn] }, Br.prototype.getClass = function () { return Br }; const zr = function () { this._findAllIntersections = !1, this._isCheckEndSegmentsOnly = !1, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new wt(), this._intersectionCount = 0, this._keepIntersections = !0; const t = arguments[0]; this._li = t, this._interiorIntersection = null }; zr.prototype.getInteriorIntersection = function () { return this._interiorIntersection }, zr.prototype.setCheckEndSegmentsOnly = function (t) { this._isCheckEndSegmentsOnly = t }, zr.prototype.getIntersectionSegments = function () { return this._intSegments }, zr.prototype.count = function () { return this._intersectionCount }, zr.prototype.getIntersections = function () { return this._intersections }, zr.prototype.setFindAllIntersections = function (t) { this._findAllIntersections = t }, zr.prototype.setKeepIntersections = function (t) { this._keepIntersections = t }, zr.prototype.processIntersections = function (t, e, n, r) { if (!this._findAllIntersections && this.hasIntersection()) return null; if (t === n && e === r) return null; if (this._isCheckEndSegmentsOnly && !this.isEndSegment(t, e) && !this.isEndSegment(n, r)) return null; const i = t.getCoordinates()[e]; const o = t.getCoordinates()[e + 1]; const s = n.getCoordinates()[r]; const a = n.getCoordinates()[r + 1]; this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = i, this._intSegments[1] = o, this._intSegments[2] = s, this._intSegments[3] = a, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++) }, zr.prototype.isEndSegment = function (t, e) { return e === 0 || e >= t.size() - 2 }, zr.prototype.hasIntersection = function () { return this._interiorIntersection !== null }, zr.prototype.isDone = function () { return !this._findAllIntersections && this._interiorIntersection !== null }, zr.prototype.interfaces_ = function () { return [Hn] }, zr.prototype.getClass = function () { return zr }, zr.createAllIntersectionsFinder = function (t) { const e = new zr(t); return e.setFindAllIntersections(!0), e }, zr.createAnyIntersectionFinder = function (t) { return new zr(t) }, zr.createIntersectionCounter = function (t) { const e = new zr(t); return e.setFindAllIntersections(!0), e.setKeepIntersections(!1), e }; const Ur = function () { this._li = new it(), this._segStrings = null, this._findAllIntersections = !1, this._segInt = null, this._isValid = !0; const t = arguments[0]; this._segStrings = t }; Ur.prototype.execute = function () { if (this._segInt !== null) return null; this.checkInteriorIntersections() }, Ur.prototype.getIntersections = function () { return this._segInt.getIntersections() }, Ur.prototype.isValid = function () { return this.execute(), this._isValid }, Ur.prototype.setFindAllIntersections = function (t) { this._findAllIntersections = t }, Ur.prototype.checkInteriorIntersections = function () { this._isValid = !0, this._segInt = new zr(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections); const t = new En(); if (t.setSegmentIntersector(this._segInt), t.computeNodes(this._segStrings), this._segInt.hasIntersection()) return this._isValid = !1, null }, Ur.prototype.checkValid = function () { if (this.execute(), !this._isValid) throw new Ce(this.getErrorMessage(), this._segInt.getInteriorIntersection()) }, Ur.prototype.getErrorMessage = function () { if (this._isValid) return 'no intersections found'; const t = this._segInt.getIntersectionSegments(); return 'found non-noded intersection between ' + Q.toLineString(t[0], t[1]) + ' and ' + Q.toLineString(t[2], t[3]) }, Ur.prototype.interfaces_ = function () { return [] }, Ur.prototype.getClass = function () { return Ur }, Ur.computeIntersections = function (t) { const e = new Ur(t); return e.setFindAllIntersections(!0), e.isValid(), e.getIntersections() }; const Xr = function t () { this._nv = null; const e = arguments[0]; this._nv = new Ur(t.toSegmentStrings(e)) }; Xr.prototype.checkValid = function () { this._nv.checkValid() }, Xr.prototype.interfaces_ = function () { return [] }, Xr.prototype.getClass = function () { return Xr }, Xr.toSegmentStrings = function (t) { for (var e = new wt(), n = t.iterator(); n.hasNext();) { const r = n.next(); e.add(new Br(r.getCoordinates(), r)) } return e }, Xr.checkValid = function (t) { new Xr(t).checkValid() }; const Yr = function (t) { this._mapOp = t }; Yr.prototype.map = function (t) { for (var e = new wt(), n = 0; n < t.getNumGeometries(); n++) { const r = this._mapOp.map(t.getGeometryN(n)); r.isEmpty() || e.add(r) } return t.getFactory().createGeometryCollection(ve.toGeometryArray(e)) }, Yr.prototype.interfaces_ = function () { return [] }, Yr.prototype.getClass = function () { return Yr }, Yr.map = function (t, e) { return new Yr(e).map(t) }; const Vr = function () { this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new wt(), this._resultLineList = new wt(); const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; this._op = t, this._geometryFactory = e, this._ptLocator = n }; Vr.prototype.collectLines = function (t) { for (let e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) { const n = e.next(); this.collectLineEdge(n, t, this._lineEdgesList), this.collectBoundaryTouchEdge(n, t, this._lineEdgesList) } }, Vr.prototype.labelIsolatedLine = function (t, e) { const n = this._ptLocator.locate(t.getCoordinate(), this._op.getArgGeometry(e)); t.getLabel().setLocation(e, n) }, Vr.prototype.build = function (t) { return this.findCoveredLineEdges(), this.collectLines(t), this.buildLines(t), this._resultLineList }, Vr.prototype.collectLineEdge = function (t, e, n) { const r = t.getLabel(); const i = t.getEdge(); t.isLineEdge() && (t.isVisited() || !Ni.isResultOfOp(r, e) || i.isCovered() || (n.add(i), t.setVisitedEdge(!0))) }, Vr.prototype.findCoveredLineEdges = function () { for (let t = this._op.getGraph().getNodes().iterator(); t.hasNext();)t.next().getEdges().findCoveredLineEdges(); for (let e = this._op.getGraph().getEdgeEnds().iterator(); e.hasNext();) { const n = e.next(); const r = n.getEdge(); if (n.isLineEdge() && !r.isCoveredSet()) { const i = this._op.isCoveredByA(n.getCoordinate()); r.setCovered(i) } } }, Vr.prototype.labelIsolatedLines = function (t) { for (let e = t.iterator(); e.hasNext();) { const n = e.next(); const r = n.getLabel(); n.isIsolated() && (r.isNull(0) ? this.labelIsolatedLine(n, 0) : this.labelIsolatedLine(n, 1)) } }, Vr.prototype.buildLines = function (t) { for (let e = this._lineEdgesList.iterator(); e.hasNext();) { const n = e.next(); const r = this._geometryFactory.createLineString(n.getCoordinates()); this._resultLineList.add(r), n.setInResult(!0) } }, Vr.prototype.collectBoundaryTouchEdge = function (t, e, n) { const r = t.getLabel(); return t.isLineEdge() || t.isVisited() || t.isInteriorAreaEdge() || t.getEdge().isInResult() ? null : (et.isTrue(!(t.isInResult() || t.getSym().isInResult()) || !t.getEdge().isInResult()), void (Ni.isResultOfOp(r, e) && e === Ni.INTERSECTION && (n.add(t.getEdge()), t.setVisitedEdge(!0)))) }, Vr.prototype.interfaces_ = function () { return [] }, Vr.prototype.getClass = function () { return Vr }; const Wr = function () { this._op = null, this._geometryFactory = null, this._resultPointList = new wt(); const t = arguments[0]; const e = arguments[1]; this._op = t, this._geometryFactory = e }; Wr.prototype.filterCoveredNodeToPoint = function (t) { const e = t.getCoordinate(); if (!this._op.isCoveredByLA(e)) { const n = this._geometryFactory.createPoint(e); this._resultPointList.add(n) } }, Wr.prototype.extractNonCoveredResultNodes = function (t) { for (let e = this._op.getGraph().getNodes().iterator(); e.hasNext();) { const n = e.next(); if (!(n.isInResult() || n.isIncidentEdgeInResult() || n.getEdges().getDegree() !== 0 && t !== Ni.INTERSECTION)) { const r = n.getLabel(); Ni.isResultOfOp(r, t) && this.filterCoveredNodeToPoint(n) } } }, Wr.prototype.build = function (t) { return this.extractNonCoveredResultNodes(t), this._resultPointList }, Wr.prototype.interfaces_ = function () { return [] }, Wr.prototype.getClass = function () { return Wr }; const Hr = function () { this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = !0, this._preserveGeometryCollectionType = !0, this._preserveCollections = !1, this._preserveType = !1 }; Hr.prototype.transformPoint = function (t, e) { return this._factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(), t)) }, Hr.prototype.transformPolygon = function (t, e) { let n = !0; const r = this.transformLinearRing(t.getExteriorRing(), t); r !== null && r instanceof ee && !r.isEmpty() || (n = !1); for (var i = new wt(), o = 0; o < t.getNumInteriorRing(); o++) { const s = this.transformLinearRing(t.getInteriorRingN(o), t); s === null || s.isEmpty() || (s instanceof ee || (n = !1), i.add(s)) } if (n) return this._factory.createPolygon(r, i.toArray([])); const a = new wt(); return r !== null && a.add(r), a.addAll(i), this._factory.buildGeometry(a) }, Hr.prototype.createCoordinateSequence = function (t) { return this._factory.getCoordinateSequenceFactory().create(t) }, Hr.prototype.getInputGeometry = function () { return this._inputGeom }, Hr.prototype.transformMultiLineString = function (t, e) { for (var n = new wt(), r = 0; r < t.getNumGeometries(); r++) { const i = this.transformLineString(t.getGeometryN(r), t); i !== null && (i.isEmpty() || n.add(i)) } return this._factory.buildGeometry(n) }, Hr.prototype.transformCoordinates = function (t, e) { return this.copy(t) }, Hr.prototype.transformLineString = function (t, e) { return this._factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(), t)) }, Hr.prototype.transformMultiPoint = function (t, e) { for (var n = new wt(), r = 0; r < t.getNumGeometries(); r++) { const i = this.transformPoint(t.getGeometryN(r), t); i !== null && (i.isEmpty() || n.add(i)) } return this._factory.buildGeometry(n) }, Hr.prototype.transformMultiPolygon = function (t, e) { for (var n = new wt(), r = 0; r < t.getNumGeometries(); r++) { const i = this.transformPolygon(t.getGeometryN(r), t); i !== null && (i.isEmpty() || n.add(i)) } return this._factory.buildGeometry(n) }, Hr.prototype.copy = function (t) { return t.copy() }, Hr.prototype.transformGeometryCollection = function (t, e) { for (var n = new wt(), r = 0; r < t.getNumGeometries(); r++) { const i = this.transform(t.getGeometryN(r)); i !== null && (this._pruneEmptyGeometry && i.isEmpty() || n.add(i)) } return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(ve.toGeometryArray(n)) : this._factory.buildGeometry(n) }, Hr.prototype.transform = function (t) { if (this._inputGeom = t, this._factory = t.getFactory(), t instanceof Kt) return this.transformPoint(t, null); if (t instanceof te) return this.transformMultiPoint(t, null); if (t instanceof ee) return this.transformLinearRing(t, null); if (t instanceof Jt) return this.transformLineString(t, null); if (t instanceof Ut) return this.transformMultiLineString(t, null); if (t instanceof $t) return this.transformPolygon(t, null); if (t instanceof ne) return this.transformMultiPolygon(t, null); if (t instanceof zt) return this.transformGeometryCollection(t, null); throw new _('Unknown Geometry subtype: ' + t.getClass().getName()) }, Hr.prototype.transformLinearRing = function (t, e) { const n = this.transformCoordinates(t.getCoordinateSequence(), t); if (n === null) return this._factory.createLinearRing(null); const r = n.size(); return r > 0 && r < 4 && !this._preserveType ? this._factory.createLineString(n) : this._factory.createLinearRing(n) }, Hr.prototype.interfaces_ = function () { return [] }, Hr.prototype.getClass = function () { return Hr }; const Jr = function t () { if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = !1, this._isClosed = !1, arguments[0] instanceof Jt && typeof arguments[1] === 'number') { const e = arguments[1]; t.call(this, arguments[0].getCoordinates(), e) } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') { const n = arguments[0]; const r = arguments[1]; this._srcPts = n, this._isClosed = t.isClosed(n), this._snapTolerance = r } }; Jr.prototype.snapVertices = function (t, e) { for (let n = this._isClosed ? t.size() - 1 : t.size(), r = 0; r < n; r++) { const i = t.get(r); const o = this.findSnapForVertex(i, e); o !== null && (t.set(r, new I(o)), r === 0 && this._isClosed && t.set(t.size() - 1, new I(o))) } }, Jr.prototype.findSnapForVertex = function (t, e) { for (let n = 0; n < e.length; n++) { if (t.equals2D(e[n])) return null; if (t.distance(e[n]) < this._snapTolerance) return e[n] } return null }, Jr.prototype.snapTo = function (t) { const e = new St(this._srcPts); return this.snapVertices(e, t), this.snapSegments(e, t), e.toCoordinateArray() }, Jr.prototype.snapSegments = function (t, e) { if (e.length === 0) return null; let n = e.length; e[0].equals2D(e[e.length - 1]) && (n = e.length - 1); for (let r = 0; r < n; r++) { const i = e[r]; const o = this.findSegmentIndexToSnap(i, t); o >= 0 && t.add(o + 1, new I(i), !1) } }, Jr.prototype.findSegmentIndexToSnap = function (t, e) { for (var n = m.MAX_VALUE, r = -1, i = 0; i < e.size() - 1; i++) { if (this._seg.p0 = e.get(i), this._seg.p1 = e.get(i + 1), this._seg.p0.equals2D(t) || this._seg.p1.equals2D(t)) { if (this._allowSnappingToSourceVertices) continue; return -1 } const o = this._seg.distance(t); o < this._snapTolerance && o < n && (n = o, r = i) } return r }, Jr.prototype.setAllowSnappingToSourceVertices = function (t) { this._allowSnappingToSourceVertices = t }, Jr.prototype.interfaces_ = function () { return [] }, Jr.prototype.getClass = function () { return Jr }, Jr.isClosed = function (t) { return !(t.length <= 1) && t[0].equals2D(t[t.length - 1]) }; const Zr = function (t) { this._srcGeom = t || null }; const Kr = { SNAP_PRECISION_FACTOR: { configurable: !0 } }; Zr.prototype.snapTo = function (t, e) { const n = this.extractTargetCoordinates(t); return new Qr(e, n).transform(this._srcGeom) }, Zr.prototype.snapToSelf = function (t, e) { const n = this.extractTargetCoordinates(this._srcGeom); const r = new Qr(t, n, !0).transform(this._srcGeom); let i = r; return e && O(i, Qt) && (i = r.buffer(0)), i }, Zr.prototype.computeSnapTolerance = function (t) { return this.computeMinimumSegmentLength(t) / 10 }, Zr.prototype.extractTargetCoordinates = function (t) { for (var e = new p(), n = t.getCoordinates(), r = 0; r < n.length; r++)e.add(n[r]); return e.toArray(new Array(0).fill(null)) }, Zr.prototype.computeMinimumSegmentLength = function (t) { for (var e = m.MAX_VALUE, n = 0; n < t.length - 1; n++) { const r = t[n].distance(t[n + 1]); r < e && (e = r) } return e }, Zr.prototype.interfaces_ = function () { return [] }, Zr.prototype.getClass = function () { return Zr }, Zr.snap = function (t, e, n) { const r = new Array(2).fill(null); const i = new Zr(t); r[0] = i.snapTo(e, n); const o = new Zr(e); return r[1] = o.snapTo(r[0], n), r }, Zr.computeOverlaySnapTolerance = function () { if (arguments.length === 1) { const t = arguments[0]; let e = Zr.computeSizeBasedSnapTolerance(t); const n = t.getPrecisionModel(); if (n.getType() === pe.FIXED) { const r = 1 / n.getScale() * 2 / 1.415; r > e && (e = r) } return e } if (arguments.length === 2) { const i = arguments[0]; const o = arguments[1]; return Math.min(Zr.computeOverlaySnapTolerance(i), Zr.computeOverlaySnapTolerance(o)) } }, Zr.computeSizeBasedSnapTolerance = function (t) { const e = t.getEnvelopeInternal(); return Math.min(e.getHeight(), e.getWidth()) * Zr.SNAP_PRECISION_FACTOR }, Zr.snapToSelf = function (t, e, n) { return new Zr(t).snapToSelf(e, n) }, Kr.SNAP_PRECISION_FACTOR.get = function () { return 1e-9 }, Object.defineProperties(Zr, Kr); var Qr = (function (t) { function e (e, n, r) { t.call(this), this._snapTolerance = e || null, this._snapPts = n || null, this._isSelfSnap = void 0 !== r && r } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.snapLine = function (t, e) { const n = new Jr(t, this._snapTolerance); return n.setAllowSnappingToSourceVertices(this._isSelfSnap), n.snapTo(e) }, e.prototype.transformCoordinates = function (t, e) { const n = t.toCoordinateArray(); const r = this.snapLine(n, this._snapPts); return this._factory.getCoordinateSequenceFactory().create(r) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Hr)); const $r = function () { this._isFirst = !0, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null }; $r.prototype.getCommon = function () { return m.longBitsToDouble(this._commonBits) }, $r.prototype.add = function (t) { const e = m.doubleToLongBits(t); return this._isFirst ? (this._commonBits = e, this._commonSignExp = $r.signExpBits(this._commonBits), this._isFirst = !1, null) : $r.signExpBits(e) !== this._commonSignExp ? (this._commonBits = 0, null) : (this._commonMantissaBitsCount = $r.numCommonMostSigMantissaBits(this._commonBits, e), void (this._commonBits = $r.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount)))) }, $r.prototype.toString = function () { if (arguments.length === 1) { const t = arguments[0]; const e = m.longBitsToDouble(t); const n = '0000000000000000000000000000000000000000000000000000000000000000' + m.toBinaryString(t); const r = n.substring(n.length - 64); return r.substring(0, 1) + '  ' + r.substring(1, 12) + '(exp) ' + r.substring(12) + ' [ ' + e + ' ]' } }, $r.prototype.interfaces_ = function () { return [] }, $r.prototype.getClass = function () { return $r }, $r.getBit = function (t, e) { return (t & 1 << e) != 0 ? 1 : 0 }, $r.signExpBits = function (t) { return t >> 52 }, $r.zeroLowerBits = function (t, e) { return t & ~((1 << e) - 1) }, $r.numCommonMostSigMantissaBits = function (t, e) { for (let n = 0, r = 52; r >= 0; r--) { if ($r.getBit(t, r) !== $r.getBit(e, r)) return n; n++ } return 52 }; const ti = function () { this._commonCoord = null, this._ccFilter = new ni() }; const ei = { CommonCoordinateFilter: { configurable: !0 }, Translater: { configurable: !0 } }; ti.prototype.addCommonBits = function (t) { const e = new ri(this._commonCoord); t.apply(e), t.geometryChanged() }, ti.prototype.removeCommonBits = function (t) { if (this._commonCoord.x === 0 && this._commonCoord.y === 0) return t; const e = new I(this._commonCoord); e.x = -e.x, e.y = -e.y; const n = new ri(e); return t.apply(n), t.geometryChanged(), t }, ti.prototype.getCommonCoordinate = function () { return this._commonCoord }, ti.prototype.add = function (t) { t.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate() }, ti.prototype.interfaces_ = function () { return [] }, ti.prototype.getClass = function () { return ti }, ei.CommonCoordinateFilter.get = function () { return ni }, ei.Translater.get = function () { return ri }, Object.defineProperties(ti, ei); var ni = function () { this._commonBitsX = new $r(), this._commonBitsY = new $r() }; ni.prototype.filter = function (t) { this._commonBitsX.add(t.x), this._commonBitsY.add(t.y) }, ni.prototype.getCommonCoordinate = function () { return new I(this._commonBitsX.getCommon(), this._commonBitsY.getCommon()) }, ni.prototype.interfaces_ = function () { return [pt] }, ni.prototype.getClass = function () { return ni }; var ri = function () { this.trans = null; const t = arguments[0]; this.trans = t }; ri.prototype.filter = function (t, e) { const n = t.getOrdinate(e, 0) + this.trans.x; const r = t.getOrdinate(e, 1) + this.trans.y; t.setOrdinate(e, 0, n), t.setOrdinate(e, 1, r) }, ri.prototype.isDone = function () { return !1 }, ri.prototype.isGeometryChanged = function () { return !0 }, ri.prototype.interfaces_ = function () { return [Bt] }, ri.prototype.getClass = function () { return ri }; const ii = function (t, e) { this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t, this._geom[1] = e, this.computeSnapTolerance() }; ii.prototype.selfSnap = function (t) { return new Zr(t).snapTo(t, this._snapTolerance) }, ii.prototype.removeCommonBits = function (t) { this._cbr = new ti(), this._cbr.add(t[0]), this._cbr.add(t[1]); const e = new Array(2).fill(null); return e[0] = this._cbr.removeCommonBits(t[0].copy()), e[1] = this._cbr.removeCommonBits(t[1].copy()), e }, ii.prototype.prepareResult = function (t) { return this._cbr.addCommonBits(t), t }, ii.prototype.getResultGeometry = function (t) { const e = this.snap(this._geom); const n = Ni.overlayOp(e[0], e[1], t); return this.prepareResult(n) }, ii.prototype.checkValid = function (t) { t.isValid() || X.out.println('Snapped geometry is invalid') }, ii.prototype.computeSnapTolerance = function () { this._snapTolerance = Zr.computeOverlaySnapTolerance(this._geom[0], this._geom[1]) }, ii.prototype.snap = function (t) { const e = this.removeCommonBits(t); return Zr.snap(e[0], e[1], this._snapTolerance) }, ii.prototype.interfaces_ = function () { return [] }, ii.prototype.getClass = function () { return ii }, ii.overlayOp = function (t, e, n) { return new ii(t, e).getResultGeometry(n) }, ii.union = function (t, e) { return ii.overlayOp(t, e, Ni.UNION) }, ii.intersection = function (t, e) { return ii.overlayOp(t, e, Ni.INTERSECTION) }, ii.symDifference = function (t, e) { return ii.overlayOp(t, e, Ni.SYMDIFFERENCE) }, ii.difference = function (t, e) { return ii.overlayOp(t, e, Ni.DIFFERENCE) }; const oi = function (t, e) { this._geom = new Array(2).fill(null), this._geom[0] = t, this._geom[1] = e }; oi.prototype.getResultGeometry = function (t) { let e = null; let n = !1; let r = null; try { e = Ni.overlayOp(this._geom[0], this._geom[1], t), n = !0 } catch (t) { if (!(t instanceof $)) throw t; r = t } if (!n) try { e = ii.overlayOp(this._geom[0], this._geom[1], t) } catch (t) { throw t instanceof $ ? r : t } return e }, oi.prototype.interfaces_ = function () { return [] }, oi.prototype.getClass = function () { return oi }, oi.overlayOp = function (t, e, n) { return new oi(t, e).getResultGeometry(n) }, oi.union = function (t, e) { return oi.overlayOp(t, e, Ni.UNION) }, oi.intersection = function (t, e) { return oi.overlayOp(t, e, Ni.INTERSECTION) }, oi.symDifference = function (t, e) { return oi.overlayOp(t, e, Ni.SYMDIFFERENCE) }, oi.difference = function (t, e) { return oi.overlayOp(t, e, Ni.DIFFERENCE) }; const si = function () { this.mce = null, this.chainIndex = null; const t = arguments[0]; const e = arguments[1]; this.mce = t, this.chainIndex = e }; si.prototype.computeIntersections = function (t, e) { this.mce.computeIntersectsForChain(this.chainIndex, t.mce, t.chainIndex, e) }, si.prototype.interfaces_ = function () { return [] }, si.prototype.getClass = function () { return si }; const ai = function t () { if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; this._eventType = t.DELETE, this._xValue = e, this._insertEvent = n } else if (arguments.length === 3) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; this._eventType = t.INSERT, this._label = r, this._xValue = i, this._obj = o } }; const ui = { INSERT: { configurable: !0 }, DELETE: { configurable: !0 } }; ai.prototype.isDelete = function () { return this._eventType === ai.DELETE }, ai.prototype.setDeleteEventIndex = function (t) { this._deleteEventIndex = t }, ai.prototype.getObject = function () { return this._obj }, ai.prototype.compareTo = function (t) { const e = t; return this._xValue < e._xValue ? -1 : this._xValue > e._xValue ? 1 : this._eventType < e._eventType ? -1 : this._eventType > e._eventType ? 1 : 0 }, ai.prototype.getInsertEvent = function () { return this._insertEvent }, ai.prototype.isInsert = function () { return this._eventType === ai.INSERT }, ai.prototype.isSameLabel = function (t) { return this._label !== null && this._label === t._label }, ai.prototype.getDeleteEventIndex = function () { return this._deleteEventIndex }, ai.prototype.interfaces_ = function () { return [b] }, ai.prototype.getClass = function () { return ai }, ui.INSERT.get = function () { return 1 }, ui.DELETE.get = function () { return 2 }, Object.defineProperties(ai, ui); const li = function () {}; li.prototype.interfaces_ = function () { return [] }, li.prototype.getClass = function () { return li }; const ci = function () { this._hasIntersection = !1, this._hasProper = !1, this._hasProperInterior = !1, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = !1, this._isDoneWhenProperInt = !1; const t = arguments[0]; const e = arguments[1]; const n = arguments[2]; this._li = t, this._includeProper = e, this._recordIsolated = n }; ci.prototype.isTrivialIntersection = function (t, e, n, r) { if (t === n && this._li.getIntersectionNum() === 1) { if (ci.isAdjacentSegments(e, r)) return !0; if (t.isClosed()) { const i = t.getNumPoints() - 1; if (e === 0 && r === i || r === 0 && e === i) return !0 } } return !1 }, ci.prototype.getProperIntersectionPoint = function () { return this._properIntersectionPoint }, ci.prototype.setIsDoneIfProperInt = function (t) { this._isDoneWhenProperInt = t }, ci.prototype.hasProperInteriorIntersection = function () { return this._hasProperInterior }, ci.prototype.isBoundaryPointInternal = function (t, e) { for (let n = e.iterator(); n.hasNext();) { const r = n.next().getCoordinate(); if (t.isIntersection(r)) return !0 } return !1 }, ci.prototype.hasProperIntersection = function () { return this._hasProper }, ci.prototype.hasIntersection = function () { return this._hasIntersection }, ci.prototype.isDone = function () { return this._isDone }, ci.prototype.isBoundaryPoint = function (t, e) { return !(e === null || !this.isBoundaryPointInternal(t, e[0]) && !this.isBoundaryPointInternal(t, e[1])) }, ci.prototype.setBoundaryNodes = function (t, e) { this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t, this._bdyNodes[1] = e }, ci.prototype.addIntersections = function (t, e, n, r) { if (t === n && e === r) return null; this.numTests++; const i = t.getCoordinates()[e]; const o = t.getCoordinates()[e + 1]; const s = n.getCoordinates()[r]; const a = n.getCoordinates()[r + 1]; this._li.computeIntersection(i, o, s, a), this._li.hasIntersection() && (this._recordIsolated && (t.setIsolated(!1), n.setIsolated(!1)), this._numIntersections++, this.isTrivialIntersection(t, e, n, r) || (this._hasIntersection = !0, !this._includeProper && this._li.isProper() || (t.addIntersections(this._li, e, 0), n.addIntersections(this._li, r, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = !0, this._isDoneWhenProperInt && (this._isDone = !0), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = !0)))) }, ci.prototype.interfaces_ = function () { return [] }, ci.prototype.getClass = function () { return ci }, ci.isAdjacentSegments = function (t, e) { return Math.abs(t - e) === 1 }; const fi = (function (t) { function e () { t.call(this), this.events = new wt(), this.nOverlaps = null } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.prepareEvents = function () { $e.sort(this.events); for (let t = 0; t < this.events.size(); t++) { const e = this.events.get(t); e.isDelete() && e.getInsertEvent().setDeleteEventIndex(t) } }, e.prototype.computeIntersections = function () { if (arguments.length === 1) { const t = arguments[0]; this.nOverlaps = 0, this.prepareEvents(); for (let e = 0; e < this.events.size(); e++) { const n = this.events.get(e); if (n.isInsert() && this.processOverlaps(e, n.getDeleteEventIndex(), n, t), t.isDone()) break } } else if (arguments.length === 3) if (arguments[2] instanceof ci && O(arguments[0], Et) && O(arguments[1], Et)) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; this.addEdges(r, r), this.addEdges(i, i), this.computeIntersections(o) } else if (typeof arguments[2] === 'boolean' && O(arguments[0], Et) && arguments[1] instanceof ci) { const s = arguments[0]; const a = arguments[1]; arguments[2] ? this.addEdges(s, null) : this.addEdges(s), this.computeIntersections(a) } }, e.prototype.addEdge = function (t, e) { for (let n = t.getMonotoneChainEdge(), r = n.getStartIndexes(), i = 0; i < r.length - 1; i++) { const o = new si(n, i); const s = new ai(e, n.getMinX(i), o); this.events.add(s), this.events.add(new ai(n.getMaxX(i), s)) } }, e.prototype.processOverlaps = function (t, e, n, r) { for (let i = n.getObject(), o = t; o < e; o++) { const s = this.events.get(o); if (s.isInsert()) { const a = s.getObject(); n.isSameLabel(s) || (i.computeIntersections(a, r), this.nOverlaps++) } } }, e.prototype.addEdges = function () { if (arguments.length === 1) for (let t = arguments[0].iterator(); t.hasNext();) { const e = t.next(); this.addEdge(e, e) } else if (arguments.length === 2) for (let n = arguments[1], r = arguments[0].iterator(); r.hasNext();) { const i = r.next(); this.addEdge(i, n) } }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(li)); const hi = function () { this._min = m.POSITIVE_INFINITY, this._max = m.NEGATIVE_INFINITY }; const pi = { NodeComparator: { configurable: !0 } }; hi.prototype.getMin = function () { return this._min }, hi.prototype.intersects = function (t, e) { return !(this._min > e || this._max < t) }, hi.prototype.getMax = function () { return this._max }, hi.prototype.toString = function () { return Q.toLineString(new I(this._min, 0), new I(this._max, 0)) }, hi.prototype.interfaces_ = function () { return [] }, hi.prototype.getClass = function () { return hi }, pi.NodeComparator.get = function () { return gi }, Object.defineProperties(hi, pi); var gi = function () {}; gi.prototype.compare = function (t, e) { const n = t; const r = e; const i = (n._min + n._max) / 2; const o = (r._min + r._max) / 2; return i < o ? -1 : i > o ? 1 : 0 }, gi.prototype.interfaces_ = function () { return [w] }, gi.prototype.getClass = function () { return gi }; const di = (function (t) { function e () { t.call(this), this._item = null; const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; this._min = e, this._max = n, this._item = r } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.query = function (t, e, n) { if (!this.intersects(t, e)) return null; n.visitItem(this._item) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(hi)); const yi = (function (t) { function e () { t.call(this), this._node1 = null, this._node2 = null; const e = arguments[0]; const n = arguments[1]; this._node1 = e, this._node2 = n, this.buildExtent(this._node1, this._node2) } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.buildExtent = function (t, e) { this._min = Math.min(t._min, e._min), this._max = Math.max(t._max, e._max) }, e.prototype.query = function (t, e, n) { if (!this.intersects(t, e)) return null; this._node1 !== null && this._node1.query(t, e, n), this._node2 !== null && this._node2.query(t, e, n) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(hi)); const vi = function () { this._leaves = new wt(), this._root = null, this._level = 0 }; vi.prototype.buildTree = function () { $e.sort(this._leaves, new hi.NodeComparator()); for (let t = this._leaves, e = null, n = new wt(); ;) { if (this.buildLevel(t, n), n.size() === 1) return n.get(0); e = t, t = n, n = e } }, vi.prototype.insert = function (t, e, n) { if (this._root !== null) throw new Error('Index cannot be added to once it has been queried'); this._leaves.add(new di(t, e, n)) }, vi.prototype.query = function (t, e, n) { this.init(), this._root.query(t, e, n) }, vi.prototype.buildRoot = function () { if (this._root !== null) return null; this._root = this.buildTree() }, vi.prototype.printNode = function (t) { X.out.println(Q.toLineString(new I(t._min, this._level), new I(t._max, this._level))) }, vi.prototype.init = function () { if (this._root !== null) return null; this.buildRoot() }, vi.prototype.buildLevel = function (t, e) { this._level++, e.clear(); for (let n = 0; n < t.size(); n += 2) { const r = t.get(n); if ((n + 1 < t.size() ? t.get(n) : null) === null)e.add(r); else { const i = new yi(t.get(n), t.get(n + 1)); e.add(i) } } }, vi.prototype.interfaces_ = function () { return [] }, vi.prototype.getClass = function () { return vi }; const _i = function () { this._items = new wt() }; _i.prototype.visitItem = function (t) { this._items.add(t) }, _i.prototype.getItems = function () { return this._items }, _i.prototype.interfaces_ = function () { return [Je] }, _i.prototype.getClass = function () { return _i }; const mi = function () { this._index = null; const t = arguments[0]; if (!O(t, Qt)) throw new _('Argument must be Polygonal'); this._index = new Ei(t) }; const xi = { SegmentVisitor: { configurable: !0 }, IntervalIndexedGeometry: { configurable: !0 } }; mi.prototype.locate = function (t) { const e = new st(t); const n = new bi(e); return this._index.query(t.y, t.y, n), e.getLocation() }, mi.prototype.interfaces_ = function () { return [qn] }, mi.prototype.getClass = function () { return mi }, xi.SegmentVisitor.get = function () { return bi }, xi.IntervalIndexedGeometry.get = function () { return Ei }, Object.defineProperties(mi, xi); var bi = function () { this._counter = null; const t = arguments[0]; this._counter = t }; bi.prototype.visitItem = function (t) { const e = t; this._counter.countSegment(e.getCoordinate(0), e.getCoordinate(1)) }, bi.prototype.interfaces_ = function () { return [Je] }, bi.prototype.getClass = function () { return bi }; var Ei = function () { this._index = new vi(); const t = arguments[0]; this.init(t) }; Ei.prototype.init = function (t) { for (let e = Ir.getLines(t).iterator(); e.hasNext();) { const n = e.next().getCoordinates(); this.addLine(n) } }, Ei.prototype.addLine = function (t) { for (let e = 1; e < t.length; e++) { const n = new dn(t[e - 1], t[e]); const r = Math.min(n.p0.y, n.p1.y); const i = Math.max(n.p0.y, n.p1.y); this._index.insert(r, i, n) } }, Ei.prototype.query = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; const n = new _i(); return this._index.query(t, e, n), n.getItems() } if (arguments.length === 3) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; this._index.query(r, i, o) } }, Ei.prototype.interfaces_ = function () { return [] }, Ei.prototype.getClass = function () { return Ei }; const wi = (function (t) { function e () { if (t.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = !0, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = !1, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Sr(), arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; const r = gt.OGC_SFS_BOUNDARY_RULE; this._argIndex = e, this._parentGeom = n, this._boundaryNodeRule = r, n !== null && this.add(n) } else if (arguments.length === 3) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; this._argIndex = i, this._parentGeom = o, this._boundaryNodeRule = s, o !== null && this.add(o) } } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertBoundaryPoint = function (t, n) { const r = this._nodes.addNode(n).getLabel(); let i = 1; r.getLocation(t, Se.ON) === C.BOUNDARY && i++; const o = e.determineBoundary(this._boundaryNodeRule, i); r.setLocation(t, o) }, e.prototype.computeSelfNodes = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; return this.computeSelfNodes(t, e, !1) } if (arguments.length === 3) { const n = arguments[1]; const r = arguments[2]; const i = new ci(arguments[0], !0, !1); i.setIsDoneIfProperInt(r); const o = this.createEdgeSetIntersector(); const s = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne; const a = n || !s; return o.computeIntersections(this._edges, i, a), this.addSelfIntersectionNodes(this._argIndex), i } }, e.prototype.computeSplitEdges = function (t) { for (let e = this._edges.iterator(); e.hasNext();)e.next().eiList.addSplitEdges(t) }, e.prototype.computeEdgeIntersections = function (t, e, n) { const r = new ci(e, n, !0); return r.setBoundaryNodes(this.getBoundaryNodes(), t.getBoundaryNodes()), this.createEdgeSetIntersector().computeIntersections(this._edges, t._edges, r), r }, e.prototype.getGeometry = function () { return this._parentGeom }, e.prototype.getBoundaryNodeRule = function () { return this._boundaryNodeRule }, e.prototype.hasTooFewPoints = function () { return this._hasTooFewPoints }, e.prototype.addPoint = function () { if (arguments[0] instanceof Kt) { const t = arguments[0].getCoordinate(); this.insertPoint(this._argIndex, t, C.INTERIOR) } else if (arguments[0] instanceof I) { const e = arguments[0]; this.insertPoint(this._argIndex, e, C.INTERIOR) } }, e.prototype.addPolygon = function (t) { this.addPolygonRing(t.getExteriorRing(), C.EXTERIOR, C.INTERIOR); for (let e = 0; e < t.getNumInteriorRing(); e++) { const n = t.getInteriorRingN(e); this.addPolygonRing(n, C.INTERIOR, C.EXTERIOR) } }, e.prototype.addEdge = function (t) { this.insertEdge(t); const e = t.getCoordinates(); this.insertPoint(this._argIndex, e[0], C.BOUNDARY), this.insertPoint(this._argIndex, e[e.length - 1], C.BOUNDARY) }, e.prototype.addLineString = function (t) { const e = Nt.removeRepeatedPoints(t.getCoordinates()); if (e.length < 2) return this._hasTooFewPoints = !0, this._invalidPoint = e[0], null; const n = new nr(e, new Re(this._argIndex, C.INTERIOR)); this._lineEdgeMap.put(t, n), this.insertEdge(n), et.isTrue(e.length >= 2, 'found LineString with single point'), this.insertBoundaryPoint(this._argIndex, e[0]), this.insertBoundaryPoint(this._argIndex, e[e.length - 1]) }, e.prototype.getInvalidPoint = function () { return this._invalidPoint }, e.prototype.getBoundaryPoints = function () { for (var t = this.getBoundaryNodes(), e = new Array(t.size()).fill(null), n = 0, r = t.iterator(); r.hasNext();) { const i = r.next(); e[n++] = i.getCoordinate().copy() } return e }, e.prototype.getBoundaryNodes = function () { return this._boundaryNodes === null && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes }, e.prototype.addSelfIntersectionNode = function (t, e, n) { if (this.isBoundaryNode(t, e)) return null; n === C.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t, e) : this.insertPoint(t, e, n) }, e.prototype.addPolygonRing = function (t, e, n) { if (t.isEmpty()) return null; const r = Nt.removeRepeatedPoints(t.getCoordinates()); if (r.length < 4) return this._hasTooFewPoints = !0, this._invalidPoint = r[0], null; let i = e; let o = n; at.isCCW(r) && (i = n, o = e); const s = new nr(r, new Re(this._argIndex, C.BOUNDARY, i, o)); this._lineEdgeMap.put(t, s), this.insertEdge(s), this.insertPoint(this._argIndex, r[0], C.BOUNDARY) }, e.prototype.insertPoint = function (t, e, n) { const r = this._nodes.addNode(e); const i = r.getLabel(); i === null ? r._label = new Re(t, n) : i.setLocation(t, n) }, e.prototype.createEdgeSetIntersector = function () { return new fi() }, e.prototype.addSelfIntersectionNodes = function (t) { for (let e = this._edges.iterator(); e.hasNext();) for (let n = e.next(), r = n.getLabel().getLocation(t), i = n.eiList.iterator(); i.hasNext();) { const o = i.next(); this.addSelfIntersectionNode(t, o.coord, r) } }, e.prototype.add = function () { if (arguments.length !== 1) return t.prototype.add.apply(this, arguments); const e = arguments[0]; if (e.isEmpty()) return null; if (e instanceof ne && (this._useBoundaryDeterminationRule = !1), e instanceof $t) this.addPolygon(e); else if (e instanceof Jt) this.addLineString(e); else if (e instanceof Kt) this.addPoint(e); else if (e instanceof te) this.addCollection(e); else if (e instanceof Ut) this.addCollection(e); else if (e instanceof ne) this.addCollection(e); else { if (!(e instanceof zt)) throw new Error(e.getClass().getName()); this.addCollection(e) } }, e.prototype.addCollection = function (t) { for (let e = 0; e < t.getNumGeometries(); e++) { const n = t.getGeometryN(e); this.add(n) } }, e.prototype.locate = function (t) { return O(this._parentGeom, Qt) && this._parentGeom.getNumGeometries() > 50 ? (this._areaPtLocator === null && (this._areaPtLocator = new mi(this._parentGeom)), this._areaPtLocator.locate(t)) : this._ptLocator.locate(t, this._parentGeom) }, e.prototype.findEdge = function () { if (arguments.length === 1) { const e = arguments[0]; return this._lineEdgeMap.get(e) } return t.prototype.findEdge.apply(this, arguments) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e.determineBoundary = function (t, e) { return t.isInBoundary(e) ? C.BOUNDARY : C.INTERIOR }, e }(Xe)); const Ii = function () { if (this._li = new it(), this._resultPrecisionModel = null, this._arg = null, arguments.length === 1) { const t = arguments[0]; this.setComputationPrecision(t.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new wi(0, t) } else if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; const r = gt.OGC_SFS_BOUNDARY_RULE; e.getPrecisionModel().compareTo(n.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e.getPrecisionModel()) : this.setComputationPrecision(n.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new wi(0, e, r), this._arg[1] = new wi(1, n, r) } else if (arguments.length === 3) { const i = arguments[0]; const o = arguments[1]; const s = arguments[2]; i.getPrecisionModel().compareTo(o.getPrecisionModel()) >= 0 ? this.setComputationPrecision(i.getPrecisionModel()) : this.setComputationPrecision(o.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new wi(0, i, s), this._arg[1] = new wi(1, o, s) } }; Ii.prototype.getArgGeometry = function (t) { return this._arg[t].getGeometry() }, Ii.prototype.setComputationPrecision = function (t) { this._resultPrecisionModel = t, this._li.setPrecisionModel(this._resultPrecisionModel) }, Ii.prototype.interfaces_ = function () { return [] }, Ii.prototype.getClass = function () { return Ii }; const Si = function () {}; Si.prototype.interfaces_ = function () { return [] }, Si.prototype.getClass = function () { return Si }, Si.map = function () { if (arguments[0] instanceof ct && O(arguments[1], Si.MapOp)) { for (var t = arguments[0], e = arguments[1], n = new wt(), r = 0; r < t.getNumGeometries(); r++) { const i = e.map(t.getGeometryN(r)); i !== null && n.add(i) } return t.getFactory().buildGeometry(n) } if (O(arguments[0], xt) && O(arguments[1], Si.MapOp)) { for (var o = arguments[0], s = arguments[1], a = new wt(), u = o.iterator(); u.hasNext();) { const l = u.next(); const c = s.map(l); c !== null && a.add(c) } return a } }, Si.MapOp = function () {}; var Ni = (function (t) { function e () { const e = arguments[0]; const n = arguments[1]; t.call(this, e, n), this._ptLocator = new Sr(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Wn(), this._resultPolyList = new wt(), this._resultLineList = new wt(), this._resultPointList = new wt(), this._graph = new Xe(new Yn()), this._geomFact = e.getFactory() } return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.insertUniqueEdge = function (t) { const e = this._edgeList.findEqualEdge(t); if (e !== null) { const n = e.getLabel(); let r = t.getLabel(); e.isPointwiseEqual(t) || (r = new Re(t.getLabel())).flip(); const i = e.getDepth(); i.isNull() && i.add(n), i.add(r), n.merge(r) } else this._edgeList.add(t) }, e.prototype.getGraph = function () { return this._graph }, e.prototype.cancelDuplicateResultEdges = function () { for (let t = this._graph.getEdgeEnds().iterator(); t.hasNext();) { const e = t.next(); const n = e.getSym(); e.isInResult() && n.isInResult() && (e.setInResult(!1), n.setInResult(!1)) } }, e.prototype.isCoveredByLA = function (t) { return !!this.isCovered(t, this._resultLineList) || !!this.isCovered(t, this._resultPolyList) }, e.prototype.computeGeometry = function (t, n, r, i) { const o = new wt(); return o.addAll(t), o.addAll(n), o.addAll(r), o.isEmpty() ? e.createEmptyResult(i, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o) }, e.prototype.mergeSymLabels = function () { for (let t = this._graph.getNodes().iterator(); t.hasNext();)t.next().getEdges().mergeSymLabels() }, e.prototype.isCovered = function (t, e) { for (let n = e.iterator(); n.hasNext();) { const r = n.next(); if (this._ptLocator.locate(t, r) !== C.EXTERIOR) return !0 } return !1 }, e.prototype.replaceCollapsedEdges = function () { for (var t = new wt(), e = this._edgeList.iterator(); e.hasNext();) { const n = e.next(); n.isCollapsed() && (e.remove(), t.add(n.getCollapsedEdge())) } this._edgeList.addAll(t) }, e.prototype.updateNodeLabelling = function () { for (let t = this._graph.getNodes().iterator(); t.hasNext();) { const e = t.next(); const n = e.getEdges().getLabel(); e.getLabel().merge(n) } }, e.prototype.getResultGeometry = function (t) { return this.computeOverlay(t), this._resultGeom }, e.prototype.insertUniqueEdges = function (t) { for (let e = t.iterator(); e.hasNext();) { const n = e.next(); this.insertUniqueEdge(n) } }, e.prototype.computeOverlay = function (t) { this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, !1), this._arg[1].computeSelfNodes(this._li, !1), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, !0); const e = new wt(); this._arg[0].computeSplitEdges(e), this._arg[1].computeSplitEdges(e), this.insertUniqueEdges(e), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Xr.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t), this.cancelDuplicateResultEdges(); const n = new Ye(this._geomFact); n.add(this._graph), this._resultPolyList = n.getPolygons(); const r = new Vr(this, this._geomFact, this._ptLocator); this._resultLineList = r.build(t); const i = new Wr(this, this._geomFact, this._ptLocator); this._resultPointList = i.build(t), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t) }, e.prototype.labelIncompleteNode = function (t, e) { const n = this._ptLocator.locate(t.getCoordinate(), this._arg[e].getGeometry()); t.getLabel().setLocation(e, n) }, e.prototype.copyPoints = function (t) { for (let e = this._arg[t].getNodeIterator(); e.hasNext();) { const n = e.next(); this._graph.addNode(n.getCoordinate()).setLabel(t, n.getLabel().getLocation(t)) } }, e.prototype.findResultAreaEdges = function (t) { for (let n = this._graph.getEdgeEnds().iterator(); n.hasNext();) { const r = n.next(); const i = r.getLabel(); i.isArea() && !r.isInteriorAreaEdge() && e.isResultOfOp(i.getLocation(0, Se.RIGHT), i.getLocation(1, Se.RIGHT), t) && r.setInResult(!0) } }, e.prototype.computeLabelsFromDepths = function () { for (let t = this._edgeList.iterator(); t.hasNext();) { const e = t.next(); const n = e.getLabel(); const r = e.getDepth(); if (!r.isNull()) { r.normalize(); for (let i = 0; i < 2; i++)n.isNull(i) || !n.isArea() || r.isNull(i) || (r.getDelta(i) === 0 ? n.toLine(i) : (et.isTrue(!r.isNull(i, Se.LEFT), 'depth of LEFT side has not been initialized'), n.setLocation(i, Se.LEFT, r.getLocation(i, Se.LEFT)), et.isTrue(!r.isNull(i, Se.RIGHT), 'depth of RIGHT side has not been initialized'), n.setLocation(i, Se.RIGHT, r.getLocation(i, Se.RIGHT)))) } } }, e.prototype.computeLabelling = function () { for (let t = this._graph.getNodes().iterator(); t.hasNext();)t.next().getEdges().computeLabelling(this._arg); this.mergeSymLabels(), this.updateNodeLabelling() }, e.prototype.labelIncompleteNodes = function () { for (let t = this._graph.getNodes().iterator(); t.hasNext();) { const e = t.next(); const n = e.getLabel(); e.isIsolated() && (n.isNull(0) ? this.labelIncompleteNode(e, 0) : this.labelIncompleteNode(e, 1)), e.getEdges().updateLabelling(n) } }, e.prototype.isCoveredByA = function (t) { return !!this.isCovered(t, this._resultPolyList) }, e.prototype.interfaces_ = function () { return [] }, e.prototype.getClass = function () { return e }, e }(Ii)); Ni.overlayOp = function (t, e, n) { return new Ni(t, e).getResultGeometry(n) }, Ni.intersection = function (t, e) { if (t.isEmpty() || e.isEmpty()) return Ni.createEmptyResult(Ni.INTERSECTION, t, e, t.getFactory()); if (t.isGeometryCollection()) { const n = e; return Yr.map(t, { interfaces_: function () { return [Si.MapOp] }, map: function (t) { return t.intersection(n) } }) } return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), oi.overlayOp(t, e, Ni.INTERSECTION) }, Ni.symDifference = function (t, e) { if (t.isEmpty() || e.isEmpty()) { if (t.isEmpty() && e.isEmpty()) return Ni.createEmptyResult(Ni.SYMDIFFERENCE, t, e, t.getFactory()); if (t.isEmpty()) return e.copy(); if (e.isEmpty()) return t.copy() } return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), oi.overlayOp(t, e, Ni.SYMDIFFERENCE) }, Ni.resultDimension = function (t, e, n) { const r = e.getDimension(); const i = n.getDimension(); let o = -1; switch (t) { case Ni.INTERSECTION:o = Math.min(r, i); break; case Ni.UNION:o = Math.max(r, i); break; case Ni.DIFFERENCE:o = r; break; case Ni.SYMDIFFERENCE:o = Math.max(r, i) } return o }, Ni.createEmptyResult = function (t, e, n, r) { let i = null; switch (Ni.resultDimension(t, e, n)) { case -1:i = r.createGeometryCollection(new Array(0).fill(null)); break; case 0:i = r.createPoint(); break; case 1:i = r.createLineString(); break; case 2:i = r.createPolygon() } return i }, Ni.difference = function (t, e) { return t.isEmpty() ? Ni.createEmptyResult(Ni.DIFFERENCE, t, e, t.getFactory()) : e.isEmpty() ? t.copy() : (t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), oi.overlayOp(t, e, Ni.DIFFERENCE)) }, Ni.isResultOfOp = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; const n = t.getLocation(0); const r = t.getLocation(1); return Ni.isResultOfOp(n, r, e) } if (arguments.length === 3) { let i = arguments[0]; let o = arguments[1]; const s = arguments[2]; switch (i === C.BOUNDARY && (i = C.INTERIOR), o === C.BOUNDARY && (o = C.INTERIOR), s) { case Ni.INTERSECTION:return i === C.INTERIOR && o === C.INTERIOR; case Ni.UNION:return i === C.INTERIOR || o === C.INTERIOR; case Ni.DIFFERENCE:return i === C.INTERIOR && o !== C.INTERIOR; case Ni.SYMDIFFERENCE:return i === C.INTERIOR && o !== C.INTERIOR || i !== C.INTERIOR && o === C.INTERIOR } return !1 } }, Ni.INTERSECTION = 1, Ni.UNION = 2, Ni.DIFFERENCE = 3, Ni.SYMDIFFERENCE = 4; const Pi = function () { this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Sr(), this._seg = new dn(); const t = arguments[0]; const e = arguments[1]; this._g = t, this._boundaryDistanceTolerance = e, this._linework = this.extractLinework(t) }; Pi.prototype.isWithinToleranceOfBoundary = function (t) { for (let e = 0; e < this._linework.getNumGeometries(); e++) for (let n = this._linework.getGeometryN(e).getCoordinateSequence(), r = 0; r < n.size() - 1; r++) if (n.getCoordinate(r, this._seg.p0), n.getCoordinate(r + 1, this._seg.p1), this._seg.distance(t) <= this._boundaryDistanceTolerance) return !0; return !1 }, Pi.prototype.getLocation = function (t) { return this.isWithinToleranceOfBoundary(t) ? C.BOUNDARY : this._ptLocator.locate(t, this._g) }, Pi.prototype.extractLinework = function (t) { const e = new Ci(); t.apply(e); const n = e.getLinework(); const r = ve.toLineStringArray(n); return t.getFactory().createMultiLineString(r) }, Pi.prototype.interfaces_ = function () { return [] }, Pi.prototype.getClass = function () { return Pi }; var Ci = function () { this._linework = null, this._linework = new wt() }; Ci.prototype.getLinework = function () { return this._linework }, Ci.prototype.filter = function (t) { if (t instanceof $t) { const e = t; this._linework.add(e.getExteriorRing()); for (let n = 0; n < e.getNumInteriorRing(); n++) this._linework.add(e.getInteriorRingN(n)) } }, Ci.prototype.interfaces_ = function () { return [qt] }, Ci.prototype.getClass = function () { return Ci }; const Mi = function () { this._g = null, this._doLeft = !0, this._doRight = !0; const t = arguments[0]; this._g = t }; Mi.prototype.extractPoints = function (t, e, n) { for (let r = t.getCoordinates(), i = 0; i < r.length - 1; i++) this.computeOffsetPoints(r[i], r[i + 1], e, n) }, Mi.prototype.setSidesToGenerate = function (t, e) { this._doLeft = t, this._doRight = e }, Mi.prototype.getPoints = function (t) { for (var e = new wt(), n = Ir.getLines(this._g).iterator(); n.hasNext();) { const r = n.next(); this.extractPoints(r, t, e) } return e }, Mi.prototype.computeOffsetPoints = function (t, e, n, r) { const i = e.x - t.x; const o = e.y - t.y; const s = Math.sqrt(i * i + o * o); const a = n * i / s; const u = n * o / s; const l = (e.x + t.x) / 2; const c = (e.y + t.y) / 2; if (this._doLeft) { const f = new I(l - u, c + a); r.add(f) } if (this._doRight) { const h = new I(l + u, c - a); r.add(h) } }, Mi.prototype.interfaces_ = function () { return [] }, Mi.prototype.getClass = function () { return Mi }; const Oi = function t () { this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t.TOLERANCE, this._testCoords = new wt(); const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; this._boundaryDistanceTolerance = t.computeBoundaryDistanceTolerance(e, n), this._geom = [e, n, r], this._locFinder = [new Pi(this._geom[0], this._boundaryDistanceTolerance), new Pi(this._geom[1], this._boundaryDistanceTolerance), new Pi(this._geom[2], this._boundaryDistanceTolerance)] }; const Li = { TOLERANCE: { configurable: !0 } }; Oi.prototype.reportResult = function (t, e, n) { X.out.println('Overlay result invalid - A:' + C.toLocationSymbol(e[0]) + ' B:' + C.toLocationSymbol(e[1]) + ' expected:' + (n ? 'i' : 'e') + ' actual:' + C.toLocationSymbol(e[2])) }, Oi.prototype.isValid = function (t) { return this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]), this.checkValid(t) }, Oi.prototype.checkValid = function () { if (arguments.length === 1) { for (let t = arguments[0], e = 0; e < this._testCoords.size(); e++) { const n = this._testCoords.get(e); if (!this.checkValid(t, n)) return this._invalidLocation = n, !1 } return !0 } if (arguments.length === 2) { const r = arguments[0]; const i = arguments[1]; return this._location[0] = this._locFinder[0].getLocation(i), this._location[1] = this._locFinder[1].getLocation(i), this._location[2] = this._locFinder[2].getLocation(i), !!Oi.hasLocation(this._location, C.BOUNDARY) || this.isValidResult(r, this._location) } }, Oi.prototype.addTestPts = function (t) { const e = new Mi(t); this._testCoords.addAll(e.getPoints(5 * this._boundaryDistanceTolerance)) }, Oi.prototype.isValidResult = function (t, e) { const n = Ni.isResultOfOp(e[0], e[1], t); const r = !(n ^ e[2] === C.INTERIOR); return r || this.reportResult(t, e, n), r }, Oi.prototype.getInvalidLocation = function () { return this._invalidLocation }, Oi.prototype.interfaces_ = function () { return [] }, Oi.prototype.getClass = function () { return Oi }, Oi.hasLocation = function (t, e) { for (let n = 0; n < 3; n++) if (t[n] === e) return !0; return !1 }, Oi.computeBoundaryDistanceTolerance = function (t, e) { return Math.min(Zr.computeSizeBasedSnapTolerance(t), Zr.computeSizeBasedSnapTolerance(e)) }, Oi.isValid = function (t, e, n, r) { return new Oi(t, e, r).isValid(n) }, Li.TOLERANCE.get = function () { return 1e-6 }, Object.defineProperties(Oi, Li); const Ri = function t (e) { this._geomFactory = null, this._skipEmpty = !1, this._inputGeoms = null, this._geomFactory = t.extractFactory(e), this._inputGeoms = e }; Ri.prototype.extractElements = function (t, e) { if (t === null) return null; for (let n = 0; n < t.getNumGeometries(); n++) { const r = t.getGeometryN(n); this._skipEmpty && r.isEmpty() || e.add(r) } }, Ri.prototype.combine = function () { for (var t = new wt(), e = this._inputGeoms.iterator(); e.hasNext();) { const n = e.next(); this.extractElements(n, t) } return t.size() === 0 ? this._geomFactory !== null ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t) }, Ri.prototype.interfaces_ = function () { return [] }, Ri.prototype.getClass = function () { return Ri }, Ri.combine = function () { if (arguments.length === 1) return new Ri(arguments[0]).combine(); if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; return new Ri(Ri.createList(t, e)).combine() } if (arguments.length === 3) { const n = arguments[0]; const r = arguments[1]; const i = arguments[2]; return new Ri(Ri.createList(n, r, i)).combine() } }, Ri.extractFactory = function (t) { return t.isEmpty() ? null : t.iterator().next().getFactory() }, Ri.createList = function () { if (arguments.length === 2) { const t = arguments[0]; const e = arguments[1]; const n = new wt(); return n.add(t), n.add(e), n } if (arguments.length === 3) { const r = arguments[0]; const i = arguments[1]; const o = arguments[2]; const s = new wt(); return s.add(r), s.add(i), s.add(o), s } }; const Ai = function () { this._inputPolys = null, this._geomFactory = null; const t = arguments[0]; this._inputPolys = t, this._inputPolys === null && (this._inputPolys = new wt()) }; const Ti = { STRTREE_NODE_CAPACITY: { configurable: !0 } }; Ai.prototype.reduceToGeometries = function (t) { for (var e = new wt(), n = t.iterator(); n.hasNext();) { const r = n.next(); let i = null; O(r, Et) ? i = this.unionTree(r) : r instanceof ct && (i = r), e.add(i) } return e }, Ai.prototype.extractByEnvelope = function (t, e, n) { for (var r = new wt(), i = 0; i < e.getNumGeometries(); i++) { const o = e.getGeometryN(i); o.getEnvelopeInternal().intersects(t) ? r.add(o) : n.add(o) } return this._geomFactory.buildGeometry(r) }, Ai.prototype.unionOptimized = function (t, e) { const n = t.getEnvelopeInternal(); const r = e.getEnvelopeInternal(); if (!n.intersects(r)) return Ri.combine(t, e); if (t.getNumGeometries() <= 1 && e.getNumGeometries() <= 1) return this.unionActual(t, e); const i = n.intersection(r); return this.unionUsingEnvelopeIntersection(t, e, i) }, Ai.prototype.union = function () { if (this._inputPolys === null) throw new Error('union() method cannot be called twice'); if (this._inputPolys.isEmpty()) return null; this._geomFactory = this._inputPolys.iterator().next().getFactory(); for (var t = new sn(Ai.STRTREE_NODE_CAPACITY), e = this._inputPolys.iterator(); e.hasNext();) { const n = e.next(); t.insert(n.getEnvelopeInternal(), n) } this._inputPolys = null; const r = t.itemsTree(); return this.unionTree(r) }, Ai.prototype.binaryUnion = function () { if (arguments.length === 1) { const t = arguments[0]; return this.binaryUnion(t, 0, t.size()) } if (arguments.length === 3) { const e = arguments[0]; const n = arguments[1]; const r = arguments[2]; if (r - n <= 1) { const i = Ai.getGeometry(e, n); return this.unionSafe(i, null) } if (r - n == 2) return this.unionSafe(Ai.getGeometry(e, n), Ai.getGeometry(e, n + 1)); const o = Math.trunc((r + n) / 2); const s = this.binaryUnion(e, n, o); const a = this.binaryUnion(e, o, r); return this.unionSafe(s, a) } }, Ai.prototype.repeatedUnion = function (t) { for (var e = null, n = t.iterator(); n.hasNext();) { const r = n.next(); e = e === null ? r.copy() : e.union(r) } return e }, Ai.prototype.unionSafe = function (t, e) { return t === null && e === null ? null : t === null ? e.copy() : e === null ? t.copy() : this.unionOptimized(t, e) }, Ai.prototype.unionActual = function (t, e) { return Ai.restrictToPolygons(t.union(e)) }, Ai.prototype.unionTree = function (t) { const e = this.reduceToGeometries(t); return this.binaryUnion(e) }, Ai.prototype.unionUsingEnvelopeIntersection = function (t, e, n) { const r = new wt(); const i = this.extractByEnvelope(n, t, r); const o = this.extractByEnvelope(n, e, r); const s = this.unionActual(i, o); return r.add(s), Ri.combine(r) }, Ai.prototype.bufferUnion = function () { if (arguments.length === 1) { const t = arguments[0]; return t.get(0).getFactory().buildGeometry(t).buffer(0) } if (arguments.length === 2) { const e = arguments[0]; const n = arguments[1]; return e.getFactory().createGeometryCollection([e, n]).buffer(0) } }, Ai.prototype.interfaces_ = function () { return [] }, Ai.prototype.getClass = function () { return Ai }, Ai.restrictToPolygons = function (t) { if (O(t, Qt)) return t; const e = wr.getPolygons(t); return e.size() === 1 ? e.get(0) : t.getFactory().createMultiPolygon(ve.toPolygonArray(e)) }, Ai.getGeometry = function (t, e) { return e >= t.size() ? null : t.get(e) }, Ai.union = function (t) { return new Ai(t).union() }, Ti.STRTREE_NODE_CAPACITY.get = function () { return 4 }, Object.defineProperties(Ai, Ti); const Di = function () {}; Di.prototype.interfaces_ = function () { return [] }, Di.prototype.getClass = function () { return Di }, Di.union = function (t, e) { if (t.isEmpty() || e.isEmpty()) { if (t.isEmpty() && e.isEmpty()) return Ni.createEmptyResult(Ni.UNION, t, e, t.getFactory()); if (t.isEmpty()) return e.copy(); if (e.isEmpty()) return t.copy() } return t.checkNotGeometryCollection(t), t.checkNotGeometryCollection(e), oi.overlayOp(t, e, Ni.UNION) }, t.GeoJSONReader = we, t.GeoJSONWriter = Ie, t.OverlayOp = Ni, t.UnionOp = Di, t.BufferOp = dr, Object.defineProperty(t, '__esModule', { value: !0 }) }(e)) } }; const e = {}; function n (r) { const i = e[r]; if (void 0 !== i) return i.exports; const o = e[r] = { exports: {} }; return t[r].call(o.exports, o, o.exports, n), o.exports }n.d = (t, e) => { for (const r in e)n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, { enumerable: !0, get: e[r] }) }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.r = t => { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(t, '__esModule', { value: !0 }) }; const r = n(3607); module.exports.IndoorGraphs = r })()
